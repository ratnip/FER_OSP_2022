[["index.html", "Programirajmo u R-u (Udbenik za predmet Osnove statistikog programiranja) Predgovor", " Programirajmo u R-u Damir Pintar 2022-10-19 (Udbenik za predmet Osnove statistikog programiranja) ** NAPOMENA: Za vrijeme odvijanja predmeta Osnove statistikog programiranja u tekuoj akademskoj godini provodi se revizija poglavlja udbenika. Nakon to se materija odradi na predavanjima te zavri ciklus predaje radnih biljenica nova poglavlja e se dinamiki dodavati u ovaj HTML dokument. Ukoliko vam je nuno potreban pristup cjelokupnim materijalima kontaktirajte autora udbenika na damir.pintar@fer.hr ** Predgovor Ovaj udbenik nastao je iz interaktivnih lekcija koritenih na predmetu Osnove statistikog programiranja na Fakultetu elektrotehnike i raunarstva Sveuilita u Zagrebu. No teme koje se ovdje obrauju nisu korisne samo studentima navedenog fakulteta - poznavanje jezika R dobro e doi kako u akademskom, tako i u poslovnom svijetu. Iako je R poznat kao programski jezik napravljen od statistiara, za statistiare te se najee povezuje sa poljem podatkovne znanosti unutar kojeg se koristi za sloene statistike i dubinske analize, on se moe pokazati vrlo koristan i za poslove vezane uz upravljanje manjim ili veim podatkovnim skupovima koji nisu nuno strogo orijentirani naprednoj analitici. Naime, popularni grafiki alati sa svojim interaktivnim tablinim prikazom vrlo su intuitivni i odlini za jednostavnije poslove, no kako se pojavljuju potrebe za sloenijim zadacima oni vrlo brzo gube na uinkovitosti i jednostavnosti; s druge strane, interaktivni programski pristup kojeg nudi R inicijalno je neto zahtjevniji, no dugorono vrlo isplativ jer se i vrlo sloeni zadaci mogu rjeavati na uinkovit, konzistentan i pregledan nain. Upravo iz tog razloga u poslovnom svijetu pojavljuje se jasna tendencija odmaka od klasinih grafikih alata prema platformama sa boljom podrkom za provoenje sloenijih izrauna i stvaranje atraktivnih vizualizacija. Ovo se oituje snanim porastom popularnosti jezika R i drugih platformi sa slinim pristupom analizi podataka. Navedena popularnost jezika R rezultira i poveanom potrebom za resursima za uenje, kojih na hrvatskom jeziku trenutno nema ba previe. Ovaj udbenik svojim pristupom uenja kroz primjere pokuati e uenje R-a uiniti to lakim i zanimljivijim. Naglasak e biti stavljen prvenstveno na svladavanje R-a kao programskog jezika. Upravo zbog toga poetna poglavlja baviti e se poglavito programerskim aspektima, a potom e biti dan pregled dostupnih alata za zadatke za koje pretpostavlja da su korisni najirem skupu itatelja - upravljanje podatkovnim skupovima, izvlaenje korisnih informacija i stvaranje vizualizacija. Budui da je R ipak domenski orijentirani jezik, pria o R-u zaokruiti e se kratkim uvidom u njegovu podrku za statistike analize te pregledom odabranih metoda strojnog uenja i njihove primjene. Iako e biti dano dovoljno informacija da se sve prikazane metode stave u kontekst, ideja ovog udbenika nije nauiti itatelja statistiku niti duboko ui u polje strojnog uenja - namjera autora jest zaintrigirati itatelja da nastavi istraivanje ovog interesantnog podruja, adekvatno naoruanog znanjem platforme koje e omoguiti da sva novousvojena znanja odmah praktino primjeni u svojim daljnjim istraivanjima. "],["uvod.html", "1 Uvod 1.1 to je programski jezik R? 1.2 Instalacija programske podrke 1.3 Pregled razvojnog suelja RStudio 1.4 Kako koristiti ovaj udbenik?", " 1 Uvod 1.1 to je programski jezik R? 1.1.1 Openito o R-u Programski jezik R proizaao je iz programskog jezika S, razvijenog za potrebe Bell Telephone Laboratorija u vlasnitvu AT &amp; T korporacije. Zamiljen je kao interni alat za statistiku analizu. Osnovna filozofija jezika S (koju je naslijedio i programski jezik R) bila je domenska orijentiranost - tj. olakavanje posla podatkovnim analitiarima bez potrebe za prilagoavanjem konvencijama tradicionalnih programskih jezika. Jezik S je kroz 80.-te i 90.-te dosegnuo znaajnu popularnost u krugovima poslovnih analitiara i statistiara, no dostupan samo kroz komercijalnu varijantu nazvanoj S-PLUS. Programski jezik R nastao je na sveuilitu u Aucklandu (NZ) po uzoru na S, a 2000. objavljuje se pod GNU licencom otvorenog koda. Standardna distribucija R programskog jezika sastoji se od: jezgre R-a, sa temeljnim funkcijama i tzv. base paketom koji omoguuje osnovnu funkcionalnost kolekcijom dodatnih paketa (osnovni - base i preporueni - recommended) za upravljanje podacima, vizualizacije i statistike analize Ovdje ne treba zanemariti izvrsnu integraciju R-a sa bogatim repozitorijem paketa zvanom CRAN (Coprehensive R Archive Network) koja omoguuje brzu i jednostavnu instalaciju bilo kojeg paketa iz navedenog repozitorija nakon ega on postaje dio lokalne R instalacije. Budui da je za jezik R specifian iznimno jaki utjecaj R zajednice na razvoj novih paketa, esto se nakon pojavljivanja novih eksperimentalnih metoda i pristupa podatkovne analize vrlo brzo na CRAN-u mogu pronai paketi koji iste implementiraju, a takoer treba spomenuti i snani i kontinuirani entuzijazam R zajednice za razvoj poboljanja postojeih elemenata R-a koji ublaavaju ili uklanjaju veliki broj uoenih manjkavosti jezika. R se zbog toga esto zna usporeivati sa uradi sam projektom gdje korisnik, nakon upoznavanja sa isporuenim tvornikim komponentama (u ovom sluaju temeljnim funkcijama i paketima), poinje prilagoavati svoju razvojnu okolinu odabirom paketa koji tono odgovaraju njegovim potrebama i preferencama. Kreativnost i fleksibilnost u koritenju R-a se smatra njegovom velikom prednou, iako rezultira odreenom neformalnou i liberalnim pristupom programiranju koji nije omiljen korisnicima naviknutim na stroge i formalne programske okvire sa jasnim skupom smjernica i pravila koja se moraju slijediti. Usprkos iznimno velikoj prihvaenosti jezika R za podatkovne analize te mnotvu opcija koje nudi korisniku, potrebno je odmah u poetku biti svjestan i njegovih odreenih ogranienja: R jako intenzivno koristi radnu memoriju to je dugo vremena smatrano ozbiljnim ogranienjem; porastom kapaciteta modernih hardverskih sustava ovo ogranienje je danas puno prihvatljivije, a takoer su se pojavili brojni paketi koji racionaliziraju koritenje memorije. Ipak ostaje injenica da R brzo pojede RAM naeg raunala, iako je to esto i rezultat nepanje ili neznanja programera koji nije dovoljno dobro usvojio R-ovski nain programiranja. R je prilino nekonvencionalan tako da je krivulja uenja inicijalno neto strmija, pogotovo za programere naviknute na standardne konvencije drugih programskih jezika. S druge strane, ako se gleda dugorono, programiranje u R-u je prilino jednostavno budui da je veina kompleksnih zadataka apstrahirana u visokorazinske funkcije koje transparentno obavljaju operativne poslove niske razine. esto se kae da je R vie orijentiran cilju kojeg elimo postii a manje detaljima oko puta kojim do njega stiemo. R nije brzi jezik; iako se radi o jeziku koji oekivano radi nad velikim skupovima podataka, R nije optimiziran za brzinu izvoenja, pa ak ni za viedretvenost; iako je veliki trud uloen da se gotovo sve kljune rutine implementiraju u C-u i da se sprijee znatna usporavanja, a postoji i niz paketa koji omoguuju viedretveno izvoenje R programa, i dalje stoji injenica da R nije dizajniran s ciljem da se izvrava to je bre mogue; ukoliko je brzina prioritet, esto je potrebno traiti alternativna rjeenja - zbog ega se esto zna rei da je R primarno istraivaki jezik, ne produkcijski. R je prvenstveno namijenjen za interaktivni rad, tj. izvoenje niza strojnih instrukcija koje se dinamiki upisuju i izvode uz pomo programske konzole. Ovo je prilagoeno standardnom procesu analize podataka gdje analitiar moe uitavati podatke, istiti ih, transformirati, razvijati modele, testirati i sl. uz konstantnu povratnu informaciju od raunala, mogunost pregleda meurezultata, izmjene procesa prema trenutnim saznanjima i sl. Ovo ne znai da se u programskom jeziku ne moe programirati na klasian proceduralni nain, razvojem algoritama enkapsuliranih u funkcije koje onda nakon pozivanja automatski obavljaju svoje zadatke, ali injenica jest da se uinkovitost R-a upravo odraava u interaktivnom radu. Ovaj princip se prenosi i na uenje R-a; programski jezik R puno se lake ui interaktivnim pristupom uz izvravanje konkretnih zadataka, eksperimentiranjem s podatkovnim skupovima, dostupnim metodama i sl. nego klasinim pristupom izrade programskih skripti koje implementiraju neke niskorazinske poslove. 1.1.2 Alternative jeziku R Programski jezik R je popularno, ali ne i jedino rjeenje za interaktivnu analizu podataka i statistiko programiranje. U nastavku emo dati kratki pregled nekih popularnijih tehnologija i rjeenja koje se danas koriste u ovu svrhu, uz kratku usporedbu i osvrt na prednosti i nedostatke u usporedbi sa onim to nudi jezik R. SAS i SPSS  SAS (Statistical Analysis System, razvijen od strane SAS Institute) i SPSS (Software Package for Statistical Analysis, razvijen od strane IBM-a) su dva razliita softverska paketa koje stavljamo pod istu stavku prvenstveno zato to se radi o komercijalnim alatima, tj. alatima koji za svoju punu funkcionalnost zahtijevaju plaanje licence. Isto tako, SAS i SPSS se relativno lako ue a svoju funkcionalnost u velikoj mjeri zasnivaju na pomno dizajniranim korisnikim sueljima. Ovi alati naglasak stavljaju na uinkovitost i odlina su opcija za velike tvrtke koje trae konzistentno, robusno rjeenje za svoju analitiku i kojima ne smeta komercijalna priroda takvih rjeenja. Weka i Orange  Weka (Waikato Environment for Knowledge Analysis, razvijen od strane sveuilita Waikato na Novom Zelandu) i Orange (alat za dubinsku analizu podataka razvijen na sveuilitu u Ljubljani) su besplatan softver za eksploratornu analizu podataka i dubinsku analizu koji svoju funkcionalnost zasnivaju na relativno jednostavnim grafikim sueljima i vizualnom pristupu programiranju. Ova rjeenja vrlo su dobra za korisnike koji nisu previe zahtjevni glede fleksibilnosti i kompleksnosti svojih analiza jer na vrlo pristupaan i jasan nain omoguuju provedbu definiranih koraka procesa analize. To ne znai da se u ovim alatima ne mogu raditi i kompleksnije analize, samo da su oni ipak prilagoeniji analizama kroz predefinirane funkcionalnosti pruenog grafikog suelja. Python (Numpy / Pandas / Scikit)  u zadnjih nekoliko godina upravo je Python najozbiljniji konkurent jeziku R, prvenstveno zbog injenice da je Python sam po sebi vrlo popularan programski jezik koji za potrebe analize podataka koristi pakete s vrlo slinim pristupom procesu analize onom kojeg koristi i jezik R. Rasprava o tome koji jezik odabrati je vrlo esta u polju znanosti o podacima, obino bez jasnog konanog zakljuka. Lako s uvjeriti da su razlike zapravo u nijansama - dok je R snano domenski orijentiran i vei naglasak stavlja na lakou i jednostavnost koritenja uz iroku paletu dostupnih paketa sa preklapajuim funkcionalnostima kako bi korisnik mogao odabrati onaj koji mu najvie odgovara, Python naglaava rigidnu formalnu strukturu i princip za jedan posao jedan nain obavljanja. Stoga bi se moglo rei da je R neto pogodniji za istraivanje podataka dok je prednost Pythona laki razvoj i integracija analitikih modula u nekom produkcijskom okruenju, pogotovo ako je navedeno okruenje ve izvedeno u Pythonu. No snanim razvojem oba jezika i meusobnim praenjem funkcionalnosti i ova navedena razlika postaje sve manje relevantna - danas vie nije problem integrirati R skripte u postojee sustave neovisno o platformi na kojoj su izvedeni, a u Python zajednica razvija svoje inaice popularnih paketa iz R-a koje vjerno preslikavaju njihovu funkcionalnost. U konanici se moe rei da inicijalni odabir izmeu ove dvije alternative i nije toliko bitan - pristup kojeg koriste je toliko slian a praenje funkcionalnosti toliko izraeno da se uenjem jednog jezika svladava veina bitnih koncepata iz drugog tako da se podatkovni znanstvenici esto na kraju odluuju na svladavanje oba jezika, kako bi se lako prilagodili velikom broju okruenja u kojima moraju provoditi svoje analize. 1.2 Instalacija programske podrke Instalacija programske podrke za jezik R je prilino jednostavna, pogotovo ako se kao platforma koristi preporueno razvojno suelje RStudio. Ovo nije jedina opcija - jedna od popularnih alternativa jest i viejezina platforma Jupyter Notebook koja nudi vlastitu podrku za R. itateljima se dugorono preporuuje istraivanje svih dostupnih opcija i konani odabir onog suelja koje osobno procijene najboljim za svoje potrebe, no ovaj udbenik e se usredotoiti na RStudio ponajvie zbog jasnog, preglednog suelja, lake instalacije i vrlo bogate podrke za razliite funkcionalnosti - od instalacije novih paketa, lakog dohvaanja dokumentacije, prikaza vizualizacija do stvaranja i objave izvjetaja. Radne biljenice o kojima e vie rijei biti u nastavku uglavnom pretpostavljaju da ste odabrali suelje RStudio. Za uspjeno postavljanje razvojne platforme potrebno je instalirati dvije stvari distribuciju jezika R razvojno suelje RStudio Preporuuje se koristiti najnovije dostupne inaice. U trenutku pisanja ovog dokumenta to su R 4.2.2 i RStudio 2022.07.2. Ukoliko se ove inaice razlikuju od one koje se nalaze na vaem raunalu, vjerojatno nee biti problema ukoliko su brojevi inaica vii od navedenih; u suprotnom preporuuje se njihova nadogradnja. U nastavku e se opisati postupak za instalaciju navedenog softvera na operacijski sustav Microsoft Windows. Ukoliko radite na nekom od drugih operacijskih sustava, kao to je neka od Linux distribucija ili Mac OS procedura je neto drugaija, no i dalje ne previe sloena - dovoljno je pratiti upute na web stranicama spomenutim u nastavku koje su orijentirane platformi koju koristite. Kako bi pronali spomenuti softver u trailicu upiite sljedee pojmove: download R download RStudio U oba sluaja dobiti ete stranice sa poveznicama na izvrne datoteke koje morate pokrenuti kako bi se softver instalirao na vae raunalo. U sluaju jezika R to moe biti datoteka R-4.2.2-win.exe (toni brojevi se mogu razlikovati). Kod suelja RStudio moete vidjeti vie opcija - odaberite besplatnu desktop inaicu. Komercijalne inaice imaju neke dodatne funkcionalnosti koje su veinom orijentirane uporabi u profesionalnim, viekorisnikim okruenjima te nisu bitne za uobiajeni rad. Izvrne datoteke moete pokrenuti i pustiti arobnjaka da instalira sve potrebne komponente na vae raunalo. Preporuuje se prihvatiti sve nazivne opcije osim mape instalacije - umjesto podmape Program Files bolje je instalirati R direktno u osnovnu mapu (npr. C:\\R\\R-4.2.2). Na ovaj nain biti e lake pronai trenutno instaliranu inaicu i eventualno kasnije aurirati. Iz istih razloga preporuuje se RStudio instalirati u mapu C:\\R\\RStudio. U sluaju da niste mogunosti ili ne elite odabrati ove mape, moete definirati neke druge ili zadrati nazivne opcije - ovaj izbor ne bi u konanici trebao bitno utjecati na daljnji rad. Nakon instalacije suelja RStudio dovoljno je isto jednostavno pokrenuti uz pomo stvorene kratice na radnoj mapi (ili alternativno, uz pomo izvrne datoteke RStudio.exe u odabranoj mapi za instalaciju). Nakon pokretanja aplikacija bi trebala izgledati slino sljedeoj slici: Slika 1.1: Izgled suelja RStudio Ukoliko je dolo do nekih problema, provjerite da li ste ispravno proveli sve navedene korake instalacije. U nastavku emo se pozabaviti detaljima prikazanog suelja. 1.3 Pregled razvojnog suelja RStudio Pogledajmo suelje RStudio. Vidimo da je podijeljeno na tri prozora - lijevi dio je radni i u njega upisujemo programski kod. S desne strane se nalaze pomoni prozori koji prikazuju razliite stvari, ovisno o odabranoj kartici; u gornjem desnom dijelu izmeu ostalog moemo vidjeti to se trenutno nalazi u naoj radnoj okolini (koja je na poetku prazna) te povijest naredbi koje smo izvravali. Donji dio slui za prikaz dokumentacije, datoteka u radnoj mapi, instaliranih paketa, vizualizacija i sl. 1.3.1 Interaktivna konzola Vratimo se na lijevi dio suelja. Ovdje se zapravo radi o tzv. interaktivnoj konzoli. Naime, po svojoj prirodi R je tzv. interpreterski jezik u smislu da se naredbe odmah interpretiraju i izvravaju. Iako je mogue izraivati i vee skripte koje se onda izvravaju u komadu, rad sa jezikom R vrlo esto se svodi na princip naredba - odgovor. Upravo zbog toga govorimo o interaktivnoj programskoj analizi podataka - analitiar programira upisivanjem naredbi te u svakom trenutku moe prouiti dobivene meurezultate i odluiti se na daljnje korake. Prikaimo kako radi interaktivna konzola. Uz pomo tipkovnice moemo utipkati jednostavan matematiki izraz - npr. 3 + 2 i stisnuti tipku ENTER. Vidimo da e nam R odmah pruiti rezultat - moemo ga koristiti i kao kalkulator! Za matematike izraze koje nije jednostavno utipkati moramo koristiti funkcije. Tako npr. drugi korijen moemo izraunati uz pomo funkcije sqrt(). Pokuajmo u konzolu utipkati sqrt(10) i stisnuti ENTER. R nam opet odmah prikazuje rezultat. U ovom trenutku zaslon bi nam trebao izgledati otprilike kao na sljedeoj slici. Slika 1.2: R kao kalkulator Jedan od problema ovakvog naina koritenja R-a jest taj to nam se mijeaju naredbe i rezultati, a povijest niza naredbi postaje sve tee vidljiva kako se koritenjem konzole sputamo sve nie i nie. Isto tako, ako iz nekog razloga naredba koju izvravamo rezultira grekom koju pokuavamo ispraviti, konzola vrlo brzo postaje prljava budui da se mijeaju korektni pozivi sa izvjetajima o grekama ime bilo kakva sloenija procedura koju elimo provesti postaje rastrgana i nepregledna. Zbog toga analitiari vrlo esto koriste tzv. R skripte koje omoguuju da vizualno izdvojimo naredbe koje elimo izvriti od same konzole, ali i dalje uz mogunost da ih lako upiemo u konzolu, slijedno izvrimo i pogledamo rezultat. 1.3.2 Pisanje R skripti Na alatnoj traci odaberimo File -&gt; New File -&gt; R Script (ili stisnemo kombinaciju tipaka CTRL + SHIFT + N). Vidimo da se radni dio na lijevoj strani razdvojio na dva dijela. Gornji dio predstavlja prostor za nau skriptu - zapravo niz naredbi koje elimo izvriti - dok interaktivna konzola sada zauzima donji dio radne plohe. Ukoliko elimo, moemo pomicanjem granice promijeniti veliinu ovih (a i ostalih prozora), no za sada je bitno da imamo pregled i skripte i konzole. Upiimo dvije naredbe u prozor za pisanje skripte - prva neka bude print(\"Pozdrav!\") a ispod nje opet jednostavan matematiki izraz 3 + 4. Vratimo kursor na prvi redak i stisnimo kombinaciju tipki CTRL + ENTER. Ukoliko smo ispravno pratili navedene korake, naredba na mjestu koje se nalazio kursor automatski e se preslikati u interaktivnu konzolu i izvriti. Kursor e sada biti na mjestu sljedee naredbe koju takoer moemo izvriti sa CTRL + ENTER. Zaslon bi sada trebao izgledati slino sljedeoj slici. Slika 1.3: R skripta Ovo je zapravo uobiajeni nain rada u jeziku R - u prostor za skripte upisujemo naredbe koje potom izvravamo njihovim automatskim preslikavanjem u konzolu. Ako neto ne tima s naredbom, lako ju preinaimo i ponovo izvrimo. Ukoliko elimo izvesti blok naredbi, odaberemo ih povlaenjem mia i izvrimo kombinacijom tipaka CTRL + ENTER. Skripte moemo proiriti komentarima (koji poinju znakom # kojeg R interpretira kao ovaj redak ignoriraj), a na kraju rada spremiti pod odabranim imenom na vrsti disk. No moemo otii i korak dalje. Iako su R skripte sasvim adekvatne za ugodan rad u jeziku R, postoji dodatna tehnologija koja nam omoguuje jo veu fleksibilnost u radu sa programskim jezikom R - R Markdown. 1.3.3 R Markdown Pisanje R skripti vrlo je slino klasinom poimanju programiranja - piemo programske naredbe koje se u pravilu izvravaju slijedno te kojima opcionalno dodajemo komentare u svrhu dokumentacije. No budui da je rad u R-u vrlo esto interaktivne prirode te da se kao zavrni korak neke analize podataka obino oekuje oblikovanje izvjetaja koji e na adekvatan nain prikazati dobivene rezultate, suelje RStudio podrava tehnologiju koja omoguuje uinkovitu kombinacije programiranja i strukturiranog dokumentiranja na principu interaktivne biljenice; analitiar moe pisatiisti\" tekst, opcionalno sa formulama, slikama te izmjenama veliine i prirode tekstualnog fonta, da bi potom u takav tekst ugradio izvrivi programski kod zajedno sa njegovim rezultatima. Tehnologija koja ovo omoguuje je tzv. R Markdown, koji je relativno nedavno proiren novim konceptom nazvanim R Notebook. Rad ove tehnologije najlake je prikazati preko primjera - u alatnoj traci odaberimo File -&gt; New File -&gt; R Markdown... te u iduem prozoru odaberimo proizvoljni naslov (npr. Proba), opcionalno ime autora te jednu od opcija za konani oblik izvjetaja (preporueno HTML zbog najmanje ovisnosti o dodatnim paketima). Za razliku od R skripte, R e kod novog R Markdown dokumenta stvoriti popunjeni dokument. Ovo je izvedeno na ovaj nain iz jednostavnog razloga da korisnik dobije predloak koji istovremeno slui i kao podsjetnik te kojeg onda lako izmjeni prema svojem nahoenju. Mi emo za nae potrebe obrisati vei dio ovog predloka - sve poslije inicijalnog zaglavlja, tj. ispod druge pojave znakova ---. Potom moemo ispod napisati bilo kakav tekst. Znakovima #, ##, ### itd. moemo postaviti naslov odreene kategorije (to sada nisu komentari, jer ovo zapravo nije R kod!), dok znakovima * i ** ispred i iza odabranih rijei odabiremo nakoeni ili masni otisak u konanom izvjetaju. Ovo je tzv. isti markdown, tj. obian tekst koji se uz pomo dodatnih alata moe pretvoriti u oblikovani tekst, ukoliko elimo. Kada elimo u ovaj na izvjetaj ugraditi programski kod, moramo stvoriti tzv. isjeak (engl. chunk). To moemo uiniti odabirom Insert -&gt; R na alatnoj traci ili kombinacijom tipaka CTRL + ALT + I. Uoite da isjeak poinje i zavrava posebno odabranim nizom znakova - tri apostrofa nalijevo (engl. backticks). Isto tako, poetak isjeka u vitiastim zagradama opisuje parametre isjeka, od ega je najvaniji programski jezik kojeg emo koristiti. U ovom udbeniku emo gotovo iskljuivo koristiti jezik R, iako je mogue koristiti i druge jezike ukoliko su oni instalirani na platformi na kojoj je pokrenut RStudio. Isjeak koda ponaa se isto kao i standardna R skripta - moemo upisivati naredbe i izvravati ih. Razlika je samo u tome to - ukoliko elimo - rezultate moemo vidjeti i odmah u samom R Markdown dokumentu. Ako nam ova opcija smeta moemo ju iskljuiti (klik na zupanik u alatnoj traci i odabir Chunk output in console) no u pravilu nam odgovara da se rezultat ugradi u dokument kako bi naknadno mogli ponovo pregledavati rezultate prethodnih isjeaka. Ako smo pratili upute, zaslon bi mogao izgledati slino sljedeoj slici: Slika 1.4: R Markdown dokument Ukoliko elimo, moemo pokuati stvoriti izvjetaj od trenutnog dokumenta. Prvo ga moramo spremiti pod odreenim imenom (npr. Proba.rmd), a potom moemo kliknuti na gumb Knit koji e dokument iz istog teksta pretvoriti u HTML datoteku. R Markdown dokumenti su puno moniji nego to se moda daje naslutiti do sada prikazanim elementima. Isjecima moemo dodavati niz parametara kako bismo utjecali na njihovo ponaanje. Izlazni oblik moe biti PDF, DOCX ali i drugi oblici kao to slajdovi raznih tehnologija, knjige namijenjene mobilnim ureajima, interaktivna Web aplikacija i sl. Udbenik kojeg itate zapravo nije nita drugo do niz RMD datoteka pretvoren u adekvatni oblik kojeg trenutno koristite. Kao to emo objasniti u sljedeem poglavlju, RMD datoteke su takoer i glavni nain na kojeg ete moi na interaktivan nain pratiti ovaj udbenik i isprobavati primjere i zadatke koje slijede. Univerzalnost i fleksibilnost tehnologije R Markdown je iznimno velika, emu u prilog govori i njezina velika popularnost u R zajednici. 1.4 Kako koristiti ovaj udbenik? Osnovna ideja ovog udbenika jest uenje kroz primjenu. Zbog toga se u lekcijama u nastavku nee koristiti previe primjera, ve se itatelja potie da svaki novi koncept usvoji kroz rjeavanje niza lakih i teih zadataka. Svako poglavlje koje slijedi ima prateu radnu biljenicu. Jednostavno reeno, radi se o RMD datoteci koja sadri sve primjere iz zadatke iz ovog udbenika, popraene saetim tekstom radi lakeg snalaenja i referenciranja na koncepte koji se obrauju. Osnovna ideja je da itatelj paralelno ita udbenik i rjeava radnu biljenicu, gledajui rjeenje zadatka tek nakon to ga samostalno rijei unutar programskog alata. Poneki zadaci zahtijevati e jednostavno uklanjanje znaka # (koji oznaava komentar) sa poetka naredbe te njezino izvravanje. Usprkos trivijalnom pristupu, na ovaj nain se ipak jasnije potie itatelja za samostalno isprobavanje naredbe, umjesto da samo pogleda njezin rezultat. Drugi zadaci zahtijevati e neto vei angaman. Konano, nakon svake lekcije nalazi se niz Zadataka za vjebu uz koje se nee nalaziti rjeenje te koji e predstavljati svojevrsnu provjeru svih danih koncepata lekcije. itateljima se snano preporuuje rjeavanje svih primjera i zadataka prije prelaska na iduu lekciju, budui da lekcije koje slijede pretpostavljaju dobro usvojeno znanje svih do tada obraenih tema. Naravno, udbenik je mogue itati i bez navedenog interaktivnog pristupa. Rjeenja uz zadatke otkrivaju ispravnu metodu pristupa problemu, a veina naredbi popraena je ispisom kojeg bi korisnik dobio na zaslonu njihovim izvravanjem. Usprkos tome, stav autora udbenika jest da se programski jezici ne mogu uiti itanjem te da se dodatni trud isprobavanja svih, pa ak i najjednostavnijih koncepata, u konanici viestruko isplati. Upoznajmo se poblie sa konceptom radnih biljenica. Prvo je potrebno pronai i otvoriti radnu biljenicu koja odgovara lekciji koju itate. Nju je lako prepoznati prema odgovarajuem broju lekcije - radna biljenica za ovu lekciju nosi naziv 01_Uvod_RB.Rmd. Preporuuje se da sve radne biljenice na kojima namjeravati raditi kopirate negdje na lokalno raunalo zajedno sa svim prateim datotekama koje se nalaze u istoj mapi ako ih ima. Kao to je reeno, radna biljenica e u pravilu sadravati sav programski kod lekcije na koje se odnosi, ali samo dio teksta koliko je dovoljno za lake snalaenje. Ukoliko ovaj tekst itate direktno iz radne biljenice, a ne kao dio udbenika, moete vidjeti da nedostaje cijeli prethodni dio lekcije; to je zato to se uvodni koraci opisani u njemu tiu koncepata koje je potrebno usvojiti prije koritenja radne biljenice. Ako ih niste proli, preporuka je da se vratite i proete ih te potom nastavite sa primjerima i zadacima koji slijede. Radne biljenice razlikuju Primjere i Zadatke. Primjere je u pravilu potrebno samo izvriti. Zadaci s druge strane oekuju izvjesne preinake ili unos novog programskog koda. Kao to je reeno, udbenik e postaviti daleko vei naglasak na zadatke. Primjer moe izgledati ovako: Primjer - nekoliko jednostavnih naredbi R programskog jezika 3+2 #zbrajanje log(10) # prirodni logaritam! log10(10) # ovo je logaritam baze 10! Usput, komentare piemo znakom &quot;#&quot; sin(0.5 * pi) # pi je jedna od ugraenih konstanti ## [1] 5 ## [1] 2.302585 ## [1] 1 ## [1] 1 Naredbe iz primjera moete izvriti pojedinano, ili cijeli isjeak odjednom kombinacijom tipaka CTRL + SHIFT + ENTER. Nikakve preinake koda nisu nune (iako esto nije loe eksperimentirati sa danim naredbama!). Zadaci s druge strane uvijek trae odreenu - makar minimalnu - intervenciju. Zadatak 1.1 - naredbe za provjeru i izmjenu radne mape # izvrite sljedee naredbe uklanjanjem znaka komentara #getwd() # mapa u kojoj trenutno radimo #setwd(&quot;.&quot;) # ovdje moemo navesti novu radnu mapu ukoliko elimo getwd() # mapa u kojoj trenutno radimo setwd(&quot;.&quot;) # ovdje moemo navesti novu radnu mapu ukoliko elimo Zadatak e se esto odnositi na upravo uvedeni koncept. Npr. zgodno je za napomenuti da, iako jezik R podrava operator = za pridruivanje vrijednosti nekoj varijabli, preporuuje se koritenje operatora &lt;- u tu svrhu koji je neto vie R-ovski. Takoer, uoimo da R podrava tzv. autoprint, tj. uvijek e ispisati rezultat zadnje naredbe na zaslon. To znai da ako u isjeku stvaramo novu varijablu x te ju elimo ispisati na zaslon, ne moramo kao zadnju naredbu staviti print(x) ve je dovoljno staviti samo x. Isprobajmo ovo u zadatku. Zadatak 1.2 - R-ovski operator pridruivanja # upiite `5` u varijablu `x` # potom ispiite varijablu `x` na zaslon x &lt;- 5 x ## [1] 5 Sada kada smo se dobro upoznali sa radnom platformom, moemo poeti sa uenjem osnovnih elemenata programskog jezika R. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["tipovi.html", "2 Osnovni tipovi podataka i operatori 2.1 Osnovni tipovi podataka 2.2 Operatori 2.3 Nedostajue, nepoznate i nemogue vrijednosti Zadaci za vjebu", " 2 Osnovni tipovi podataka i operatori Osnovni ili primitivni tipovi podataka su temeljni izgradbeni blokovi programskih jezika. Ovdje se najee misli na ugraene mehanizme koji omoguuju pohrane elementarne informacije - najee logikog, numerikog ili znakovnog tipa. Veina programskih jezika koristi iste ili vrlo sline naine pohrane takvih informacija, to znai da implementira sline osnovne tipove podataka - razlika je esto u detaljima kao to su sam naziv tipa, nazivni broj bajtova za odreeni tip podatka i sl. U svakom sluaju najei prvi korak kod uenja novog programskog jezika jest upoznavanje osnovnih tipova podataka koje isti podrava. Sljedea stvar koja nas potom moe zanimati jest sintaksa jezika, tj. nain na kojeg piemo naredbe koje interpreter jezika moe razumjeti i izvriti. Jezik R u svojoj sintaksi slijedi sline konvencije viene u jezicima kao to su Python, Ruby ili Java, naravno uz izvjesne specifinosti to je uobiajeno za svaki novi programski jezik. Neka sintaksna pravila koje je korisno znati su sljea: svaka naredba (u pravilu) mora ii u svoj redak uvlaenje naredbi unutar blokova je preporueno ali nije obvezno, kao ni stavljanje toke-zareza na kraj naredbe blokove definiramo vitiastim zagradama, slino jezicima Java ili C tipove varijabli ne definiramo unaprijed, oni se prilagoavaju pridruenoj vrijednosti komentari zapoinju znakom # Umjesto navoenja niza pravila sintaksu emo najbolje nauiti kroz primjere - uz upoznavanje sa jednostavnim funkcijama i operatorima, to emo i uiniti u ovoj lekciji. Nakon pregleda osnovnih tipova i operatora zavretak lekcije emo posvetiti rapsravi o tzv. nedostajuim ili nepostojeim vrijednostima, koje imaju posebno vanu ulogu kod uobiajenog koritenja programskog jezika R. 2.1 Osnovni tipovi podataka R poznaje est osnovnih tipova podataka: tip izvorni naziv tipa primjeri logiki logical TRUE, FALSE ili T, F cjelobrojni integer 2L, 5L, 123456789L realni double 4, 6, 3.14, 2e5 kompleksni complex 5 + 2i, 7 + 1i znakovni character \"A\", \"B\", \"Pero\", \"ABCDEFGHijklmnoPQRSTUVwyz\" bajtovi raw as.raw(2), charToRaw(\"1\") Dobro je znati: cjelobrojni i realni tipovi se esto zajedno tretiraju kao tip numeric (iako ovo nije u potpunosti konzistentno!) kompleksni tip mora imati deklariranu imaginarnu konstantu ak i ako je ona 1 (2 + i nije dobar zapis!) tip sirovih bajtova se relativno rijetko koristi Provjeru da li je neka varijabla odreenog tipa moemo raditi uz pomo funkcije is.&lt;naziv_tipa&gt;, to emo demonstrirati u sljedeem zadatku. Prije samog zadatka potrebno je napomenuti sljedee: kako bi ispis programskih odsjeaka bio to pregledniji potruditi emo se vizualno odvojiti razliite segmente ispisa. U tu svrhu emo koristiti naredbu cat(\"-----------\\n\") koja e na zaslon ispisati niz crtica i potom prijei u novi red. Ovdje moemo koristiti i funkciju print(), no naredba cat je ovdje bolji izbor samo zbog injenice da print uvijek ispis zapoinje indeksom prikazanog elementa, to nam kod ovakvog tipa ispisa nije potrebno. Zadatak 2.1 - provjera tipova podataka #isprobajte sljedee naredbe: #is.logical(FALSE) #is.integer(2L) #is.double(1.11) # izvedite sljedee provjere: # da li je 5L numeriki tip? # da li je 3.14 numeriki tip? # da li je &quot;ABC&quot; znakovni tip? # da li je 4 + 2i kompleksni tip? # da li je 5 cjelobrojni tip? is.logical(FALSE) is.integer(2L) is.double(1.11) cat(&quot;-----------\\n&quot;) is.numeric(5L) is.numeric(3.14) is.character(&quot;ABC&quot;) is.complex(4 + 2i) is.integer(5) ## [1] TRUE ## [1] TRUE ## [1] TRUE ## ----------- ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] FALSE Da li ste uoili neto neobino u ovim provjerama? Pokuajte objasniti dobiveni rezultat. Tip neke varijable ili konstante moemo dohvatiti uz pomo funkcija typeof ili class. Razlika izmeu njih je sljedea: typeof - dohvaa primitivni ili osnovni tip podatka (integer, double ) class - objektni tip, zapravo vrijednost atributa class Zadatak 2.2 - dohvat naziva tipa podatka # ispiite tipove sljedeih konstanti: TRUE, 2L, F, 3.14, &quot;ABC&quot; # ispiite klase istih konstanti. Ima li razlike? typeof(TRUE) typeof(2L) typeof(F) typeof(3.14) typeof(&quot;ABC&quot;) cat(&quot;-----------\\n&quot;) class(TRUE) class(2L) class(F) class(3.14) class(&quot;ABC&quot;) ## [1] &quot;logical&quot; ## [1] &quot;integer&quot; ## [1] &quot;logical&quot; ## [1] &quot;double&quot; ## [1] &quot;character&quot; ## ----------- ## [1] &quot;logical&quot; ## [1] &quot;integer&quot; ## [1] &quot;logical&quot; ## [1] &quot;numeric&quot; ## [1] &quot;character&quot; Podatke moemo eksplicitno pretvarati iz jednog tipa u drugi uz pomo funkcije as.&lt;naziv_tipa&gt;: Zadatak 2.3 - pretvorba tipova podataka # Izvedite sljedee pretvorbe i ispiite rezultat # 2.35 u integer # TRUE u numeric # 100L u character # 2.35 u character # 2e2 u character # 0 u logical # 2.75 u logical as.integer(2.35) as.numeric(TRUE) as.character(100L) as.character(2.35) as.character(2e2) as.logical(0) as.logical(2.75) ## [1] 2 ## [1] 1 ## [1] &quot;100&quot; ## [1] &quot;2.35&quot; ## [1] &quot;200&quot; ## [1] FALSE ## [1] TRUE R e sam provoditi implicitnu pretvorbu ukoliko je mogua: Zadatak 2.4 - implicitna pretvorba # napiite izraze koji odgovaraju sljedeem i ispiite rezultat: # aritmetiki operator izmeu logike i numerike varijable # aritmetiki operator izmeu cjijelog i realnog broja # logiki operator negacije primjenjen na numeriku varijablu # aritmetiki operator izmeu logike i numerike varijable TRUE + 5 # aritmetiki operator izmeu cjelobrojne i numerike varijable 5L + 3.14 # logiki operator negacije primjenjen na numeriku varijablu !25 ## [1] 6 ## [1] 8.14 ## [1] FALSE Implicitna pretvorba e se izvesti samo ako je smislen - npr. aritmetiki operator izmeu znakovne i numerike varijable rezultirati e grekom. 2.2 Operatori Kao i u drugim programskim jezicima, R dozvoljava koritenje operatora u izrazima. Neki od ee koritenih operatora su: aritmetiki +, -, *, /, ** ili ^ (potencija), %% (modulo), %/% (cjelobrojno dijeljenje) usporedni &lt;, &lt;=, &gt;, &gt;=, ==, != logiki ! (negacija), &amp;&amp; (skalarni i), || (skalarni ili), &amp; (vektorski i), | (vektorski ili) pridruivanje &lt;- ili = Zadatak 2.5 - operatori # isprobajte izraze `5 / 2` i `5 %/% 2` # provjerite koliko iznosi &quot;17 na kvadrat&quot; i &quot;ostatak dijeljenja 101 sa 12&quot; # provjerite to je rezultat sljedeih izraza: `17 &gt; 13`, `!TRUE`, `5 &amp;&amp; 0`, `0. || 2` # isprobajte izraze `5 / 2` i `5 %/% 2` 5 / 2 5 %/% 2 cat(&quot;-----------\\n&quot;) # provjerite koliko iznosi &quot;17 na kvadrat&quot; i &quot;ostatak dijeljenja 101 sa 12&quot; 17 ^ 2 101 %% 12 cat(&quot;-----------\\n&quot;) # provjerite to je rezultat sljedeih izraza: `17 &gt; 13`, `!TRUE`, `5 &amp;&amp; 0`, `0. || 2`, 17 &gt; 13 !TRUE 5 &amp;&amp; 0 0. || 2 ## [1] 2.5 ## [1] 2 ## ----------- ## [1] 289 ## [1] 5 ## ----------- ## [1] TRUE ## [1] FALSE ## [1] FALSE ## [1] TRUE Logike vrijednosti i usporedne operatore najee emo koristiti kod tzv. uvjetnog izvoenja naredbi, poznatog iz drugih programskih jezika kao IF ELSE naredba. U R-u njezina sintaksa izgleda ovako: if (izraz) {blok} else {blok} Isprobajmo ovu naredbu na sljedeem zadatku: Zadatak 2.6 - uvjetno izvoenje naredbi # napiite naredbu koja izvodi sljedee: # &quot;ako je 100 paran broj ispii &#39;Uspjeh!&#39;&quot; if (100 %% 2 == 0) print(&quot;Uspjeh!&quot;) ## [1] &quot;Uspjeh!&quot; Uoili smo gore da imamo dvije vrste logikih operatora za i i ili. Razliku emo objasniti kasnije, za sada je dovoljno rei da se kod uvjetnog izvoenja naredbi ili programskih petlji gotovo iskljuivo koristimo operatorima &amp;&amp; i || (C++ - ovski operatori!). Isto tako, ve smo spomenuli da R nudi dva operatora pridruivanja, &lt;- i =. Izmeu njih postoje neke sitne razlike, no one nemaju gotovo nikakav utjecaj na uobiajeno koritenje ovog operatora u praksi. U literaturi se za pridruivanje vrijednosti novim varijablama moe vidjeti i jedna i druga inaica, no mi emo u nastavku primarno i konzistentno koristiti &lt;-, ponajvie zato kako bi programski kod bio vizualno distinktivniji od drugih programskih jezika. NAPOMENA: za jednostavniji upis operatora &lt;- moemo se koristiti kombinacijom tipaka ALT i - Kod pridruivanja pazimo da je s lijeve strane tzv. lijeva vrijednost (engl. lvalue). Ovo u programerskom smislu interpretiramo kao neto u to se moe pohraniti izraunata vrijednost. x + 1 &lt;- 2 # greka!!!] U pravilu se u R-u kao lvalue koristi varijabla, iako se tu ponekad moe pojaviti i poziv funkcije. Ovu moda inicijalno zbunjujuu pojavu razjasniti emo kasnije. Imenovanje varijabli uglavnom slijedi pravila iz drugih programskih jezika - dozvoljena su slova, brojke, podcrta ali i toka . Prvi simbol mora biti slovo ili toka. .mojaVarijabla &lt;- 5 #OK moja.Varijabla &lt;- 5 #OK _mojaVarijabla &lt;- 5 # nije OK 123Varijabla &lt;- 5 # nije OK U praksi za varijable sloenih imena trebamo odabrati jednu od sljedeih konvencija: mojaVarijabla &lt;- 1 # tzv. camelcase moja_varijabla &lt;- 2 # podcrta ili moja.varijabla &lt;- 3 # toka Bitno je da u programskom kodu ne mijeamo konvencije tj. da nakon odabira budemo konzistentni. Ukoliko ba inzistiramo na udnim imenima koja koriste specijalne znakove, onda ih moramo staviti pod tzv. lijeve jednostruke apostrofe (engl. backticks): Zadatak 2.7 - ime varijable sa specijalnim znakovima # upiite proizvoljno ime sa specijalnim znakovima unutar lijevih apostrofa # i ispiite vrijednost varijable #`` &lt;- 2 `!%^$*@__=` &lt;- 2 `!%^$*@__=` ## [1] 2 Ovakav nain imenovanja varijabli nije previe koristan u praksi, ali ima i svoju svrhu - budui da su operatori u R-u zapravo funkcije (ija su imena doslovno +, ^ i sl.) upotrebom lijevih apostrofa moemo ih direktno referencirati u njihovom originalnom obliku, to se moe pokazati vrlo praktinim kod tzv. funkcijskog programiranja (o emu emo govoriti u jednoj od buduih lekcija). Pridjeljivanje vrijednosti novim nazivima varijabli mi zapravo stvaramo nove varijable u radnoj okolini (koja se u R-u naziva globalna okolina). Sve varijable koje smo do sada stvorili moemo vidjeti uz pomo funkcije ls(). Ukoliko elimo obrisati neke varijable, samo navedemo njihova imena u pozivu funkcije rm() (npr. rm(x, y, z)). Za brisanje svih varijabli iz radne okoline koristimo poziv rm(list=ls()), s time to tu moramo biti oprezni (nema undo!). Zadatak 2.8 - ispis i brisanje varijabli globalne okoline # ispiite sve do sada stvorene varijable globalne okoline # obriite neke od gore ispisanih varijabli - npr. rm(x, y, z) # ponovo ispiite dostupne varijable # obriite SVE varijable globalne okoline # (oprezno s ovim pozivom u praksi!) # uvjerite se da je globalna okolina prazna # ispiite sve do sada stvorene varijable globalne okoline ls() # obriite neke od upravo ispisanih varijabli - npr. rm(x, y, z) # ponovo ispiite dostupne varijable rm(x, y) ls() # obriite SVE varijable globalne okoline # (oprezno s ovim pozivom u praksi!) # uvjerite se da je globalna okolina prazna rm(list=ls()) ls() Konano, kad god nam treba pomo oko neke funkcije, imamo sljedee opcije na raspolaganju: napiemo samo &lt;ime_funkcije&gt; (bez zagrada sa parametrima) i stisnemo - ukoliko je funkcija pisana u R-u (a nije samo proxy prema implementaciji u C-u) na zaslon emo dobiti ispis izvornog koda funkcije napiemo help(&lt;ime_funkcije&gt;) ili ?&lt;ime_funkcije&gt; ime dobijamo stranicu pomoi o funkciji sa popisom parametara, primjerima i sl. napiemo example(&lt;ime_funkcije&gt;) pri emu dobijemo popis primjera koritenja funkcije i dobivenih rezultata Sljedei isjeak koda prikazuje nain koritenja gornjih metoda (zbog tednje prostora ne prikazujemo njihov rezultat). #programski kod funkcije `ls` ls # pomo za funkciju `ls` ?ls # ili help(ls) # primjeri koritenja funkcije `ls` example(ls) 2.3 Nedostajue, nepoznate i nemogue vrijednosti U R-u postoji tri naina modeliranja nepostojeih vrijednosti: NA - (not available) nedostajua ili nepoznata vrijednost odreenog tipa NaN - (not a number) nemogui broj, npr. 0/0 NULL - nepostojea vrijednost, doslovno nita Zadatak 2.9 - rad sa NA, NaN i NULL # Koliko je &quot;5 + nepoznati broj&quot;? # Koliko je &quot;5 + nepostojei broj&quot;? # provjerite klase sljedeih konstanti i izraza: # NA # aritmetika operacija izmeu numeric i NA # NaN # NULL # Koliko je &quot;5 + nepoznati broj&quot;? 5 + NA # Koliko je &quot;5 + nepostojei broj&quot;? 5 + NaN cat(&quot;-----------\\n&quot;) # provjerite klase sljedeih konstanti i izraza i objasnite rezultat: # NA # aritmetika operacija izmeu numeric i NA # NaN # NULL class(NA) # logiki tip je &quot;najslabiji&quot;! class(5 + NA) class(NaN) class(NULL) ## [1] NA ## [1] NaN ## ----------- ## [1] &quot;logical&quot; ## [1] &quot;numeric&quot; ## [1] &quot;numeric&quot; ## [1] &quot;NULL&quot; Provjeru nedostajuih vrijednosti radimo slino provjeri tipova podataka - koristimo funkcije is.na, is.nan i is.null. Moramo voditi rauna da je NaN zapravo podvrsta od NA te da je NULL zapravo potpuno zasebna klasa sa specifinim ponaanjem - pokuaj aritmetikih ili logikih operacija nad NULL vrijednosti nee rezultirati novom nepostojeom vrijednosti ve upozorenjima i praznim rezultatima. Ovo je posebno bitno napomenuti poznavateljima jezika SQL - ono to je NULL u SQL-u je NA u R-u i to je ono to u pravilu koristimo u praksi, dok NULL ima vrlo specifine primjene te ga puno rjee koristimo u programskom kodu. Zadatak 2.10 - provjera vrijednosti NA, NaN i NULL # to je od idueg NA? NA, NaN, NULL, &quot;&quot;, 0 # to je od idueg NaN? NA, NaN, NULL # to je od idueg NULL? NA, NaN, NULL # to je od idueg NA? NA, NaN, NULL, &quot;&quot;, 0 is.na(NA) is.na(NaN) is.na(NULL) is.na(&quot;&quot;) is.na(0) cat(&quot;-----------\\n&quot;) # to je od idueg NaN? NA, NaN, NULL is.nan(NA) is.nan(NaN) is.nan(NULL) cat(&quot;-----------\\n&quot;) # to je od idueg NULL? NA, NaN, NULL is.null(NA) is.null(NaN) is.null(NULL) ## [1] TRUE ## [1] TRUE ## logical(0) ## [1] FALSE ## [1] FALSE ## ----------- ## [1] FALSE ## [1] TRUE ## logical(0) ## ----------- ## [1] FALSE ## [1] FALSE ## [1] TRUE Za kraj posvetimo se malo NA vrijednosti, budui da emo ju vrlo esto susretati u praksi. Pojednostavljeno reeno, ukoliko se pojavljuju NA vrijednosti, moemo oekivati sljedee nuspojave: rezultati aritmetikih izraza rezultiraju sa NA vrijednosti rezultati poziva nekih funkcija rezultiraju sa NA (osim ako ne navedemo kompenzacijske akcije, kao npr. parametar na.rm = T koji zapravo znai ignoriraj NA) rezultati logikih izraza mogu ali ne moraju rezultirati sa NA vrijednosti ovisno o tom da li izraz ovisi o NA ili ne (npr. TRUE || NA ima rezultat TRUE, ali FALSE || NA ima rezultat NA) S ovim zadnjim moramo biti posebno oprezni, budui da NA u uvjetnom izrazu rezultira grekom: if (NA &lt; 2) print(&quot;Uspjeh!&quot;) # greka!! U ovoj lekciji upoznali smo se sa osnovnim elementima jezika R. U radu s R-om u pravilu radimo sa sloenim tipovima podataka koje emo upoznati u nastavku - a to su vektori, matrice, podatkovni okviri i liste. Zadaci za vjebu to je rezultat sljedeih naredbi? Razmislite o moguem rezultatu prije izvravanja. as.complex(2) as.integer(-3.25) as.logical(&quot;0&quot;) as.numeric(TRUE) as.character(11.5+2i) as.numeric(&quot;ABC&quot;) Kako u R-u izgledaju sljedei opisni izrazi: tri puta deset na devetu logaritam od 5 cjelobrojno dijeljenje 10 sa 3 ostatak cjelobrojnog dijeljenja 10 sa 3 tangens od 75 stupnjeva | Uz pomo if izraza provjerite da li se rezultat dijeljenja nule s nulom smatra kao vrijednost NA, NaN ili NULL. Ubacite u varijablu x vrijednost 5. Ispiite sve varijable okoline. Potom u varijablu x ubacite NULL. Postoji li i dalje ova varijabla? Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["vektori.html", "3 Vektori, matrice i liste 3.1 Vektori 3.2 Indeksni vektori 3.3 Matrice i polja 3.4 Liste Zadaci za vjebu", " 3 Vektori, matrice i liste 3.1 Vektori Vektor je jedan od sloenih tipova podataka u jeziku R, u smislu da sadrava vie vrijednosti istog tipa. On je kao takav slian pojmu polja u jeziku C. No ovdje postoji jedna bitna razlika, koju je nuno usvojiti budui da se radi o jednoj od najvanijih karakteristika jezika R - u R-u je (gotovo) svaki tip varijable zapravo vektor. ak i varijable i konstante koje smo koristili u prethodnoj lekciji su zapravo bili jednoelementni vektori. Ovo ima dalekosene posljedice o kojima emo detaljno raspravljati u nastavku, a za poetak se prvo upoznajmo sa sintaksom stvaranja i upravljanja vektorima. 3.1.1 Stvaranje vektora Novi vektor (koji ima vie od jednog elementa) stvaramo uz pomo funkcije c (od engl. combine). # numeriki vektor m &lt;- c(1, 2, 3, 4, 5) # logiki vektor v &lt;- c(T, F, T) # znakovni vektor imena &lt;- c(&quot;Ivo&quot;, &quot;Pero&quot;, &quot;Ana&quot;) Dakle, jednostavno reeno, vektor je ureeni skup elemenata istog tipa. Ovo konkretno znai da svi elementi vektora moraju biti istog tipa. Ako stvaramo novi vektor sa elementima razliitih tipova podataka, R e sve elemente automatski pretvoriti u najjai tip, to e na kraju postati i tip samog vektora (termin jai tip u ovom kontekstu oznaavaju mogunost tipa da pohrani svu informaciju pohranjenu u slabiji tip, a u openitom sluaju pretvorba ide u smjeru logiki -&gt; numeriki -&gt; znakovni tip). Zadatak 3.1 - stvaranje vektora # stvorite novi vektor `x` sa etiri proizvoljna elementa sljedeih tipova: # logiki, realni, znakovni i cjelobrojni # ispiite na zaslon sadraj vektora i njegovu klasu # stvorite novi vektor `x` sa etiri proizvoljna elementa sljedeih tipova: # logiki, realni, znakovni i cjelobrojni x &lt;- c(T, 1.25, &quot;Ivo&quot;, 10L) # ispiite na zaslon sadraj vektora i njegovu klasu x class(x) ## [1] &quot;TRUE&quot; &quot;1.25&quot; &quot;Ivo&quot; &quot;10&quot; ## [1] &quot;character&quot; Vektor moemo eksplicitno pretvoriti u drugi tip uz pomo ve upoznatih funkcija as.&lt;naziv_tipa&gt;. Ukoliko je pretvorbu nemogue provesti element e biti pretvoren u NA uz prikladno upozorenje. Zadatak 3.2 - eksplicitna pretvorba tipa vektora x &lt;- c(1, T, 2L) y &lt;- c(1L, 2L, 3L) z &lt;- c(1.25, TRUE, &quot;Ana&quot; ) # razmislite o moguem rezultatu a potom pokuajte izvriti sljedee pretvorbe # vektor `x` u numeriki tip # vektor `y` u znakovni tip # vektor `z` u cjelobrojni tip # razmislite o moguem rezultatu a potom pokuajte izvriti sljedee pretvorbe # vektor `x` u numeriki tip # vektor `y` u znakovni tip # vektor `z` u cjelobrojni tip as.numeric(x) as.character(y) as.integer(z) ## Warning: NAs introduced by coercion ## [1] 1 1 2 ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; ## [1] 1 NA NA Moete li odgovoriti na pitanje - zato u zadnjem primjeru vrijednost TRUE nije postala 1L ve NA? Pokuajte ispisati vektor z i uoite rezultate implicitne pretvorbe koju ste moda zanemarili (a koja je logiku vrijednost TRUE pretvorila u niz znakova \"TRUE\" kojeg vie nije mogue vratiti u numeriku vrijednost 1L). Funkcijom c moemo takoer i vie vektora spojiti u jedan: a &lt;- c(1, 2, 3) b &lt;- c(4, 5) c &lt;- c(6, 7, 8) # varijablu smijemo nazvati &quot;c&quot; usprkos tome to postoji funkcija c() d &lt;- c(a, b, c) # d je sada c(1, 2, 3, 4, 5, 6, 7, 8) Pored funkcije c, R nudi i dodatne pogodne naine stvaranja novih vektora: : - operator raspona (engl. range), pri emu dajemo raspon od gornje do donje granice, obje ukljuive seq - funkcija sekvence (engl. sequence), radi slino operatoru raspona, ali s dodatnim mogunostima rep - funkcija repliciranja (engl. replicate), ponavlja zadane elemente zadani broj puta Zadatak 3.3 - pomone funkcije za stvaranje vektora # ispiite rezultate sljedeih naredbi # 1:5 # rep(c(1, 2, 3), times = 3) # rep(c(1, 2, 3), each = 3) # seq(1, 5, by = 0.5) # ispiite rezultate sljedeih naredbi 1:5 rep(c(1, 2, 3), times = 3) rep(c(1, 2, 3), each = 3) seq(1, 5, by = 0.5) ## [1] 1 2 3 4 5 ## [1] 1 2 3 1 2 3 1 2 3 ## [1] 1 1 1 2 2 2 3 3 3 ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 Vektore moemo stvoriti i uz pomo funkcija koje odgovaraju imenima tipova vektora (numeric, character i sl.) pri emu kao parametar navodimo eljenu duljinu vektora. Ovo esto radimo kao pripremu vektora za naknadno punjenje stvarnim vrijednostima, tj. svojevrsnu rezervaciju mjesta u radnoj memoriji. Ono to je interesantno jest injenica da moemo stvoriti i prazan vektor odreenog tipa koji je i dalje vektor, samo sa duljinom nula (a kojem npr. uz pomo funkcije c moemo naknadno dodavati elemente). x &lt;- numeric(2) # vektor se puni &quot;nultim&quot; elementima, u ovom sluaju (0, 0) y &lt;- character(5) z &lt;- integer(0) # &quot;prazan&quot; vektor! z &lt;- c(z, 1) # dodaj vektoru element 1 (zapravo &quot;spoji prazan vektor i element 1&quot;) Konano, provjeru da li neki vektor sadri odreeni element moemo napraviti uz pomo operatora %in%: 4 %in% seq(1, 10, 2) # vraa FALSE &quot;d&quot; %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) # vraa TRUE Pogledajmo sada kako pristupiti pojedinim elementima vektora 3.1.2 Operator [ Elementima vektora pristupamo preko indeksnog operatora [, uz pomo kojeg moemo i mijenjati elemente vektora: a &lt;- c(2, 4, 6) a[1] # ispisuje vrijednost 2 a[2] &lt;- 5 # element na 2. mjestu postaje 5 a[5] &lt;- 7 # na 5. mjesto dodaje se 7, a &quot;rupa&quot; se popunjava sa NA a ## [1] 2 ## [1] 2 5 6 NA 7 Uoite jednu pomalo neuobiajenu injenicu - prvi element vektora u R-u ima indeks 1, a ne 0! Ovo je bitna razlika u odnosu na referenciranje elemenata u drugim programskim jezicima. Razlog ove specifinosti je jednostavan - R se primarno smatra jezikom za analizu podataka, poglavito u tablinom obliku, a u praksi je puno lake brojati retke ili stupce redoslijedom kako se pojavljuju u podatkovnom skupu nego raditi posmak za 1. Primjer gore zapravo prikazuje vrlo pojednostavljeni sluaj pristupanja elementima vektora i nain njihove izmjene. Naime, jedna od specifinosti jezika R je tzv. vektoriziranost, tj. princip da se u R-u vrlo esto radi vie stvari odjednom - ne toliko u smislu paralelnog izvravanja, ve u smislu zadavanja naredbi to elimo da se izvede. Konkretno, u sluaju referenciranja elemenata vektora vrlo rijetko dohvaamo ili mijenjamo elemente jedan po jedan, ve obuhvaamo vei broj elemenata odjednom koritenjem principa vektorizacije i recikliranja. Razumijevanje ovih pojmova presudno je za svladavanje jezika R, tako da emo ih detaljno objasniti u nastavku. 3.1.3 Principi vektorizacije i recikliranja Pojam vektorizacije ili bolje reeno vektoriziranih operacija i funkcija jednostavno znai da se operacije rade nad vie elemenata odjednom. Ako zadamo R-u da radi neku operaciju ili funkciju nad nekim vektorom vrijednosti, R e funkciju ili operaciju izvesti nad svakim elementom posebno i vratiti rezultantni vektor kao rezultat. Isto tako, ako provodimo binarnu operaciju nad dva vektora, ona e se provesti nad uparenim ili poravnatim elementima obaju vektora (pretpostavimo za sada da su vektori jednake duljine). Zadatak 3.4 - princip vektorizacije x &lt;- seq(-5, 5, 1) a &lt;- 1:3 b &lt;- 4:6 # pozovite funkciju `abs` za raunanje apsolutne vrijednosti # nad vektorom `x` i ispiite rezultat # zbrojite vektore `a` i `b` uz pomo operatora `+` # i ispiite rezultat # pomnoite vektore `a` i `b` uz pomo operatora `*` # i ispiite rezultat # pozovite funkciju `abs` za raunanje apsolutne vrijednosti # nad vektorom `x` i ispiite rezultat abs(x) cat(&quot;-----------\\n&quot;) # zbrojite vektore `a` i `b` uz pomo operatora `+` # i ispiite rezultat a + b cat(&quot;-----------\\n&quot;) # pomnoite vektore `a` i `b` uz pomo operatora `*` # i ispiite rezultat a * b ## [1] 5 4 3 2 1 0 1 2 3 4 5 ## ----------- ## [1] 5 7 9 ## ----------- ## [1] 4 10 18 Paljivo razmotrite rezultate prethodnog zadatka. Ukoliko je potrebno, skicirajte vektore a i b na papiru sa vertikalno poslaganim elementima i uoite kako radi paralelno uparivanje elemenata. Primijetite da ovdje ne priamo o vektorskim operacijama u strogom matematikom smislu, ve o poravnavanju elemenata dvaju nizova i provoenja jednostavnih operacija nad svakim od tih parova. Ovo je pogotovo oito u zadnjem primjeru gdje nema nikakvog mnoenja vektora u nekoj od matematikih interpretacija, ve se provodi jednostavno mnoenje paralelnih elemenata dvaju vektora. to ako vektori nisu jednake duljine? R u ovom sluaju koristi princip recikliranja. Princip recikliranja navodi da se kod nejednake duljine vektora krai vektor reciklira onoliko puta koliko je potrebno da se dostigne duljina duljeg vektora. Najei scenarij koritenja ovog principa su operacije u kojima je s jedne strane vektor s vie elemenata a s druge strane jednoelementni vektor koji se onda reciklira za svaki element velikog vektora. Ono to bismo trebali izbjegavati jest scenarij recikliranja gdje duljina velikog vektora nije viekratnik duljine malog - R e i dalje reciklirati krai vektor, samo e ga na kraju morati odrezati to e rezultirati odgovarajuim upozorenjem. Zadatak 3.5 - princip recikliranja a &lt;- 1:4 b &lt;- c(1, 2) c &lt;- rep(5, 3) # udvostruite elemente vektora `a` i ispiite rezultat # podijelite vektor `a` vektorom `b` i ispiite rezultat # pomnoite vektore `a` i `c` i ispiite rezultat a &lt;- 1:4 b &lt;- c(1, 2) c &lt;- rep(5, 3) # udvostruite elemente vektora `a` i ispiite rezultat 2 * a # podijelite vektor `a` vektorom `b` i ispiite rezultat a / b # pomnoite vektore `a` i `c` i ispiite rezultat a * c ## Warning in a * c: longer object length is not a multiple of shorter object ## length ## [1] 2 4 6 8 ## [1] 1 1 3 2 ## [1] 5 10 15 20 Sada konano moemo demistificirati razliku izmeu skalarnih i vektorskih logikih operatora (podsjetimo se, skalarni su || i &amp;&amp;, dok su vektorski | i &amp;). Skalarni logiki operatori namijenjeni su koritenju sa jednoelementnim vektorima, vraaju jedinstvenu vrijednosti TRUE ili FALSE te su pogodni za koritenje raznim u uvjetnim izrazima. Vektorski logiki operatori koriste standardne R-ove principe vektorizacije i recikliranja, tj. namijenjeni su radu sa logikim vektorima i kao rezultat daju logiki vektor Zadatak 3.6 - skalarni i vektorski logiki operatori a &lt;- c(T, F, F) b &lt;- c(T, T, F) # primjenite skalarnu i vektorsku inaicu logikog operatora &quot;ili&quot; # nad vektorima `a` i `b` i ispiite rezultat # primjenite skalarnu i vektorsku inaicu logikog operatora &quot;ili&quot; # nad vektorima `a` i `b` i ispiite rezultat a || b a | b ## [1] TRUE ## [1] TRUE TRUE FALSE Vidimo da e skalarna inaica iskoristiti samo prvi par elemenata logikih vektora. Ovo znai da ju u teoriji moemo koristiti u uvjetnim izrazima, iako za to nema opravdanog smisla, a R e se u tom sluaju oglasiti upozorenjem kako bi nam obratio panju na injenicu da vjerojatno koristimo krivi operator. Sljedei primjer sa usporednim operatorima e moda inicijalno izgledati trivijalan, no potrebno je obratiti posebnu panju na rezultate koje emo dobiti budui da e oni imati vrlo vanu primjenu u nastavku lekcije. Dakle, pogledajmo to se dogaa kod vektorizacije usporednih operatora. Zadatak 3.7 - vektorizacija usporednih operatora x &lt;- 1:5 y &lt;- seq(-10, 10, 5) #ispiite x i y #ispiite rezultat naredbe x &gt; y i objasnite rezultat #ispiite rezultat naredbe x &lt; 3 i objasnite rezultat #ispiite x i y x y cat(&quot;-----------\\n&quot;) #ispiite rezultat naredbe x &gt; y i objasnite rezultat x &gt; y cat(&quot;-----------\\n&quot;) #ispiite rezultat naredbe x &lt; 3 i objasnite rezultat x &lt; 3 ## [1] 1 2 3 4 5 ## [1] -10 -5 0 5 10 ## ----------- ## [1] TRUE TRUE TRUE FALSE FALSE ## ----------- ## [1] TRUE TRUE FALSE FALSE FALSE Dakle vektoriziranom primjenom usporednih operatora nad vektorima (ili kombinacijama vektora i skalara) kao rezultat dobivamo logike vektore. Interpretacija ovih rezultata je kljuna - ona zapravo odgovara na pitanje na kojim indeksima je zadovoljen uvjet zadan ovim izrazom? Drugim rijeima, dobiveni rezultati zapravo predstavljaju predloak koji opisuje kako filtrirati elemente prema zadanom principu. Ovo je osnovni temelj tzv. logikog referenciranja, to je jedna od metoda dohvaanja elemenata vektora koje emo upoznati u nastavku. 3.2 Indeksni vektori Ve smo nauili da elementu polja moemo pristupiti preko numerikog indeksa (a nismo zaboravili ni injenicu da prvi element ima indeks 1). Ovaj koncept moemo proiriti tako da iz vektora uzimamo vie elemenata odjednom. to se esto naziva rezanjem vektora (engl. slicing). Osnovni princip odabira vie elemenata odjednom je jednostavan - samo moramo na odreeni nain navesti indekse elemenata koje elimo. R nudi tri osnovna naina referenciranja: lokacijsko referenciranje (engl. integer- or location-based referencing) uvjetno referenciranje (engl. conditional- or boolean-based referencing) imensko referenciranje (engl. label-based referencing) Koje referenciranje emo odabrati ovisi o tome elimo li elementima pristupati ovisno o njihovoj lokaciji, imenu ili prema zadanom uvjetu, a svaki tip referenciranja u sutini se svodi na koritenje vektora odreenog tipa kao parametra za operator referenciranja. Ovakav vektor se zbog svoje uloge naziva indeksnim vektorom. Upoznajmo detaljno svaki od tipova referenciranja. 3.2.1 Lokacijsko referenciranje Lokacijsko referenciranje je poopenje ve upoznatog principa referenciranja gdje navodimo redni broj elementa koji nas zanima. Ako elimo vie elemenata, jednostavno navedemo njihove indekse zapakirane u numeriki vektor. Pokuajte rijeiti sljedei zadatak koritenjem odgovarajuih numerikih vektora kao parametara indeksnog operatora. Zadatak 3.8 - lokacijsko referenciranje x &lt;- 1:10 # ispiite prvi element vektora x # ispiite prva tri elementa vektora x # ispiite prvi, peti i sedmi element vektora x # ispiite prvi element vektora x x[1] # ispiite prva tri elementa vektora x x[1:3] # ispiite prvi, peti i sedmi element vektora x x[c(1,5,7)] ## [1] 1 ## [1] 1 2 3 ## [1] 1 5 7 Dakle, lokacijski indeksni vektor nije nita drugo nego obian numeriki vektor kojeg koristimo zajedno sa indeksnim operatorom da bi odredili koje elemente nekog drugog vektora elimo zadrati. Pogledajmo jo neke znaajke lokacijskih indeksnih vektora: Zadatak 3.9 - lokacijsko referenciranje (2) x &lt;- 1:10 # odgovorite na sljedea pitanja uz pomo prikladnog primjera # to vraa indeks 0? # to vraa negativni indeks? # to vraa indeks izvan granica duljine vektora x &lt;- 1:10 # odgovorite na sljedea pitanja uz pomo prikladnog primjera # to vraa indeks 0? x[0] # to vraa negativni indeks? x[-1] # to vraa indeks izvan granica duljine vektora x[20] ## integer(0) ## [1] 2 3 4 5 6 7 8 9 10 ## [1] NA Indeksni operator se ne koristi samo za dohvaanje elemenata. Kombinacijom indeksnog operatora i operatora pridruivanja moemo mijenjati elemente vektora (i to takoer po principu vie elemenata odjednom: Zadatak 3.10 - lokacijsko referenciranje i pridruivanje a &lt;- 1:10 # postavite sve elemente vektora `a` od drugog do osmog mjesta na nulu # ispiite vektor `a` b &lt;- 1:20 b[2 * 1:5] &lt;- 0 # razmislite kako izgleda vektor `b` nakon gornje naredbe # ispiite vektor `b` i objasnite rezultat a &lt;- 1:10 # postavite sve elemente vektora `a` od drugog do osmog mjesta na nulu # ispiite vektor `a` a[2:8] &lt;- 0 a b &lt;- 1:20 b[2 * 1:5] &lt;- NA # razmislite kako izgleda vektor `b` nakon gornje naredbe # ispiite vektor `b` i objasnite rezultat b ## [1] 1 0 0 0 0 0 0 0 9 10 ## [1] 1 NA 3 NA 5 NA 7 NA 9 NA 11 12 13 14 15 16 17 18 19 20 3.2.2 Uvjetno referenciranje Ako smo paljivo razmotrili rezultate dobivene kod primjera sa vektoriziranim usporednim operatorima onda smo mogli vrlo dobro naslutiti kako radi uvjetno referenciranje. Princip je jednostavan - za indeksni vektor postavljamo logiki vektor iste duljine kao i vektor ije elemente elimo dohvatiti. Elementi logikog vektora odreuju koje elemente zadravamo (pozicije gdje se nalazi vrijednost TRUE) a koje odbacujemo (pozicije gdje se nalazi vrijednost FALSE). Zadatak 3.11 - uvjetno referenciranje x &lt;- 1:10 # napravite logiki vektor `y` duljine 10 sa proizvoljnom kombinacijom # vrijednosti TRUE i FALSE # indeksirajte vektor `x` vektorom `y`, ispiite i objasnite rezultat # ispiite sve elemente vektora `x` manje ili jednake 5 # kao logiki indeksni vektor upotrijebite odgovarajui izraz # koji koristi usporedni operator x &lt;- 1:10 # napravite logiki vektor `y` duljine 10 sa proizvoljnom kombinacijom # vrijednosti TRUE i FALSE y &lt;- c(T, T, F, T, F, F, F, T, F, T) # indeksirajte vektor `x` vektorom `y`, ispiite i objasnite rezultat x[y] # ispiite sve elemente vektora `x` manje ili jednake 5 # kao logiki indeksni vektor upotrijebite odgovarajui izraz # koji koristi usporedni operator x[x &lt;= 5] ## [1] 1 2 4 8 10 ## [1] 1 2 3 4 5 Zadnja naredba, naoko jednostavna, predstavlja jedan od kljunih principa odabira elemenata u jeziku R. Kombinacija indeksnog operatora i uvjetnog izraza predstavlja saet ali vrlo moan mehanizam rezanja vektora prema odabranom kriteriju. Isprobajmo ovaj princip na jo nekoliko primjera. Zadatak 3.12 - uvjetno referenciranje y &lt;- sample(1:100, 20) # nasumicni odabir 20 elemenata izmedju 1 i 100 studenti &lt;- c(&quot;Ivo&quot;, &quot;Petra&quot;, &quot;Marijana&quot;, &quot;Ana&quot;, &quot;Tomislav&quot;, &quot;Tin&quot;) # ispiite vektor koji sadri sve parne, a potom sve neparne elemente vektora `y` # ispiite sve elemente vektora `studenti` koji predstavljaju imena od 3 slova # (napomena: za prebrojavanje slova znakovnog niza u R-u koristimo funkciju `nchar`) y &lt;- seq(1, 100, 7) studenti &lt;- c(&quot;Ivo&quot;, &quot;Petra&quot;, &quot;Marijana&quot;, &quot;Ana&quot;, &quot;Tomislav&quot;, &quot;Tin&quot;) # ispiite vektor koji sadri sve parne, a potom sve neparne elemente vektora `y` c(y[y %% 2 == 0], y[y %% 2 != 0]) # ispiite sve elemente vektora `studenti` koji predstavljaju imena od 3 slova # (napomena: za prebrojavanje slova znakovnog niza u R-u koristimo funkciju `nchar`) studenti[nchar(studenti) == 3] ## [1] 8 22 36 50 64 78 92 1 15 29 43 57 71 85 99 ## [1] &quot;Ivo&quot; &quot;Ana&quot; &quot;Tin&quot; Ukoliko koncept uvjetnog referenciranja uz pomo uvjetnih izraza i dalje nije jasan, jedna od stvari koje mogu pomoi jest skiciranje meurezultata - jednostavno na papir ispiite rezultat izraza unutar uglatih zagrada indeksnog operatora i potom razmislite kako taj rezultat utjee na konano rjeenje. Preostao nam je jo samo zadnji tip referenciranja koji radi na principu dohvaanja elemenata vektora ovisno o njihovom imenu. 3.2.3 Imensko referenciranje Imensko referenciranje radi na principu eksplicitnog imenovanja elemenata koje elimo zadrati. Da bi mogli koristiti ovakav tip referenciranja moramo zadovoljiti nuan preduvjet - elementi vektora moraju imati definirana imena. Vektori koje smo do sada koristili nisu imali imenovane elemente. Svaki element imao je svoju predefiniranu poziciju unutar vektora te svoju vrijednost, ali nije imao nikakav poseban dodatni identifikator. Programski jezik R doputa pridavanje imena elementima vektora na vrlo jednostavan nain - koritenjem funkcije names, operatora pridruivanja te znakovnog vektora sa odabranim imenima. Moramo voditi rauna da vektor imena bude jednake duljine kao originalni vektor! Zadatak 3.13 - imensko referenciranje visine &lt;- c(165, 173, 185, 174, 190) names(visine) &lt;- c(&quot;Marica&quot;, &quot;Pero&quot;, &quot;Josip&quot;, &quot;Ivana&quot;, &quot;Stipe&quot;) # ispiite vektor `visine` # ispiite koliko su visoki Pero i Ivana visine &lt;- c(165, 173, 185, 174, 190) names(visine) &lt;- c(&quot;Marica&quot;, &quot;Pero&quot;, &quot;Josip&quot;, &quot;Ivana&quot;, &quot;Stipe&quot;) # ispiite vektor `visine` visine # ispiite koliko su visoki Pero i Ivana visine[c(&quot;Pero&quot;, &quot;Ivana&quot;)] ## Marica Pero Josip Ivana Stipe ## 165 173 185 174 190 ## Pero Ivana ## 173 174 Vidimo da se imensko referenciranje oekivano svodi na prosljeivanje odgovarajueg znakovnog vektora kao parametra referenciranja. (NAPOMENA: Paljiviji itatelj uoiti e jednu neobinu injenicu u gornjem programskom kodu - poziv funkcije se koristi kao lvalue! Odgovor na pitanje zato je ovo mogue zahtijeva malo vie znanja o internom funkcioniranju jezika R, a za sada je dovoljno rei da se ovdje zapravo radi o pozivu funkcije pravog imena names&lt;- koji se skriva iza puno intuitivnije i lako razumljive sintakse) Ukoliko iz nekog razloga poelimo obrisati imena elemenata vektora, jednostavno pozivu funkcije names proslijedimo NULL. names(visine) &lt;- NULL Ovime emo zakljuiti priu o vektorima. Nauili smo razliite naine stvaranja vektora te dohvaanja i izmjene njegovih elemenata. Sada je vrijeme da pokuamo vektorima dodati dodatnu dimenziju - upoznajmo matrice i polja. 3.3 Matrice i polja Matrice i polja su, jednostavno reeno, viedimenzionalni vektori. Matrica (engl. matrix) je tako vektor sa dvije dimenzije, tj. vektor koji elemente smijeta u retke i stupce. Polje (engl. array) je vektor sa tri ili vie dimenzija. Dok se matrice relativno esto koriste u praksi, polja su ipak neto vie ograniena na posebne scenarije. Zbog ove injenice u ovom poglavlju uglavnom emo se baviti matricama, iako se prikazani koncepti vrlo lako poopuju na polja. Ono to je zajedniko matricama i poljima, a to je poznata injenica itateljima sa programerskim iskustvom, jest da je njihova viedimenzionalnost zapravo prividna. I matrice i polja su zapravo jednodimenzionalni vektori kojima je dodan atribut dimenzionalnosti, a uz pomo tog atributa jezik R mapira nae viedimenzionalno referenciranje u stvarni indeks elementa jednodimenzionalnog vektora. Ova injenica nas ne ograniava - mi i dalje moemo u veini sluajeva tretirati matricu kao da je zaista dvodimenzionalna, a znanje o jednodimenzionalnoj prirodi nam moe samo dati dodatnu fleksibilnost u radu s matricama. Postoji nekoliko naina stvaranja nove matrice: uz pomo funkcije matrix kojoj prosljeujemo jednodimenzionalni vektor i eljeni broj redaka i stupaca kroz parametre nrow i ncol runim postavljanjem dimenzija jednodimenzionalnog vektora uz pomo funkcije dim i pridruivanja dvoelementnog numerikog vektora sa dimenzijama matrice ljepljenjem jednodimenzionalnih vektora koji predstavljaju retke ili stupce nove matrice uz pomo funkcija rbind (engl. row bind) i cbind (engl. column bind) Demonstrirajmo ove naine u primjerima koji slijede. Zadatak 3.14 - funkcija matrix x &lt;- 1:12 # uz pomo funkcije `matrix` i stvorite matricu sa 3 retka i 4 stupca # koja sadri elemente vektora `x` # ispiite rezultat na zaslon # ponovite postupak ali pozivu funkcije dodajte parametar `byrow = T` # ispiite rezultat na zaslon i usporedite s prethodnim rezultatom # uz pomo funkcije `matrix` stvorite matricu sa 3 retka i 4 stupca # koja sadri elemente vektora `x` # ispiite rezultat na zaslon matrix(x, nrow = 3, ncol = 4) # ponovite postupak ali pozivu funkcije dodajte parametar `byrow = T` # ispiite rezultat na zaslon i usporedite s prethodnim rezultatom matrix(x, nrow = 3, ncol = 4, byrow = T) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 Uoite da ga ukoliko eksplicitno ne zamolimo drugaije, R matricu popunjava po stupcima. Ovo je napravljeno zbog slinosti matrice sa tablinim prikazom podataka koje najee analiziramo gledajui pojedine stupce. No budui da nam je esto punjenje po retcima prirodnije, ne smijemo zaboraviti na vrlo korisni parametar byrow. Zadatak 3.15 - funkcija dim m &lt;- 1:10 # ispiite rezultat poziva funkcije `dim` nad vektorom `m` # pozivu funkcije `dim` nad vektorom `m` pridruite vektor c(2, 5) # ispiite `m` i komentirajte rezultat # ispiite rezultate poziva funkcija `nrow` i `ncol` nad matricom `m` m &lt;- 1:10 # ispiite rezultat poziva funkcije `dim` nad vektorom `m` dim(m) # pozivu funkcije `dim` nad vektorom `m` pridruite vektor c(2, 5) dim(m) &lt;- c(2, 5) # ispiite `m` i komentirajte rezultat m # ispiite rezultate poziva funkcija `nrow` i `ncol` nad matricom `m` nrow(m) ncol(m) ## NULL ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 ## [1] 2 ## [1] 5 Vidimo da obian vektor zapravo nema dimenziju, to se oituje preko NULL vrijednosti koju smo dobili kao rezultat. Pozivom funkcije dim mi vektoru zapravo dodajemo atribut naziva dim ime on formalno postaje matrica (tj. polje u openitom sluaju). Upravo dimenzije su te koje definiraju kako su elementi sloeni po retcima i stupcima a postavljanjem dimenzija moramo biti oprezni da one odgovaraju trenutnom broju elemenata. Jednom kad matrica ima dodane dimenzije, moemo ih dohvatiti zajedno uz pomo funkcije dim, ili samo broj redaka ili stupaca uz pomo funkcija nrow i ncol. Rezultantna matrica je poput one iz prethodnog primjera popunjena po stupcima. Budui da ovdje nemamo priliku koristiti parametar byrow, jedan od naina da dobijemo matricu popunjenu po retcima jest da transponiramo dobiveni rezultat uz pomo funkcije t. m &lt;- t(m) # transponiramo matricu i pohranjujemo natrag u varijablu `m` Konano, matricu moemo stvoriti ljepljenjem redaka i stupaca uz pomo funkcija rbind i cbind. Ovo je takoer zgodan nain dodavanja novih redaka i stupaca postojeoj matrici. Zadatak 3.16 - funkcije rbind i cbind a &lt;- 1:4 b &lt;- 5:8 c &lt;- c(0,0) # stvorite matricu `m` u kojoj e vektori `a` i `b` biti retci # dodajte novi redak na vrh matrice `m` sa elementima vektora `c` # ispiite matricu `m` a &lt;- 1:4 b &lt;- 5:8 c &lt;- c(0,0) # stvorite matricu `m` u kojoj e vektori `a` i `b` biti stupci m &lt;- cbind(a,b) # dodajte novi redak na vrh matrice `m` sa elementima vektora `c` # ispiite matricu `m` m &lt;- rbind(c, m) m ## a b ## c 0 0 ## 1 5 ## 2 6 ## 3 7 ## 4 8 Vidimo da su retci i stupci naslijedili imena vektora od kojih su nastali, to je ponekad zgodno kao vizualni podsjetnik ili jednostavnije referenciranje. Ukoliko elimo promijeniti (ili ukloniti) imena redaka ili stupaca, umjesto funkcije names kod matrica koristimo funkcije rownames ili colnames. 3.3.1 Rezanje matrica Sve nauene principe za rezanje vektora uz pomo indeksnih vektora moemo direktno primijeniti nad matricama. Razlike su sljedee: referenciramo svaku dimenziju zasebno prvo referenciramo retke, a potom stupce, a indeksne vektore odvajamo zarezom ako elimo sve retke ili sve stupce taj indeksni vektor jednostavno izostavimo (ali i dalje koristimo zarez) # pretpostavimo da je `m` matrica dimenzija 3 x 5, sa imenima stupaca od `a` do `e` m[1, 2:5] # prvi redak, svi stupci od drugog do petog m[c(F, T, T), c(&quot;a&quot;, &quot;b&quot;)] # drugi i trei redak, stupci `a` i `b` m[,] # svi retci i svi stupci (moe i samo `m`) U praksi kod matrica najee koristimo lokacijsko i imensko referenciranje; uvjetno referenciranje nije previe praktino zbog dvodimenzionalne prirode matrice (iako je izvedivo, samo moramo voditi rauna da logiki indeksni vektori duljinom odgovaraju pripadajuoj dimenziji). Jedna od stvari na koju moramo voditi rauna jest tendencija jezika R da nam pomae pojednostavljujui rezultat. Tako e rezultat operacije rezanja matrice koja ostavlja samo jedan redak ili stupac automatski postati vektor, tj. izgubiti e atribut dimenzije. Ovo nam nekad ne odgovara, pogotovo ako radimo programske skripte koje u daljnjoj proceduri oekuju matricu, pa makar ona imala dimenziju redaka ili stupaca 1. U tom sluaju kod referenciranja moramo postaviti i dodatni parametar drop = F. Ovo esto izgleda dosta nezgrapno, zbog ega danas postoje mnogi paketi proirenja jezika R koji ovo popravljaju, tj. koji se trude rezultat ostavljati u konzistentnom obliku. No parametar drop postavljen na FALSE treba imati u vidu, budui da e se pojavljivati i na drugim mjestima u slinoj funkciji. Zadatak 3.17 - rezanje matrica m &lt;- matrix(1:30, 6, 5, T) colnames(m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # ispiite sve elemente matrice m od drugog do etvrtog retka # te od treeg do petog stupca # sve elemente u stupcu naziva &quot;c&quot; postavite na nulu # a potom ispiite prva dva retka matrice `m` # ispiite samo stupac &quot;d&quot; # ispiite opet stupac &quot;d&quot;, ali kod referenciranja dodajte parametar `drop = FALSE` # parametar odvojite zarezom (kao da se radi o &quot;treoj&quot; dimenziji referenciranja) m &lt;- matrix(1:30, 6, 5, T) colnames(m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # ispiite sve elemente matrice `m` od drugog do etvrtog retka # te od treeg do petog stupca m[2:4, 3:5] # sve elemente u stupcu naziva &quot;c&quot; postavite na nulu # a potom ispiite prva dva retka matrice `m` m[, &quot;c&quot;] &lt;- 0 m[1:2,] # ispiite samo stupac &quot;d&quot; m[, &quot;d&quot;] # ispiite opet stupac &quot;d&quot;, ali kod referenciranja dodajte parametar `drop = FALSE` # parametar odvojite zarezom (kao da se radi o &quot;treoj&quot; dimenziji referenciranja) m[, &quot;d&quot;, drop = F] ## c d e ## [1,] 8 9 10 ## [2,] 13 14 15 ## [3,] 18 19 20 ## a b c d e ## [1,] 1 2 0 4 5 ## [2,] 6 7 0 9 10 ## [1] 4 9 14 19 24 29 ## d ## [1,] 4 ## [2,] 9 ## [3,] 14 ## [4,] 19 ## [5,] 24 ## [6,] 29 Ovdje emo zavriti priu o matricama. Ove strukture su vrlo korisne kod rjeavanja matematikih zadataka zasnovanih na matricama, pri emu je esto zgodno pogledati dokumentaciju jezika R kako bi vidjeli koje funkcije i operatori su nam dostupni za takav posao. Isto tako, neki prikazani principi upravljanja matricama biti e korisni kod upravljanja tzv. podatkovnim okvirima - vjerojatno najpopularnijem tipu objekta jezika R kojeg emo upoznati u jednom od nastupajuih poglavlja. Konano, iako se neemo detaljno baviti poljima, prikaimo radi potpunosti primjer programskog koda koji stvara trodimenzionalno polje te potom ispisuje jedan njegov dio standardnim principom rezanja kojeg smo upoznali kod vektora i matrica. polje &lt;- array(1:24, dim = c(2, 3, 4)) # polje dimenzija 2 x 3 x 4 polje[, 1:2, 3, drop = FALSE] # ispis svih redaka, prvog i drugog stupca # treeg &quot;sloja&quot;, uz zadravanje tipa polja Polja su koristan tip objekta za viedimenzionalne izraune i specijalizirane svrhe, npr. kod programiranja s tenzorima. Bitno je shvatiti da se usprkos dodatnoj kompleksnosti koju donosi viedimenzionalnost veliki dio funkcionalnosti direktno preslikava iz funkcija za upravljanje niedimenzionalnim objektima, moda uz manje preinake - npr. za imenovanje slojeva polja neemo koristiti names niti rownames/colnames ve funkciju dimnames uz eksplicitno navoenje indeksa dimenzije koju imenujemo. 3.4 Liste Lista je element programskog jezika R koji se koristi kao univerzalni spremnik bilo kakvih podataka. Za razliku od vektora (tj. od pojma vektora kakvog smo ga inicijalno definirali), lista moe sadravati razliite tipove podataka ili - ee - skupove razliitih tipova podataka. Listu stvaramo uz pomo funkcije list kojom dodajemo niz parova naziva elemenata i njihovih sadraja. Ovi elementi mogu biti bilo to, pa ak i druge liste. mojaLista &lt;- list(a = 1, b = 2:100, c = list(x = 1, y = 2)) Probajmo stvoriti vlastitu listu u sljedeem primjeru. Zadatak 3.18 - stvaranje liste # stvorite novu listu naziva `svastara` koja e imati sljedee elemente # element naziva `brojevi` sa cijelim brojevima od 1 do 3 # element naziva `slova` sa slovima &quot;A&quot; i &quot;B&quot; # bezimeni element sa logikim vektorom `c(T,F)` # element naziva `imena` sa imenima &quot;Ivo&quot; i &quot;Ana&quot; # ispiite listu `svastara` svastara &lt;- list(brojevi = c(1,2,3), slova = c(&quot;A&quot;, &quot;B&quot;), c(T,F), imena = c(&quot;Ivo&quot;, &quot;Ana&quot;)) # ispiite listu `svastara` svastara ## $brojevi ## [1] 1 2 3 ## ## $slova ## [1] &quot;A&quot; &quot;B&quot; ## ## [[3]] ## [1] TRUE FALSE ## ## $imena ## [1] &quot;Ivo&quot; &quot;Ana&quot; Uoite da lista zadrava poredak elemenata - element bez imena prikazan je indeksom 3. Funkcija str (engl. structure) omoguuje nam uvid u svojstva i sadraj liste bez ispisivanja cijele liste. Ovu funkciju analitiari esto koriste, kako za pregled lista tako i za brzi uvid u ve spomenute podatkovne okvire koje emo raditi u iduem poglavlju. Zadatak 3.19 - struktura liste # ispiite strukturu liste `svastara` # ispiite strukturu liste `svastara` str(svastara) ## List of 4 ## $ brojevi: num [1:3] 1 2 3 ## $ slova : chr [1:2] &quot;A&quot; &quot;B&quot; ## $ : logi [1:2] TRUE FALSE ## $ imena : chr [1:2] &quot;Ivo&quot; &quot;Ana&quot; Na poetku ove lekcije smo rekli da u R-u vrijedi princip sve je vektor te da su vektori zapravo ureeni skupovi elemenata istog tipa. Iz ovog bi se moglo zakljuiti da ta injenica ne vrijedi za liste - oni oito sadravaju elemente razliitih tipova. No pravi odgovor je - i liste su zapravo vektori, a definicija zapravo nije naruena. Naime, svi elementi liste su zapravo male jednoelementne liste, tako da su formalno svi elementi istog tipa. Zadatak 3.20 - tip elemenata liste # ispiite prvi element liste svastara # provjerite njegov tip # ispiite prvi element liste svastara svastara[1] # provjerite njegov tip typeof(svastara[1]) ## $brojevi ## [1] 1 2 3 ## ## [1] &quot;list&quot; Dakle, dokazali smo da su elementi liste zapravo male liste, to se vidi iz ispisa samog elementa, kao i provjere njezinog tipa. Moda nam se ini da bi elementi gore stvorene liste trebali biti vektori, budui da smo listu i stvorili slaganjem razliitih vektora, no u postupku stvaranja objekta R je umotao elemente u jednoelementne liste prije nego ih je uklopio u veliku listu. esto ne elimo raditi s elementom liste kao malom listom, nego ga trebao u njegovom originalnom obliku. Za ovo koristimo operator [[, tj. operator dvostruke uglate zagrade. Zadatak 3.21 - operator [[ # ispiite prvi element liste svastara koritenjem operatora `[[` # provjerite njegov tip # ispiite prvi element liste svastara svastara[[1]] # provjerite njegov tip typeof(svastara[[1]]) ## [1] 1 2 3 ## [1] &quot;double&quot; Navedeni operator najee koristimo kako bi dohvatili odabrani element liste kojeg definiramo brojem ili (ako ima ime) nazivom elementa. Kod ovakvog dohvata moramo koristiti kombinaciju simbola lista[[\"ime_elementa\"]] koja je poneto nespretna za tipkanja. Zbog toga R nudi alternativni nain pristupa elementima liste prema nazivu koritenjem operatora $, tj. lista$ime_elementa. Zadatak 3.22 - operator $ # ispiite element naziva &quot;slova&quot; liste svastara # koritenjem operatora `[[` # ispiite isti element koritenjem operatora `$` # ispiite element naziva &quot;slova&quot; liste svastara # koritenjem operatora `[[` svastara[[&quot;slova&quot;]] # ispiite isti element koritenjem operatora `$` svastara$slova ## [1] &quot;A&quot; &quot;B&quot; ## [1] &quot;A&quot; &quot;B&quot; Liste su iznimno popularni tip objekta u R-u budui da predstavljaju univerzalni predloak za kompleksnije podatkovne strukture, izmeu ostalog i kompleksnije objekte u uem smislu (kao to emo vidjeti kasnije). Lista je takoer temelj za daleko najpopularniji i najee koriteni element jezika R - podatkovni okvir - kojeg emo upoznati u iduoj lekciji. Za kraj nauimo dodati element u listu. Ovo je najjednostavnije uiniti koritenjem ve spomenutog operatora $ - kao npr. lista$noviElement &lt;- noviElement. Element briemo tako da mu dodijelimo vrijednost NULL. Zadatak 3.23 - dodavanje elementa u listu # listi `svastara` dodajte element `parniBrojevi` koji sadri # sve parne brojeve od 1 do 100 # obriite trei element liste # ispiite listu `svastara` # listi `svastara` dodajte element `parniBrojevi` koji sadri # sve parne brojeve od 1 do 100 svastara$parniBrojevi &lt;- seq(2, 100, 2) # obriite trei element liste svastara[[3]] &lt;- NULL # ispiite listu `svastara` print(svastara) ## $brojevi ## [1] 1 2 3 ## ## $slova ## [1] &quot;A&quot; &quot;B&quot; ## ## $imena ## [1] &quot;Ivo&quot; &quot;Ana&quot; ## ## $parniBrojevi ## [1] 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 ## [20] 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 ## [39] 78 80 82 84 86 88 90 92 94 96 98 100 U sljedeoj lekciji konano emo upoznati ve vie puta spominjane podatkovne okvire kao daleko najpopularniji i najee koritenu podatkovnu strukturu jezika R. Zadaci za vjebu Stvorite sljedee vektore: (11, 12, 13,, 99) (0, 0, 0, 0,  , 0) (100 nula) (0, 0.1, 0.2, ., 1.0) Kolika je suma svih brojeva od 101 do 1001, ako preskoimo sve brojeve djeljive sa 10? Koristite se funkcijom sum. Stvorite matricu 3 x 3 sa brojevima izvoenjem sljedeih naredbi (funkciju sample emo poblie upoznati u jednoj od sljedeih lekcija): # stvaramo matricu 3x3 nasumino odabranih elemenata iz skupa od 1 do 100 set.seed(1234) m &lt;- matrix(c(sample(1:100, 9, T)), nrow = 3, ncol = 3, byrow = T) Izraunajte inverznu matricu uz pomo funkcije solve. Provjerite da li umnoak originalne i inverzne matrice daje jedininu matricu (za mnoenje matrica koristite se operatorom %*%). Inicijalizirajte ponovo listu svastara koritenu u lekciji. Napravite sljedee: ispiite klasu drugog elementa liste ispiite element na treem mjestu elementa liste naziva slova provjerite duljinu elementa naziva imena te na zadnje mjesto dodajte ime \"Pero\" provjerite da li se broj 4 nalazi u prvom elementu liste na zadnje mjesto liste dodajte novu listu sa tri vektora a, b i c koji svi sadre elemente (1,2,3) Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
