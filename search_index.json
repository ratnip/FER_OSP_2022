[["index.html", "Programirajmo u R-u (Udbenik za predmet Osnove statistikog programiranja) Predgovor", " Programirajmo u R-u Damir Pintar 2022-11-10 (Udbenik za predmet Osnove statistikog programiranja) ** NAPOMENA: Za vrijeme odvijanja predmeta Osnove statistikog programiranja u tekuoj akademskoj godini provodi se revizija poglavlja udbenika. Nakon to se materija odradi na predavanjima te zavri ciklus predaje radnih biljenica nova poglavlja e se dinamiki dodavati u ovaj HTML dokument. Ukoliko vam je nuno potreban pristup cjelokupnim materijalima kontaktirajte autora udbenika na damir.pintar@fer.hr ** Predgovor Ovaj udbenik nastao je iz interaktivnih lekcija koritenih na predmetu Osnove statistikog programiranja na Fakultetu elektrotehnike i raunarstva Sveuilita u Zagrebu. No teme koje se ovdje obrauju nisu korisne samo studentima navedenog fakulteta - poznavanje jezika R dobro e doi kako u akademskom, tako i u poslovnom svijetu. Iako je R poznat kao programski jezik napravljen od statistiara, za statistiare te se najee povezuje sa poljem podatkovne znanosti unutar kojeg se koristi za sloene statistike i dubinske analize, on se moe pokazati vrlo koristan i za poslove vezane uz upravljanje manjim ili veim podatkovnim skupovima koji nisu nuno strogo orijentirani naprednoj analitici. Naime, popularni grafiki alati sa svojim interaktivnim tablinim prikazom vrlo su intuitivni i odlini za jednostavnije poslove, no kako se pojavljuju potrebe za sloenijim zadacima oni vrlo brzo gube na uinkovitosti i jednostavnosti; s druge strane, interaktivni programski pristup kojeg nudi R inicijalno je neto zahtjevniji, no dugorono vrlo isplativ jer se i vrlo sloeni zadaci mogu rjeavati na uinkovit, konzistentan i pregledan nain. Upravo iz tog razloga u poslovnom svijetu pojavljuje se jasna tendencija odmaka od klasinih grafikih alata prema platformama sa boljom podrkom za provoenje sloenijih izrauna i stvaranje atraktivnih vizualizacija. Ovo se oituje snanim porastom popularnosti jezika R i drugih platformi sa slinim pristupom analizi podataka. Navedena popularnost jezika R rezultira i poveanom potrebom za resursima za uenje, kojih na hrvatskom jeziku trenutno nema ba previe. Ovaj udbenik svojim pristupom uenja kroz primjere pokuati e uenje R-a uiniti to lakim i zanimljivijim. Naglasak e biti stavljen prvenstveno na svladavanje R-a kao programskog jezika. Upravo zbog toga poetna poglavlja baviti e se poglavito programerskim aspektima, a potom e biti dan pregled dostupnih alata za zadatke za koje pretpostavlja da su korisni najirem skupu itatelja - upravljanje podatkovnim skupovima, izvlaenje korisnih informacija i stvaranje vizualizacija. Budui da je R ipak domenski orijentirani jezik, pria o R-u zaokruiti e se kratkim uvidom u njegovu podrku za statistike analize te pregledom odabranih metoda strojnog uenja i njihove primjene. Iako e biti dano dovoljno informacija da se sve prikazane metode stave u kontekst, ideja ovog udbenika nije nauiti itatelja statistiku niti duboko ui u polje strojnog uenja - namjera autora jest zaintrigirati itatelja da nastavi istraivanje ovog interesantnog podruja, adekvatno naoruanog znanjem platforme koje e omoguiti da sva novousvojena znanja odmah praktino primjeni u svojim daljnjim istraivanjima. "],["uvod.html", "1 Uvod 1.1 to je programski jezik R? 1.2 Instalacija programske podrke 1.3 Pregled razvojnog suelja RStudio 1.4 Kako koristiti ovaj udbenik?", " 1 Uvod 1.1 to je programski jezik R? 1.1.1 Openito o R-u Programski jezik R proizaao je iz programskog jezika S, razvijenog za potrebe Bell Telephone Laboratorija u vlasnitvu AT &amp; T korporacije. Zamiljen je kao interni alat za statistiku analizu. Osnovna filozofija jezika S (koju je naslijedio i programski jezik R) bila je domenska orijentiranost - tj. olakavanje posla podatkovnim analitiarima bez potrebe za prilagoavanjem konvencijama tradicionalnih programskih jezika. Jezik S je kroz 80.-te i 90.-te dosegnuo znaajnu popularnost u krugovima poslovnih analitiara i statistiara, no dostupan samo kroz komercijalnu varijantu nazvanoj S-PLUS. Programski jezik R nastao je na sveuilitu u Aucklandu (NZ) po uzoru na S, a 2000. objavljuje se pod GNU licencom otvorenog koda. Standardna distribucija R programskog jezika sastoji se od: jezgre R-a, sa temeljnim funkcijama i tzv. base paketom koji omoguuje osnovnu funkcionalnost kolekcijom dodatnih paketa (osnovni - base i preporueni - recommended) za upravljanje podacima, vizualizacije i statistike analize Ovdje ne treba zanemariti izvrsnu integraciju R-a sa bogatim repozitorijem paketa zvanom CRAN (Coprehensive R Archive Network) koja omoguuje brzu i jednostavnu instalaciju bilo kojeg paketa iz navedenog repozitorija nakon ega on postaje dio lokalne R instalacije. Budui da je za jezik R specifian iznimno jaki utjecaj R zajednice na razvoj novih paketa, esto se nakon pojavljivanja novih eksperimentalnih metoda i pristupa podatkovne analize vrlo brzo na CRAN-u mogu pronai paketi koji iste implementiraju, a takoer treba spomenuti i snani i kontinuirani entuzijazam R zajednice za razvoj poboljanja postojeih elemenata R-a koji ublaavaju ili uklanjaju veliki broj uoenih manjkavosti jezika. R se zbog toga esto zna usporeivati sa uradi sam projektom gdje korisnik, nakon upoznavanja sa isporuenim tvornikim komponentama (u ovom sluaju temeljnim funkcijama i paketima), poinje prilagoavati svoju razvojnu okolinu odabirom paketa koji tono odgovaraju njegovim potrebama i preferencama. Kreativnost i fleksibilnost u koritenju R-a se smatra njegovom velikom prednou, iako rezultira odreenom neformalnou i liberalnim pristupom programiranju koji nije omiljen korisnicima naviknutim na stroge i formalne programske okvire sa jasnim skupom smjernica i pravila koja se moraju slijediti. Usprkos iznimno velikoj prihvaenosti jezika R za podatkovne analize te mnotvu opcija koje nudi korisniku, potrebno je odmah u poetku biti svjestan i njegovih odreenih ogranienja: R jako intenzivno koristi radnu memoriju to je dugo vremena smatrano ozbiljnim ogranienjem; porastom kapaciteta modernih hardverskih sustava ovo ogranienje je danas puno prihvatljivije, a takoer su se pojavili brojni paketi koji racionaliziraju koritenje memorije. Ipak ostaje injenica da R brzo pojede RAM naeg raunala, iako je to esto i rezultat nepanje ili neznanja programera koji nije dovoljno dobro usvojio R-ovski nain programiranja. R je prilino nekonvencionalan tako da je krivulja uenja inicijalno neto strmija, pogotovo za programere naviknute na standardne konvencije drugih programskih jezika. S druge strane, ako se gleda dugorono, programiranje u R-u je prilino jednostavno budui da je veina kompleksnih zadataka apstrahirana u visokorazinske funkcije koje transparentno obavljaju operativne poslove niske razine. esto se kae da je R vie orijentiran cilju kojeg elimo postii a manje detaljima oko puta kojim do njega stiemo. R nije brzi jezik; iako se radi o jeziku koji oekivano radi nad velikim skupovima podataka, R nije optimiziran za brzinu izvoenja, pa ak ni za viedretvenost; iako je veliki trud uloen da se gotovo sve kljune rutine implementiraju u C-u i da se sprijee znatna usporavanja, a postoji i niz paketa koji omoguuju viedretveno izvoenje R programa, i dalje stoji injenica da R nije dizajniran s ciljem da se izvrava to je bre mogue; ukoliko je brzina prioritet, esto je potrebno traiti alternativna rjeenja - zbog ega se esto zna rei da je R primarno istraivaki jezik, ne produkcijski. R je prvenstveno namijenjen za interaktivni rad, tj. izvoenje niza strojnih instrukcija koje se dinamiki upisuju i izvode uz pomo programske konzole. Ovo je prilagoeno standardnom procesu analize podataka gdje analitiar moe uitavati podatke, istiti ih, transformirati, razvijati modele, testirati i sl. uz konstantnu povratnu informaciju od raunala, mogunost pregleda meurezultata, izmjene procesa prema trenutnim saznanjima i sl. Ovo ne znai da se u programskom jeziku ne moe programirati na klasian proceduralni nain, razvojem algoritama enkapsuliranih u funkcije koje onda nakon pozivanja automatski obavljaju svoje zadatke, ali injenica jest da se uinkovitost R-a upravo odraava u interaktivnom radu. Ovaj princip se prenosi i na uenje R-a; programski jezik R puno se lake ui interaktivnim pristupom uz izvravanje konkretnih zadataka, eksperimentiranjem s podatkovnim skupovima, dostupnim metodama i sl. nego klasinim pristupom izrade programskih skripti koje implementiraju neke niskorazinske poslove. 1.1.2 Alternative jeziku R Programski jezik R je popularno, ali ne i jedino rjeenje za interaktivnu analizu podataka i statistiko programiranje. U nastavku emo dati kratki pregled nekih popularnijih tehnologija i rjeenja koje se danas koriste u ovu svrhu, uz kratku usporedbu i osvrt na prednosti i nedostatke u usporedbi sa onim to nudi jezik R. SAS i SPSS  SAS (Statistical Analysis System, razvijen od strane SAS Institute) i SPSS (Software Package for Statistical Analysis, razvijen od strane IBM-a) su dva razliita softverska paketa koje stavljamo pod istu stavku prvenstveno zato to se radi o komercijalnim alatima, tj. alatima koji za svoju punu funkcionalnost zahtijevaju plaanje licence. Isto tako, SAS i SPSS se relativno lako ue a svoju funkcionalnost u velikoj mjeri zasnivaju na pomno dizajniranim korisnikim sueljima. Ovi alati naglasak stavljaju na uinkovitost i odlina su opcija za velike tvrtke koje trae konzistentno, robusno rjeenje za svoju analitiku i kojima ne smeta komercijalna priroda takvih rjeenja. Weka i Orange  Weka (Waikato Environment for Knowledge Analysis, razvijen od strane sveuilita Waikato na Novom Zelandu) i Orange (alat za dubinsku analizu podataka razvijen na sveuilitu u Ljubljani) su besplatan softver za eksploratornu analizu podataka i dubinsku analizu koji svoju funkcionalnost zasnivaju na relativno jednostavnim grafikim sueljima i vizualnom pristupu programiranju. Ova rjeenja vrlo su dobra za korisnike koji nisu previe zahtjevni glede fleksibilnosti i kompleksnosti svojih analiza jer na vrlo pristupaan i jasan nain omoguuju provedbu definiranih koraka procesa analize. To ne znai da se u ovim alatima ne mogu raditi i kompleksnije analize, samo da su oni ipak prilagoeniji analizama kroz predefinirane funkcionalnosti pruenog grafikog suelja. Python (Numpy / Pandas / Scikit)  u zadnjih nekoliko godina upravo je Python najozbiljniji konkurent jeziku R, prvenstveno zbog injenice da je Python sam po sebi vrlo popularan programski jezik koji za potrebe analize podataka koristi pakete s vrlo slinim pristupom procesu analize onom kojeg koristi i jezik R. Rasprava o tome koji jezik odabrati je vrlo esta u polju znanosti o podacima, obino bez jasnog konanog zakljuka. Lako s uvjeriti da su razlike zapravo u nijansama - dok je R snano domenski orijentiran i vei naglasak stavlja na lakou i jednostavnost koritenja uz iroku paletu dostupnih paketa sa preklapajuim funkcionalnostima kako bi korisnik mogao odabrati onaj koji mu najvie odgovara, Python naglaava rigidnu formalnu strukturu i princip za jedan posao jedan nain obavljanja. Stoga bi se moglo rei da je R neto pogodniji za istraivanje podataka dok je prednost Pythona laki razvoj i integracija analitikih modula u nekom produkcijskom okruenju, pogotovo ako je navedeno okruenje ve izvedeno u Pythonu. No snanim razvojem oba jezika i meusobnim praenjem funkcionalnosti i ova navedena razlika postaje sve manje relevantna - danas vie nije problem integrirati R skripte u postojee sustave neovisno o platformi na kojoj su izvedeni, a u Python zajednica razvija svoje inaice popularnih paketa iz R-a koje vjerno preslikavaju njihovu funkcionalnost. U konanici se moe rei da inicijalni odabir izmeu ove dvije alternative i nije toliko bitan - pristup kojeg koriste je toliko slian a praenje funkcionalnosti toliko izraeno da se uenjem jednog jezika svladava veina bitnih koncepata iz drugog tako da se podatkovni znanstvenici esto na kraju odluuju na svladavanje oba jezika, kako bi se lako prilagodili velikom broju okruenja u kojima moraju provoditi svoje analize. 1.2 Instalacija programske podrke Instalacija programske podrke za jezik R je prilino jednostavna, pogotovo ako se kao platforma koristi preporueno razvojno suelje RStudio. Ovo nije jedina opcija - jedna od popularnih alternativa jest i viejezina platforma Jupyter Notebook koja nudi vlastitu podrku za R. itateljima se dugorono preporuuje istraivanje svih dostupnih opcija i konani odabir onog suelja koje osobno procijene najboljim za svoje potrebe, no ovaj udbenik e se usredotoiti na RStudio ponajvie zbog jasnog, preglednog suelja, lake instalacije i vrlo bogate podrke za razliite funkcionalnosti - od instalacije novih paketa, lakog dohvaanja dokumentacije, prikaza vizualizacija do stvaranja i objave izvjetaja. Radne biljenice o kojima e vie rijei biti u nastavku uglavnom pretpostavljaju da ste odabrali suelje RStudio. Za uspjeno postavljanje razvojne platforme potrebno je instalirati dvije stvari distribuciju jezika R razvojno suelje RStudio Preporuuje se koristiti najnovije dostupne inaice. U trenutku pisanja ovog dokumenta to su R 4.2.2 i RStudio 2022.07.2. Ukoliko se ove inaice razlikuju od one koje se nalaze na vaem raunalu, vjerojatno nee biti problema ukoliko su brojevi inaica vii od navedenih; u suprotnom preporuuje se njihova nadogradnja. U nastavku e se opisati postupak za instalaciju navedenog softvera na operacijski sustav Microsoft Windows. Ukoliko radite na nekom od drugih operacijskih sustava, kao to je neka od Linux distribucija ili Mac OS procedura je neto drugaija, no i dalje ne previe sloena - dovoljno je pratiti upute na web stranicama spomenutim u nastavku koje su orijentirane platformi koju koristite. Kako bi pronali spomenuti softver u trailicu upiite sljedee pojmove: download R download RStudio U oba sluaja dobiti ete stranice sa poveznicama na izvrne datoteke koje morate pokrenuti kako bi se softver instalirao na vae raunalo. U sluaju jezika R to moe biti datoteka R-4.2.2-win.exe (toni brojevi se mogu razlikovati). Kod suelja RStudio moete vidjeti vie opcija - odaberite besplatnu desktop inaicu. Komercijalne inaice imaju neke dodatne funkcionalnosti koje su veinom orijentirane uporabi u profesionalnim, viekorisnikim okruenjima te nisu bitne za uobiajeni rad. Izvrne datoteke moete pokrenuti i pustiti arobnjaka da instalira sve potrebne komponente na vae raunalo. Preporuuje se prihvatiti sve nazivne opcije osim mape instalacije - umjesto podmape Program Files bolje je instalirati R direktno u osnovnu mapu (npr. C:\\R\\R-4.2.2). Na ovaj nain biti e lake pronai trenutno instaliranu inaicu i eventualno kasnije aurirati. Iz istih razloga preporuuje se RStudio instalirati u mapu C:\\R\\RStudio. U sluaju da niste mogunosti ili ne elite odabrati ove mape, moete definirati neke druge ili zadrati nazivne opcije - ovaj izbor ne bi u konanici trebao bitno utjecati na daljnji rad. Nakon instalacije suelja RStudio dovoljno je isto jednostavno pokrenuti uz pomo stvorene kratice na radnoj mapi (ili alternativno, uz pomo izvrne datoteke RStudio.exe u odabranoj mapi za instalaciju). Nakon pokretanja aplikacija bi trebala izgledati slino sljedeoj slici: Slika 1.1: Izgled suelja RStudio Ukoliko je dolo do nekih problema, provjerite da li ste ispravno proveli sve navedene korake instalacije. U nastavku emo se pozabaviti detaljima prikazanog suelja. 1.3 Pregled razvojnog suelja RStudio Pogledajmo suelje RStudio. Vidimo da je podijeljeno na tri prozora - lijevi dio je radni i u njega upisujemo programski kod. S desne strane se nalaze pomoni prozori koji prikazuju razliite stvari, ovisno o odabranoj kartici; u gornjem desnom dijelu izmeu ostalog moemo vidjeti to se trenutno nalazi u naoj radnoj okolini (koja je na poetku prazna) te povijest naredbi koje smo izvravali. Donji dio slui za prikaz dokumentacije, datoteka u radnoj mapi, instaliranih paketa, vizualizacija i sl. 1.3.1 Interaktivna konzola Vratimo se na lijevi dio suelja. Ovdje se zapravo radi o tzv. interaktivnoj konzoli. Naime, po svojoj prirodi R je tzv. interpreterski jezik u smislu da se naredbe odmah interpretiraju i izvravaju. Iako je mogue izraivati i vee skripte koje se onda izvravaju u komadu, rad sa jezikom R vrlo esto se svodi na princip naredba - odgovor. Upravo zbog toga govorimo o interaktivnoj programskoj analizi podataka - analitiar programira upisivanjem naredbi te u svakom trenutku moe prouiti dobivene meurezultate i odluiti se na daljnje korake. Prikaimo kako radi interaktivna konzola. Uz pomo tipkovnice moemo utipkati jednostavan matematiki izraz - npr. 3 + 2 i stisnuti tipku ENTER. Vidimo da e nam R odmah pruiti rezultat - moemo ga koristiti i kao kalkulator! Za matematike izraze koje nije jednostavno utipkati moramo koristiti funkcije. Tako npr. drugi korijen moemo izraunati uz pomo funkcije sqrt(). Pokuajmo u konzolu utipkati sqrt(10) i stisnuti ENTER. R nam opet odmah prikazuje rezultat. U ovom trenutku zaslon bi nam trebao izgledati otprilike kao na sljedeoj slici. Slika 1.2: R kao kalkulator Jedan od problema ovakvog naina koritenja R-a jest taj to nam se mijeaju naredbe i rezultati, a povijest niza naredbi postaje sve tee vidljiva kako se koritenjem konzole sputamo sve nie i nie. Isto tako, ako iz nekog razloga naredba koju izvravamo rezultira grekom koju pokuavamo ispraviti, konzola vrlo brzo postaje prljava budui da se mijeaju korektni pozivi sa izvjetajima o grekama ime bilo kakva sloenija procedura koju elimo provesti postaje rastrgana i nepregledna. Zbog toga analitiari vrlo esto koriste tzv. R skripte koje omoguuju da vizualno izdvojimo naredbe koje elimo izvriti od same konzole, ali i dalje uz mogunost da ih lako upiemo u konzolu, slijedno izvrimo i pogledamo rezultat. 1.3.2 Pisanje R skripti Na alatnoj traci odaberimo File -&gt; New File -&gt; R Script (ili stisnemo kombinaciju tipaka CTRL + SHIFT + N). Vidimo da se radni dio na lijevoj strani razdvojio na dva dijela. Gornji dio predstavlja prostor za nau skriptu - zapravo niz naredbi koje elimo izvriti - dok interaktivna konzola sada zauzima donji dio radne plohe. Ukoliko elimo, moemo pomicanjem granice promijeniti veliinu ovih (a i ostalih prozora), no za sada je bitno da imamo pregled i skripte i konzole. Upiimo dvije naredbe u prozor za pisanje skripte - prva neka bude print(\"Pozdrav!\") a ispod nje opet jednostavan matematiki izraz 3 + 4. Vratimo kursor na prvi redak i stisnimo kombinaciju tipki CTRL + ENTER. Ukoliko smo ispravno pratili navedene korake, naredba na mjestu koje se nalazio kursor automatski e se preslikati u interaktivnu konzolu i izvriti. Kursor e sada biti na mjestu sljedee naredbe koju takoer moemo izvriti sa CTRL + ENTER. Zaslon bi sada trebao izgledati slino sljedeoj slici. Slika 1.3: R skripta Ovo je zapravo uobiajeni nain rada u jeziku R - u prostor za skripte upisujemo naredbe koje potom izvravamo njihovim automatskim preslikavanjem u konzolu. Ako neto ne tima s naredbom, lako ju preinaimo i ponovo izvrimo. Ukoliko elimo izvesti blok naredbi, odaberemo ih povlaenjem mia i izvrimo kombinacijom tipaka CTRL + ENTER. Skripte moemo proiriti komentarima (koji poinju znakom # kojeg R interpretira kao ovaj redak ignoriraj), a na kraju rada spremiti pod odabranim imenom na vrsti disk. No moemo otii i korak dalje. Iako su R skripte sasvim adekvatne za ugodan rad u jeziku R, postoji dodatna tehnologija koja nam omoguuje jo veu fleksibilnost u radu sa programskim jezikom R - R Markdown. 1.3.3 R Markdown Pisanje R skripti vrlo je slino klasinom poimanju programiranja - piemo programske naredbe koje se u pravilu izvravaju slijedno te kojima opcionalno dodajemo komentare u svrhu dokumentacije. No budui da je rad u R-u vrlo esto interaktivne prirode te da se kao zavrni korak neke analize podataka obino oekuje oblikovanje izvjetaja koji e na adekvatan nain prikazati dobivene rezultate, suelje RStudio podrava tehnologiju koja omoguuje uinkovitu kombinacije programiranja i strukturiranog dokumentiranja na principu interaktivne biljenice; analitiar moe pisatiisti\" tekst, opcionalno sa formulama, slikama te izmjenama veliine i prirode tekstualnog fonta, da bi potom u takav tekst ugradio izvrivi programski kod zajedno sa njegovim rezultatima. Tehnologija koja ovo omoguuje je tzv. R Markdown, koji je relativno nedavno proiren novim konceptom nazvanim R Notebook. Rad ove tehnologije najlake je prikazati preko primjera - u alatnoj traci odaberimo File -&gt; New File -&gt; R Markdown... te u iduem prozoru odaberimo proizvoljni naslov (npr. Proba), opcionalno ime autora te jednu od opcija za konani oblik izvjetaja (preporueno HTML zbog najmanje ovisnosti o dodatnim paketima). Za razliku od R skripte, R e kod novog R Markdown dokumenta stvoriti popunjeni dokument. Ovo je izvedeno na ovaj nain iz jednostavnog razloga da korisnik dobije predloak koji istovremeno slui i kao podsjetnik te kojeg onda lako izmjeni prema svojem nahoenju. Mi emo za nae potrebe obrisati vei dio ovog predloka - sve poslije inicijalnog zaglavlja, tj. ispod druge pojave znakova ---. Potom moemo ispod napisati bilo kakav tekst. Znakovima #, ##, ### itd. moemo postaviti naslov odreene kategorije (to sada nisu komentari, jer ovo zapravo nije R kod!), dok znakovima * i ** ispred i iza odabranih rijei odabiremo nakoeni ili masni otisak u konanom izvjetaju. Ovo je tzv. isti markdown, tj. obian tekst koji se uz pomo dodatnih alata moe pretvoriti u oblikovani tekst, ukoliko elimo. Kada elimo u ovaj na izvjetaj ugraditi programski kod, moramo stvoriti tzv. isjeak (engl. chunk). To moemo uiniti odabirom Insert -&gt; R na alatnoj traci ili kombinacijom tipaka CTRL + ALT + I. Uoite da isjeak poinje i zavrava posebno odabranim nizom znakova - tri apostrofa nalijevo (engl. backticks). Isto tako, poetak isjeka u vitiastim zagradama opisuje parametre isjeka, od ega je najvaniji programski jezik kojeg emo koristiti. U ovom udbeniku emo gotovo iskljuivo koristiti jezik R, iako je mogue koristiti i druge jezike ukoliko su oni instalirani na platformi na kojoj je pokrenut RStudio. Isjeak koda ponaa se isto kao i standardna R skripta - moemo upisivati naredbe i izvravati ih. Razlika je samo u tome to - ukoliko elimo - rezultate moemo vidjeti i odmah u samom R Markdown dokumentu. Ako nam ova opcija smeta moemo ju iskljuiti (klik na zupanik u alatnoj traci i odabir Chunk output in console) no u pravilu nam odgovara da se rezultat ugradi u dokument kako bi naknadno mogli ponovo pregledavati rezultate prethodnih isjeaka. Ako smo pratili upute, zaslon bi mogao izgledati slino sljedeoj slici: Slika 1.4: R Markdown dokument Ukoliko elimo, moemo pokuati stvoriti izvjetaj od trenutnog dokumenta. Prvo ga moramo spremiti pod odreenim imenom (npr. Proba.rmd), a potom moemo kliknuti na gumb Knit koji e dokument iz istog teksta pretvoriti u HTML datoteku. R Markdown dokumenti su puno moniji nego to se moda daje naslutiti do sada prikazanim elementima. Isjecima moemo dodavati niz parametara kako bismo utjecali na njihovo ponaanje. Izlazni oblik moe biti PDF, DOCX ali i drugi oblici kao to slajdovi raznih tehnologija, knjige namijenjene mobilnim ureajima, interaktivna Web aplikacija i sl. Udbenik kojeg itate zapravo nije nita drugo do niz RMD datoteka pretvoren u adekvatni oblik kojeg trenutno koristite. Kao to emo objasniti u sljedeem poglavlju, RMD datoteke su takoer i glavni nain na kojeg ete moi na interaktivan nain pratiti ovaj udbenik i isprobavati primjere i zadatke koje slijede. Univerzalnost i fleksibilnost tehnologije R Markdown je iznimno velika, emu u prilog govori i njezina velika popularnost u R zajednici. 1.4 Kako koristiti ovaj udbenik? Osnovna ideja ovog udbenika jest uenje kroz primjenu. Zbog toga se u lekcijama u nastavku nee koristiti previe primjera, ve se itatelja potie da svaki novi koncept usvoji kroz rjeavanje niza lakih i teih zadataka. Svako poglavlje koje slijedi ima prateu radnu biljenicu. Jednostavno reeno, radi se o RMD datoteci koja sadri sve primjere iz zadatke iz ovog udbenika, popraene saetim tekstom radi lakeg snalaenja i referenciranja na koncepte koji se obrauju. Osnovna ideja je da itatelj paralelno ita udbenik i rjeava radnu biljenicu, gledajui rjeenje zadatka tek nakon to ga samostalno rijei unutar programskog alata. Poneki zadaci zahtijevati e jednostavno uklanjanje znaka # (koji oznaava komentar) sa poetka naredbe te njezino izvravanje. Usprkos trivijalnom pristupu, na ovaj nain se ipak jasnije potie itatelja za samostalno isprobavanje naredbe, umjesto da samo pogleda njezin rezultat. Drugi zadaci zahtijevati e neto vei angaman. Konano, nakon svake lekcije nalazi se niz Zadataka za vjebu uz koje se nee nalaziti rjeenje te koji e predstavljati svojevrsnu provjeru svih danih koncepata lekcije. itateljima se snano preporuuje rjeavanje svih primjera i zadataka prije prelaska na iduu lekciju, budui da lekcije koje slijede pretpostavljaju dobro usvojeno znanje svih do tada obraenih tema. Naravno, udbenik je mogue itati i bez navedenog interaktivnog pristupa. Rjeenja uz zadatke otkrivaju ispravnu metodu pristupa problemu, a veina naredbi popraena je ispisom kojeg bi korisnik dobio na zaslonu njihovim izvravanjem. Usprkos tome, stav autora udbenika jest da se programski jezici ne mogu uiti itanjem te da se dodatni trud isprobavanja svih, pa ak i najjednostavnijih koncepata, u konanici viestruko isplati. Upoznajmo se poblie sa konceptom radnih biljenica. Prvo je potrebno pronai i otvoriti radnu biljenicu koja odgovara lekciji koju itate. Nju je lako prepoznati prema odgovarajuem broju lekcije - radna biljenica za ovu lekciju nosi naziv 01_Uvod_RB.Rmd. Preporuuje se da sve radne biljenice na kojima namjeravati raditi kopirate negdje na lokalno raunalo zajedno sa svim prateim datotekama koje se nalaze u istoj mapi ako ih ima. Kao to je reeno, radna biljenica e u pravilu sadravati sav programski kod lekcije na koje se odnosi, ali samo dio teksta koliko je dovoljno za lake snalaenje. Ukoliko ovaj tekst itate direktno iz radne biljenice, a ne kao dio udbenika, moete vidjeti da nedostaje cijeli prethodni dio lekcije; to je zato to se uvodni koraci opisani u njemu tiu koncepata koje je potrebno usvojiti prije koritenja radne biljenice. Ako ih niste proli, preporuka je da se vratite i proete ih te potom nastavite sa primjerima i zadacima koji slijede. Radne biljenice razlikuju Primjere i Zadatke. Primjere je u pravilu potrebno samo izvriti. Zadaci s druge strane oekuju izvjesne preinake ili unos novog programskog koda. Kao to je reeno, udbenik e postaviti daleko vei naglasak na zadatke. Primjer moe izgledati ovako: Primjer - nekoliko jednostavnih naredbi R programskog jezika 3+2 #zbrajanje log(10) # prirodni logaritam! log10(10) # ovo je logaritam baze 10! Usput, komentare piemo znakom &quot;#&quot; sin(0.5 * pi) # pi je jedna od ugraenih konstanti ## [1] 5 ## [1] 2.302585 ## [1] 1 ## [1] 1 Naredbe iz primjera moete izvriti pojedinano, ili cijeli isjeak odjednom kombinacijom tipaka CTRL + SHIFT + ENTER. Nikakve preinake koda nisu nune (iako esto nije loe eksperimentirati sa danim naredbama!). Zadaci s druge strane uvijek trae odreenu - makar minimalnu - intervenciju. Zadatak 1.1 - naredbe za provjeru i izmjenu radne mape # izvrite sljedee naredbe uklanjanjem znaka komentara #getwd() # mapa u kojoj trenutno radimo #setwd(&quot;.&quot;) # ovdje moemo navesti novu radnu mapu ukoliko elimo getwd() # mapa u kojoj trenutno radimo setwd(&quot;.&quot;) # ovdje moemo navesti novu radnu mapu ukoliko elimo Zadatak e se esto odnositi na upravo uvedeni koncept. Npr. zgodno je za napomenuti da, iako jezik R podrava operator = za pridruivanje vrijednosti nekoj varijabli, preporuuje se koritenje operatora &lt;- u tu svrhu koji je neto vie R-ovski. Takoer, uoimo da R podrava tzv. autoprint, tj. uvijek e ispisati rezultat zadnje naredbe na zaslon. To znai da ako u isjeku stvaramo novu varijablu x te ju elimo ispisati na zaslon, ne moramo kao zadnju naredbu staviti print(x) ve je dovoljno staviti samo x. Isprobajmo ovo u zadatku. Zadatak 1.2 - R-ovski operator pridruivanja # upiite `5` u varijablu `x` # potom ispiite varijablu `x` na zaslon x &lt;- 5 x ## [1] 5 Sada kada smo se dobro upoznali sa radnom platformom, moemo poeti sa uenjem osnovnih elemenata programskog jezika R. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["tipovi.html", "2 Osnovni tipovi podataka i operatori 2.1 Osnovni tipovi podataka 2.2 Operatori 2.3 Nedostajue, nepoznate i nemogue vrijednosti Zadaci za vjebu", " 2 Osnovni tipovi podataka i operatori Osnovni ili primitivni tipovi podataka su temeljni izgradbeni blokovi programskih jezika. Ovdje se najee misli na ugraene mehanizme koji omoguuju pohrane elementarne informacije - najee logikog, numerikog ili znakovnog tipa. Veina programskih jezika koristi iste ili vrlo sline naine pohrane takvih informacija, to znai da implementira sline osnovne tipove podataka - razlika je esto u detaljima kao to su sam naziv tipa, nazivni broj bajtova za odreeni tip podatka i sl. U svakom sluaju najei prvi korak kod uenja novog programskog jezika jest upoznavanje osnovnih tipova podataka koje isti podrava. Sljedea stvar koja nas potom moe zanimati jest sintaksa jezika, tj. nain na kojeg piemo naredbe koje interpreter jezika moe razumjeti i izvriti. Jezik R u svojoj sintaksi slijedi sline konvencije viene u jezicima kao to su Python, Ruby ili Java, naravno uz izvjesne specifinosti to je uobiajeno za svaki novi programski jezik. Neka sintaksna pravila koje je korisno znati su sljea: svaka naredba (u pravilu) mora ii u svoj redak uvlaenje naredbi unutar blokova je preporueno ali nije obvezno, kao ni stavljanje toke-zareza na kraj naredbe blokove definiramo vitiastim zagradama, slino jezicima Java ili C tipove varijabli ne definiramo unaprijed, oni se prilagoavaju pridruenoj vrijednosti komentari zapoinju znakom # Umjesto navoenja niza pravila sintaksu emo najbolje nauiti kroz primjere - uz upoznavanje sa jednostavnim funkcijama i operatorima, to emo i uiniti u ovoj lekciji. Nakon pregleda osnovnih tipova i operatora zavretak lekcije emo posvetiti rapsravi o tzv. nedostajuim ili nepostojeim vrijednostima, koje imaju posebno vanu ulogu kod uobiajenog koritenja programskog jezika R. 2.1 Osnovni tipovi podataka R poznaje est osnovnih tipova podataka: tip izvorni naziv tipa primjeri logiki logical TRUE, FALSE ili T, F cjelobrojni integer 2L, 5L, 123456789L realni double 4, 6, 3.14, 2e5 kompleksni complex 5 + 2i, 7 + 1i znakovni character \"A\", \"B\", \"Pero\", \"ABCDEFGHijklmnoPQRSTUVwyz\" bajtovi raw as.raw(2), charToRaw(\"1\") Dobro je znati: cjelobrojni i realni tipovi se esto zajedno tretiraju kao tip numeric (iako ovo nije u potpunosti konzistentno!) kompleksni tip mora imati deklariranu imaginarnu konstantu ak i ako je ona 1 (2 + i nije dobar zapis!) tip sirovih bajtova se relativno rijetko koristi Provjeru da li je neka varijabla odreenog tipa moemo raditi uz pomo funkcije is.&lt;naziv_tipa&gt;, to emo demonstrirati u sljedeem zadatku. Prije samog zadatka potrebno je napomenuti sljedee: kako bi ispis programskih odsjeaka bio to pregledniji potruditi emo se vizualno odvojiti razliite segmente ispisa. U tu svrhu emo koristiti naredbu cat(\"-----------\\n\") koja e na zaslon ispisati niz crtica i potom prijei u novi red. Ovdje moemo koristiti i funkciju print(), no naredba cat je ovdje bolji izbor samo zbog injenice da print uvijek ispis zapoinje indeksom prikazanog elementa, to nam kod ovakvog tipa ispisa nije potrebno. Zadatak 2.1 - provjera tipova podataka #isprobajte sljedee naredbe: #is.logical(FALSE) #is.integer(2L) #is.double(1.11) # izvedite sljedee provjere: # da li je 5L numeriki tip? # da li je 3.14 numeriki tip? # da li je &quot;ABC&quot; znakovni tip? # da li je 4 + 2i kompleksni tip? # da li je 5 cjelobrojni tip? is.logical(FALSE) is.integer(2L) is.double(1.11) cat(&quot;-----------\\n&quot;) is.numeric(5L) is.numeric(3.14) is.character(&quot;ABC&quot;) is.complex(4 + 2i) is.integer(5) ## [1] TRUE ## [1] TRUE ## [1] TRUE ## ----------- ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] FALSE Da li ste uoili neto neobino u ovim provjerama? Pokuajte objasniti dobiveni rezultat. Tip neke varijable ili konstante moemo dohvatiti uz pomo funkcija typeof ili class. Razlika izmeu njih je sljedea: typeof - dohvaa primitivni ili osnovni tip podatka (integer, double ) class - objektni tip, zapravo vrijednost atributa class Zadatak 2.2 - dohvat naziva tipa podatka # ispiite tipove sljedeih konstanti: TRUE, 2L, F, 3.14, &quot;ABC&quot; # ispiite klase istih konstanti. Ima li razlike? typeof(TRUE) typeof(2L) typeof(F) typeof(3.14) typeof(&quot;ABC&quot;) cat(&quot;-----------\\n&quot;) class(TRUE) class(2L) class(F) class(3.14) class(&quot;ABC&quot;) ## [1] &quot;logical&quot; ## [1] &quot;integer&quot; ## [1] &quot;logical&quot; ## [1] &quot;double&quot; ## [1] &quot;character&quot; ## ----------- ## [1] &quot;logical&quot; ## [1] &quot;integer&quot; ## [1] &quot;logical&quot; ## [1] &quot;numeric&quot; ## [1] &quot;character&quot; Podatke moemo eksplicitno pretvarati iz jednog tipa u drugi uz pomo funkcije as.&lt;naziv_tipa&gt;: Zadatak 2.3 - pretvorba tipova podataka # Izvedite sljedee pretvorbe i ispiite rezultat # 2.35 u integer # TRUE u numeric # 100L u character # 2.35 u character # 2e2 u character # 0 u logical # 2.75 u logical as.integer(2.35) as.numeric(TRUE) as.character(100L) as.character(2.35) as.character(2e2) as.logical(0) as.logical(2.75) ## [1] 2 ## [1] 1 ## [1] &quot;100&quot; ## [1] &quot;2.35&quot; ## [1] &quot;200&quot; ## [1] FALSE ## [1] TRUE R e sam provoditi implicitnu pretvorbu ukoliko je mogua: Zadatak 2.4 - implicitna pretvorba # napiite izraze koji odgovaraju sljedeem i ispiite rezultat: # aritmetiki operator izmeu logike i numerike varijable # aritmetiki operator izmeu cjijelog i realnog broja # logiki operator negacije primjenjen na numeriku varijablu # aritmetiki operator izmeu logike i numerike varijable TRUE + 5 # aritmetiki operator izmeu cjelobrojne i numerike varijable 5L + 3.14 # logiki operator negacije primjenjen na numeriku varijablu !25 ## [1] 6 ## [1] 8.14 ## [1] FALSE Implicitna pretvorba e se izvesti samo ako je smislen - npr. aritmetiki operator izmeu znakovne i numerike varijable rezultirati e grekom. 2.2 Operatori Kao i u drugim programskim jezicima, R dozvoljava koritenje operatora u izrazima. Neki od ee koritenih operatora su: aritmetiki +, -, *, /, ** ili ^ (potencija), %% (modulo), %/% (cjelobrojno dijeljenje) usporedni &lt;, &lt;=, &gt;, &gt;=, ==, != logiki ! (negacija), &amp;&amp; (skalarni i), || (skalarni ili), &amp; (vektorski i), | (vektorski ili) pridruivanje &lt;- ili = Zadatak 2.5 - operatori # isprobajte izraze `5 / 2` i `5 %/% 2` # provjerite koliko iznosi &quot;17 na kvadrat&quot; i &quot;ostatak dijeljenja 101 sa 12&quot; # provjerite to je rezultat sljedeih izraza: `17 &gt; 13`, `!TRUE`, `5 &amp;&amp; 0`, `0. || 2` # isprobajte izraze `5 / 2` i `5 %/% 2` 5 / 2 5 %/% 2 cat(&quot;-----------\\n&quot;) # provjerite koliko iznosi &quot;17 na kvadrat&quot; i &quot;ostatak dijeljenja 101 sa 12&quot; 17 ^ 2 101 %% 12 cat(&quot;-----------\\n&quot;) # provjerite to je rezultat sljedeih izraza: `17 &gt; 13`, `!TRUE`, `5 &amp;&amp; 0`, `0. || 2`, 17 &gt; 13 !TRUE 5 &amp;&amp; 0 0. || 2 ## [1] 2.5 ## [1] 2 ## ----------- ## [1] 289 ## [1] 5 ## ----------- ## [1] TRUE ## [1] FALSE ## [1] FALSE ## [1] TRUE Logike vrijednosti i usporedne operatore najee emo koristiti kod tzv. uvjetnog izvoenja naredbi, poznatog iz drugih programskih jezika kao IF ELSE naredba. U R-u njezina sintaksa izgleda ovako: if (izraz) {blok} else {blok} Isprobajmo ovu naredbu na sljedeem zadatku: Zadatak 2.6 - uvjetno izvoenje naredbi # napiite naredbu koja izvodi sljedee: # &quot;ako je 100 paran broj ispii &#39;Uspjeh!&#39;&quot; if (100 %% 2 == 0) print(&quot;Uspjeh!&quot;) ## [1] &quot;Uspjeh!&quot; Uoili smo gore da imamo dvije vrste logikih operatora za i i ili. Razliku emo objasniti kasnije, za sada je dovoljno rei da se kod uvjetnog izvoenja naredbi ili programskih petlji gotovo iskljuivo koristimo operatorima &amp;&amp; i || (C++ - ovski operatori!). Isto tako, ve smo spomenuli da R nudi dva operatora pridruivanja, &lt;- i =. Izmeu njih postoje neke sitne razlike, no one nemaju gotovo nikakav utjecaj na uobiajeno koritenje ovog operatora u praksi. U literaturi se za pridruivanje vrijednosti novim varijablama moe vidjeti i jedna i druga inaica, no mi emo u nastavku primarno i konzistentno koristiti &lt;-, ponajvie zato kako bi programski kod bio vizualno distinktivniji od drugih programskih jezika. NAPOMENA: za jednostavniji upis operatora &lt;- moemo se koristiti kombinacijom tipaka ALT i - Kod pridruivanja pazimo da je s lijeve strane tzv. lijeva vrijednost (engl. lvalue). Ovo u programerskom smislu interpretiramo kao neto u to se moe pohraniti izraunata vrijednost. x + 1 &lt;- 2 # greka!!!] U pravilu se u R-u kao lvalue koristi varijabla, iako se tu ponekad moe pojaviti i poziv funkcije. Ovu moda inicijalno zbunjujuu pojavu razjasniti emo kasnije. Imenovanje varijabli uglavnom slijedi pravila iz drugih programskih jezika - dozvoljena su slova, brojke, podcrta ali i toka . Prvi simbol mora biti slovo ili toka. .mojaVarijabla &lt;- 5 #OK moja.Varijabla &lt;- 5 #OK _mojaVarijabla &lt;- 5 # nije OK 123Varijabla &lt;- 5 # nije OK U praksi za varijable sloenih imena trebamo odabrati jednu od sljedeih konvencija: mojaVarijabla &lt;- 1 # tzv. camelcase moja_varijabla &lt;- 2 # podcrta ili moja.varijabla &lt;- 3 # toka Bitno je da u programskom kodu ne mijeamo konvencije tj. da nakon odabira budemo konzistentni. Ukoliko ba inzistiramo na udnim imenima koja koriste specijalne znakove, onda ih moramo staviti pod tzv. lijeve jednostruke apostrofe (engl. backticks): Zadatak 2.7 - ime varijable sa specijalnim znakovima # upiite proizvoljno ime sa specijalnim znakovima unutar lijevih apostrofa # i ispiite vrijednost varijable #`` &lt;- 2 `!%^$*@__=` &lt;- 2 `!%^$*@__=` ## [1] 2 Ovakav nain imenovanja varijabli nije previe koristan u praksi, ali ima i svoju svrhu - budui da su operatori u R-u zapravo funkcije (ija su imena doslovno +, ^ i sl.) upotrebom lijevih apostrofa moemo ih direktno referencirati u njihovom originalnom obliku, to se moe pokazati vrlo praktinim kod tzv. funkcijskog programiranja (o emu emo govoriti u jednoj od buduih lekcija). Pridjeljivanje vrijednosti novim nazivima varijabli mi zapravo stvaramo nove varijable u radnoj okolini (koja se u R-u naziva globalna okolina). Sve varijable koje smo do sada stvorili moemo vidjeti uz pomo funkcije ls(). Ukoliko elimo obrisati neke varijable, samo navedemo njihova imena u pozivu funkcije rm() (npr. rm(x, y, z)). Za brisanje svih varijabli iz radne okoline koristimo poziv rm(list=ls()), s time to tu moramo biti oprezni (nema undo!). Zadatak 2.8 - ispis i brisanje varijabli globalne okoline # ispiite sve do sada stvorene varijable globalne okoline # obriite neke od gore ispisanih varijabli - npr. rm(x, y, z) # ponovo ispiite dostupne varijable # obriite SVE varijable globalne okoline # (oprezno s ovim pozivom u praksi!) # uvjerite se da je globalna okolina prazna # ispiite sve do sada stvorene varijable globalne okoline ls() # obriite neke od upravo ispisanih varijabli - npr. rm(x, y, z) # ponovo ispiite dostupne varijable rm(x, y) ls() # obriite SVE varijable globalne okoline # (oprezno s ovim pozivom u praksi!) # uvjerite se da je globalna okolina prazna rm(list=ls()) ls() Konano, kad god nam treba pomo oko neke funkcije, imamo sljedee opcije na raspolaganju: napiemo samo &lt;ime_funkcije&gt; (bez zagrada sa parametrima) i stisnemo - ukoliko je funkcija pisana u R-u (a nije samo proxy prema implementaciji u C-u) na zaslon emo dobiti ispis izvornog koda funkcije napiemo help(&lt;ime_funkcije&gt;) ili ?&lt;ime_funkcije&gt; ime dobijamo stranicu pomoi o funkciji sa popisom parametara, primjerima i sl. napiemo example(&lt;ime_funkcije&gt;) pri emu dobijemo popis primjera koritenja funkcije i dobivenih rezultata Sljedei isjeak koda prikazuje nain koritenja gornjih metoda (zbog tednje prostora ne prikazujemo njihov rezultat). #programski kod funkcije `ls` ls # pomo za funkciju `ls` ?ls # ili help(ls) # primjeri koritenja funkcije `ls` example(ls) 2.3 Nedostajue, nepoznate i nemogue vrijednosti U R-u postoji tri naina modeliranja nepostojeih vrijednosti: NA - (not available) nedostajua ili nepoznata vrijednost odreenog tipa NaN - (not a number) nemogui broj, npr. 0/0 NULL - nepostojea vrijednost, doslovno nita Zadatak 2.9 - rad sa NA, NaN i NULL # Koliko je &quot;5 + nepoznati broj&quot;? # Koliko je &quot;5 + nepostojei broj&quot;? # provjerite klase sljedeih konstanti i izraza: # NA # aritmetika operacija izmeu numeric i NA # NaN # NULL # Koliko je &quot;5 + nepoznati broj&quot;? 5 + NA # Koliko je &quot;5 + nepostojei broj&quot;? 5 + NaN cat(&quot;-----------\\n&quot;) # provjerite klase sljedeih konstanti i izraza i objasnite rezultat: # NA # aritmetika operacija izmeu numeric i NA # NaN # NULL class(NA) # logiki tip je &quot;najslabiji&quot;! class(5 + NA) class(NaN) class(NULL) ## [1] NA ## [1] NaN ## ----------- ## [1] &quot;logical&quot; ## [1] &quot;numeric&quot; ## [1] &quot;numeric&quot; ## [1] &quot;NULL&quot; Provjeru nedostajuih vrijednosti radimo slino provjeri tipova podataka - koristimo funkcije is.na, is.nan i is.null. Moramo voditi rauna da je NaN zapravo podvrsta od NA te da je NULL zapravo potpuno zasebna klasa sa specifinim ponaanjem - pokuaj aritmetikih ili logikih operacija nad NULL vrijednosti nee rezultirati novom nepostojeom vrijednosti ve upozorenjima i praznim rezultatima. Ovo je posebno bitno napomenuti poznavateljima jezika SQL - ono to je NULL u SQL-u je NA u R-u i to je ono to u pravilu koristimo u praksi, dok NULL ima vrlo specifine primjene te ga puno rjee koristimo u programskom kodu. Zadatak 2.10 - provjera vrijednosti NA, NaN i NULL # to je od idueg NA? NA, NaN, NULL, &quot;&quot;, 0 # to je od idueg NaN? NA, NaN, NULL # to je od idueg NULL? NA, NaN, NULL # to je od idueg NA? NA, NaN, NULL, &quot;&quot;, 0 is.na(NA) is.na(NaN) is.na(NULL) is.na(&quot;&quot;) is.na(0) cat(&quot;-----------\\n&quot;) # to je od idueg NaN? NA, NaN, NULL is.nan(NA) is.nan(NaN) is.nan(NULL) cat(&quot;-----------\\n&quot;) # to je od idueg NULL? NA, NaN, NULL is.null(NA) is.null(NaN) is.null(NULL) ## [1] TRUE ## [1] TRUE ## logical(0) ## [1] FALSE ## [1] FALSE ## ----------- ## [1] FALSE ## [1] TRUE ## logical(0) ## ----------- ## [1] FALSE ## [1] FALSE ## [1] TRUE Za kraj posvetimo se malo NA vrijednosti, budui da emo ju vrlo esto susretati u praksi. Pojednostavljeno reeno, ukoliko se pojavljuju NA vrijednosti, moemo oekivati sljedee nuspojave: rezultati aritmetikih izraza rezultiraju sa NA vrijednosti rezultati poziva nekih funkcija rezultiraju sa NA (osim ako ne navedemo kompenzacijske akcije, kao npr. parametar na.rm = T koji zapravo znai ignoriraj NA) rezultati logikih izraza mogu ali ne moraju rezultirati sa NA vrijednosti ovisno o tom da li izraz ovisi o NA ili ne (npr. TRUE || NA ima rezultat TRUE, ali FALSE || NA ima rezultat NA) S ovim zadnjim moramo biti posebno oprezni, budui da NA u uvjetnom izrazu rezultira grekom: if (NA &lt; 2) print(&quot;Uspjeh!&quot;) # greka!! U ovoj lekciji upoznali smo se sa osnovnim elementima jezika R. U radu s R-om u pravilu radimo sa sloenim tipovima podataka koje emo upoznati u nastavku - a to su vektori, matrice, podatkovni okviri i liste. Zadaci za vjebu to je rezultat sljedeih naredbi? Razmislite o moguem rezultatu prije izvravanja. as.complex(2) as.integer(-3.25) as.logical(&quot;0&quot;) as.numeric(TRUE) as.character(11.5+2i) as.numeric(&quot;ABC&quot;) Kako u R-u izgledaju sljedei opisni izrazi: tri puta deset na devetu logaritam od 5 cjelobrojno dijeljenje 10 sa 3 ostatak cjelobrojnog dijeljenja 10 sa 3 tangens od 75 stupnjeva | Uz pomo if izraza provjerite da li se rezultat dijeljenja nule s nulom smatra kao vrijednost NA, NaN ili NULL. Ubacite u varijablu x vrijednost 5. Ispiite sve varijable okoline. Potom u varijablu x ubacite NULL. Postoji li i dalje ova varijabla? Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["vektori.html", "3 Vektori, matrice i liste 3.1 Vektori 3.2 Indeksni vektori 3.3 Matrice i polja 3.4 Liste Zadaci za vjebu", " 3 Vektori, matrice i liste 3.1 Vektori Vektor je jedan od sloenih tipova podataka u jeziku R, u smislu da sadrava vie vrijednosti istog tipa. On je kao takav slian pojmu polja u jeziku C. No ovdje postoji jedna bitna razlika, koju je nuno usvojiti budui da se radi o jednoj od najvanijih karakteristika jezika R - u R-u je (gotovo) svaki tip varijable zapravo vektor. ak i varijable i konstante koje smo koristili u prethodnoj lekciji su zapravo bili jednoelementni vektori. Ovo ima dalekosene posljedice o kojima emo detaljno raspravljati u nastavku, a za poetak se prvo upoznajmo sa sintaksom stvaranja i upravljanja vektorima. 3.1.1 Stvaranje vektora Novi vektor (koji ima vie od jednog elementa) stvaramo uz pomo funkcije c (od engl. combine). # numeriki vektor m &lt;- c(1, 2, 3, 4, 5) # logiki vektor v &lt;- c(T, F, T) # znakovni vektor imena &lt;- c(&quot;Ivo&quot;, &quot;Pero&quot;, &quot;Ana&quot;) Dakle, jednostavno reeno, vektor je ureeni skup elemenata istog tipa. Ovo konkretno znai da svi elementi vektora moraju biti istog tipa. Ako stvaramo novi vektor sa elementima razliitih tipova podataka, R e sve elemente automatski pretvoriti u najjai tip, to e na kraju postati i tip samog vektora (termin jai tip u ovom kontekstu oznaavaju mogunost tipa da pohrani svu informaciju pohranjenu u slabiji tip, a u openitom sluaju pretvorba ide u smjeru logiki -&gt; numeriki -&gt; znakovni tip). Zadatak 3.1 - stvaranje vektora # stvorite novi vektor `x` sa etiri proizvoljna elementa sljedeih tipova: # logiki, realni, znakovni i cjelobrojni # ispiite na zaslon sadraj vektora i njegovu klasu # stvorite novi vektor `x` sa etiri proizvoljna elementa sljedeih tipova: # logiki, realni, znakovni i cjelobrojni x &lt;- c(T, 1.25, &quot;Ivo&quot;, 10L) # ispiite na zaslon sadraj vektora i njegovu klasu x class(x) ## [1] &quot;TRUE&quot; &quot;1.25&quot; &quot;Ivo&quot; &quot;10&quot; ## [1] &quot;character&quot; Vektor moemo eksplicitno pretvoriti u drugi tip uz pomo ve upoznatih funkcija as.&lt;naziv_tipa&gt;. Ukoliko je pretvorbu nemogue provesti element e biti pretvoren u NA uz prikladno upozorenje. Zadatak 3.2 - eksplicitna pretvorba tipa vektora x &lt;- c(1, T, 2L) y &lt;- c(1L, 2L, 3L) z &lt;- c(1.25, TRUE, &quot;Ana&quot; ) # razmislite o moguem rezultatu a potom pokuajte izvriti sljedee pretvorbe # vektor `x` u numeriki tip # vektor `y` u znakovni tip # vektor `z` u cjelobrojni tip # razmislite o moguem rezultatu a potom pokuajte izvriti sljedee pretvorbe # vektor `x` u numeriki tip # vektor `y` u znakovni tip # vektor `z` u cjelobrojni tip as.numeric(x) as.character(y) as.integer(z) ## Warning: NAs introduced by coercion ## [1] 1 1 2 ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; ## [1] 1 NA NA Moete li odgovoriti na pitanje - zato u zadnjem primjeru vrijednost TRUE nije postala 1L ve NA? Pokuajte ispisati vektor z i uoite rezultate implicitne pretvorbe koju ste moda zanemarili (a koja je logiku vrijednost TRUE pretvorila u niz znakova \"TRUE\" kojeg vie nije mogue vratiti u numeriku vrijednost 1L). Funkcijom c moemo takoer i vie vektora spojiti u jedan: a &lt;- c(1, 2, 3) b &lt;- c(4, 5) c &lt;- c(6, 7, 8) # varijablu smijemo nazvati &quot;c&quot; usprkos tome to postoji funkcija c() d &lt;- c(a, b, c) # d je sada c(1, 2, 3, 4, 5, 6, 7, 8) Pored funkcije c, R nudi i dodatne pogodne naine stvaranja novih vektora: : - operator raspona (engl. range), pri emu dajemo raspon od gornje do donje granice, obje ukljuive seq - funkcija sekvence (engl. sequence), radi slino operatoru raspona, ali s dodatnim mogunostima rep - funkcija repliciranja (engl. replicate), ponavlja zadane elemente zadani broj puta Zadatak 3.3 - pomone funkcije za stvaranje vektora # ispiite rezultate sljedeih naredbi # 1:5 # rep(c(1, 2, 3), times = 3) # rep(c(1, 2, 3), each = 3) # seq(1, 5, by = 0.5) # ispiite rezultate sljedeih naredbi 1:5 rep(c(1, 2, 3), times = 3) rep(c(1, 2, 3), each = 3) seq(1, 5, by = 0.5) ## [1] 1 2 3 4 5 ## [1] 1 2 3 1 2 3 1 2 3 ## [1] 1 1 1 2 2 2 3 3 3 ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 Vektore moemo stvoriti i uz pomo funkcija koje odgovaraju imenima tipova vektora (numeric, character i sl.) pri emu kao parametar navodimo eljenu duljinu vektora. Ovo esto radimo kao pripremu vektora za naknadno punjenje stvarnim vrijednostima, tj. svojevrsnu rezervaciju mjesta u radnoj memoriji. Ono to je interesantno jest injenica da moemo stvoriti i prazan vektor odreenog tipa koji je i dalje vektor, samo sa duljinom nula (a kojem npr. uz pomo funkcije c moemo naknadno dodavati elemente). x &lt;- numeric(2) # vektor se puni &quot;nultim&quot; elementima, u ovom sluaju (0, 0) y &lt;- character(5) z &lt;- integer(0) # &quot;prazan&quot; vektor! z &lt;- c(z, 1) # dodaj vektoru element 1 (zapravo &quot;spoji prazan vektor i element 1&quot;) Konano, provjeru da li neki vektor sadri odreeni element moemo napraviti uz pomo operatora %in%: 4 %in% seq(1, 10, 2) # vraa FALSE &quot;d&quot; %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) # vraa TRUE Pogledajmo sada kako pristupiti pojedinim elementima vektora 3.1.2 Operator [ Elementima vektora pristupamo preko indeksnog operatora [, uz pomo kojeg moemo i mijenjati elemente vektora: a &lt;- c(2, 4, 6) a[1] # ispisuje vrijednost 2 a[2] &lt;- 5 # element na 2. mjestu postaje 5 a[5] &lt;- 7 # na 5. mjesto dodaje se 7, a &quot;rupa&quot; se popunjava sa NA a ## [1] 2 ## [1] 2 5 6 NA 7 Uoite jednu pomalo neuobiajenu injenicu - prvi element vektora u R-u ima indeks 1, a ne 0! Ovo je bitna razlika u odnosu na referenciranje elemenata u drugim programskim jezicima. Razlog ove specifinosti je jednostavan - R se primarno smatra jezikom za analizu podataka, poglavito u tablinom obliku, a u praksi je puno lake brojati retke ili stupce redoslijedom kako se pojavljuju u podatkovnom skupu nego raditi posmak za 1. Primjer gore zapravo prikazuje vrlo pojednostavljeni sluaj pristupanja elementima vektora i nain njihove izmjene. Naime, jedna od specifinosti jezika R je tzv. vektoriziranost, tj. princip da se u R-u vrlo esto radi vie stvari odjednom - ne toliko u smislu paralelnog izvravanja, ve u smislu zadavanja naredbi to elimo da se izvede. Konkretno, u sluaju referenciranja elemenata vektora vrlo rijetko dohvaamo ili mijenjamo elemente jedan po jedan, ve obuhvaamo vei broj elemenata odjednom koritenjem principa vektorizacije i recikliranja. Razumijevanje ovih pojmova presudno je za svladavanje jezika R, tako da emo ih detaljno objasniti u nastavku. 3.1.3 Principi vektorizacije i recikliranja Pojam vektorizacije ili bolje reeno vektoriziranih operacija i funkcija jednostavno znai da se operacije rade nad vie elemenata odjednom. Ako zadamo R-u da radi neku operaciju ili funkciju nad nekim vektorom vrijednosti, R e funkciju ili operaciju izvesti nad svakim elementom posebno i vratiti rezultantni vektor kao rezultat. Isto tako, ako provodimo binarnu operaciju nad dva vektora, ona e se provesti nad uparenim ili poravnatim elementima obaju vektora (pretpostavimo za sada da su vektori jednake duljine). Zadatak 3.4 - princip vektorizacije x &lt;- seq(-5, 5, 1) a &lt;- 1:3 b &lt;- 4:6 # pozovite funkciju `abs` za raunanje apsolutne vrijednosti # nad vektorom `x` i ispiite rezultat # zbrojite vektore `a` i `b` uz pomo operatora `+` # i ispiite rezultat # pomnoite vektore `a` i `b` uz pomo operatora `*` # i ispiite rezultat # pozovite funkciju `abs` za raunanje apsolutne vrijednosti # nad vektorom `x` i ispiite rezultat abs(x) cat(&quot;-----------\\n&quot;) # zbrojite vektore `a` i `b` uz pomo operatora `+` # i ispiite rezultat a + b cat(&quot;-----------\\n&quot;) # pomnoite vektore `a` i `b` uz pomo operatora `*` # i ispiite rezultat a * b ## [1] 5 4 3 2 1 0 1 2 3 4 5 ## ----------- ## [1] 5 7 9 ## ----------- ## [1] 4 10 18 Paljivo razmotrite rezultate prethodnog zadatka. Ukoliko je potrebno, skicirajte vektore a i b na papiru sa vertikalno poslaganim elementima i uoite kako radi paralelno uparivanje elemenata. Primijetite da ovdje ne priamo o vektorskim operacijama u strogom matematikom smislu, ve o poravnavanju elemenata dvaju nizova i provoenja jednostavnih operacija nad svakim od tih parova. Ovo je pogotovo oito u zadnjem primjeru gdje nema nikakvog mnoenja vektora u nekoj od matematikih interpretacija, ve se provodi jednostavno mnoenje paralelnih elemenata dvaju vektora. to ako vektori nisu jednake duljine? R u ovom sluaju koristi princip recikliranja. Princip recikliranja navodi da se kod nejednake duljine vektora krai vektor reciklira onoliko puta koliko je potrebno da se dostigne duljina duljeg vektora. Najei scenarij koritenja ovog principa su operacije u kojima je s jedne strane vektor s vie elemenata a s druge strane jednoelementni vektor koji se onda reciklira za svaki element velikog vektora. Ono to bismo trebali izbjegavati jest scenarij recikliranja gdje duljina velikog vektora nije viekratnik duljine malog - R e i dalje reciklirati krai vektor, samo e ga na kraju morati odrezati to e rezultirati odgovarajuim upozorenjem. Zadatak 3.5 - princip recikliranja a &lt;- 1:4 b &lt;- c(1, 2) c &lt;- rep(5, 3) # udvostruite elemente vektora `a` i ispiite rezultat # podijelite vektor `a` vektorom `b` i ispiite rezultat # pomnoite vektore `a` i `c` i ispiite rezultat a &lt;- 1:4 b &lt;- c(1, 2) c &lt;- rep(5, 3) # udvostruite elemente vektora `a` i ispiite rezultat 2 * a # podijelite vektor `a` vektorom `b` i ispiite rezultat a / b # pomnoite vektore `a` i `c` i ispiite rezultat a * c ## Warning in a * c: longer object length is not a multiple of shorter object ## length ## [1] 2 4 6 8 ## [1] 1 1 3 2 ## [1] 5 10 15 20 Sada konano moemo demistificirati razliku izmeu skalarnih i vektorskih logikih operatora (podsjetimo se, skalarni su || i &amp;&amp;, dok su vektorski | i &amp;). Skalarni logiki operatori namijenjeni su koritenju sa jednoelementnim vektorima, vraaju jedinstvenu vrijednosti TRUE ili FALSE te su pogodni za koritenje raznim u uvjetnim izrazima. Vektorski logiki operatori koriste standardne R-ove principe vektorizacije i recikliranja, tj. namijenjeni su radu sa logikim vektorima i kao rezultat daju logiki vektor Zadatak 3.6 - skalarni i vektorski logiki operatori a &lt;- c(T, F, F) b &lt;- c(T, T, F) # primjenite skalarnu i vektorsku inaicu logikog operatora &quot;ili&quot; # nad vektorima `a` i `b` i ispiite rezultat # primjenite skalarnu i vektorsku inaicu logikog operatora &quot;ili&quot; # nad vektorima `a` i `b` i ispiite rezultat a || b a | b ## [1] TRUE ## [1] TRUE TRUE FALSE Vidimo da e skalarna inaica iskoristiti samo prvi par elemenata logikih vektora. Ovo znai da ju u teoriji moemo koristiti u uvjetnim izrazima, iako za to nema opravdanog smisla, a R e se u tom sluaju oglasiti upozorenjem kako bi nam obratio panju na injenicu da vjerojatno koristimo krivi operator. Sljedei primjer sa usporednim operatorima e moda inicijalno izgledati trivijalan, no potrebno je obratiti posebnu panju na rezultate koje emo dobiti budui da e oni imati vrlo vanu primjenu u nastavku lekcije. Dakle, pogledajmo to se dogaa kod vektorizacije usporednih operatora. Zadatak 3.7 - vektorizacija usporednih operatora x &lt;- 1:5 y &lt;- seq(-10, 10, 5) #ispiite x i y #ispiite rezultat naredbe x &gt; y i objasnite rezultat #ispiite rezultat naredbe x &lt; 3 i objasnite rezultat #ispiite x i y x y cat(&quot;-----------\\n&quot;) #ispiite rezultat naredbe x &gt; y i objasnite rezultat x &gt; y cat(&quot;-----------\\n&quot;) #ispiite rezultat naredbe x &lt; 3 i objasnite rezultat x &lt; 3 ## [1] 1 2 3 4 5 ## [1] -10 -5 0 5 10 ## ----------- ## [1] TRUE TRUE TRUE FALSE FALSE ## ----------- ## [1] TRUE TRUE FALSE FALSE FALSE Dakle vektoriziranom primjenom usporednih operatora nad vektorima (ili kombinacijama vektora i skalara) kao rezultat dobivamo logike vektore. Interpretacija ovih rezultata je kljuna - ona zapravo odgovara na pitanje na kojim indeksima je zadovoljen uvjet zadan ovim izrazom? Drugim rijeima, dobiveni rezultati zapravo predstavljaju predloak koji opisuje kako filtrirati elemente prema zadanom principu. Ovo je osnovni temelj tzv. logikog referenciranja, to je jedna od metoda dohvaanja elemenata vektora koje emo upoznati u nastavku. 3.2 Indeksni vektori Ve smo nauili da elementu polja moemo pristupiti preko numerikog indeksa (a nismo zaboravili ni injenicu da prvi element ima indeks 1). Ovaj koncept moemo proiriti tako da iz vektora uzimamo vie elemenata odjednom. to se esto naziva rezanjem vektora (engl. slicing). Osnovni princip odabira vie elemenata odjednom je jednostavan - samo moramo na odreeni nain navesti indekse elemenata koje elimo. R nudi tri osnovna naina referenciranja: lokacijsko referenciranje (engl. integer- or location-based referencing) uvjetno referenciranje (engl. conditional- or boolean-based referencing) imensko referenciranje (engl. label-based referencing) Koje referenciranje emo odabrati ovisi o tome elimo li elementima pristupati ovisno o njihovoj lokaciji, imenu ili prema zadanom uvjetu, a svaki tip referenciranja u sutini se svodi na koritenje vektora odreenog tipa kao parametra za operator referenciranja. Ovakav vektor se zbog svoje uloge naziva indeksnim vektorom. Upoznajmo detaljno svaki od tipova referenciranja. 3.2.1 Lokacijsko referenciranje Lokacijsko referenciranje je poopenje ve upoznatog principa referenciranja gdje navodimo redni broj elementa koji nas zanima. Ako elimo vie elemenata, jednostavno navedemo njihove indekse zapakirane u numeriki vektor. Pokuajte rijeiti sljedei zadatak koritenjem odgovarajuih numerikih vektora kao parametara indeksnog operatora. Zadatak 3.8 - lokacijsko referenciranje x &lt;- 1:10 # ispiite prvi element vektora x # ispiite prva tri elementa vektora x # ispiite prvi, peti i sedmi element vektora x # ispiite prvi element vektora x x[1] # ispiite prva tri elementa vektora x x[1:3] # ispiite prvi, peti i sedmi element vektora x x[c(1,5,7)] ## [1] 1 ## [1] 1 2 3 ## [1] 1 5 7 Dakle, lokacijski indeksni vektor nije nita drugo nego obian numeriki vektor kojeg koristimo zajedno sa indeksnim operatorom da bi odredili koje elemente nekog drugog vektora elimo zadrati. Pogledajmo jo neke znaajke lokacijskih indeksnih vektora: Zadatak 3.9 - lokacijsko referenciranje (2) x &lt;- 1:10 # odgovorite na sljedea pitanja uz pomo prikladnog primjera # to vraa indeks 0? # to vraa negativni indeks? # to vraa indeks izvan granica duljine vektora x &lt;- 1:10 # odgovorite na sljedea pitanja uz pomo prikladnog primjera # to vraa indeks 0? x[0] # to vraa negativni indeks? x[-1] # to vraa indeks izvan granica duljine vektora x[20] ## integer(0) ## [1] 2 3 4 5 6 7 8 9 10 ## [1] NA Indeksni operator se ne koristi samo za dohvaanje elemenata. Kombinacijom indeksnog operatora i operatora pridruivanja moemo mijenjati elemente vektora (i to takoer po principu vie elemenata odjednom: Zadatak 3.10 - lokacijsko referenciranje i pridruivanje a &lt;- 1:10 # postavite sve elemente vektora `a` od drugog do osmog mjesta na nulu # ispiite vektor `a` b &lt;- 1:20 b[2 * 1:5] &lt;- 0 # razmislite kako izgleda vektor `b` nakon gornje naredbe # ispiite vektor `b` i objasnite rezultat a &lt;- 1:10 # postavite sve elemente vektora `a` od drugog do osmog mjesta na nulu # ispiite vektor `a` a[2:8] &lt;- 0 a b &lt;- 1:20 b[2 * 1:5] &lt;- NA # razmislite kako izgleda vektor `b` nakon gornje naredbe # ispiite vektor `b` i objasnite rezultat b ## [1] 1 0 0 0 0 0 0 0 9 10 ## [1] 1 NA 3 NA 5 NA 7 NA 9 NA 11 12 13 14 15 16 17 18 19 20 3.2.2 Uvjetno referenciranje Ako smo paljivo razmotrili rezultate dobivene kod primjera sa vektoriziranim usporednim operatorima onda smo mogli vrlo dobro naslutiti kako radi uvjetno referenciranje. Princip je jednostavan - za indeksni vektor postavljamo logiki vektor iste duljine kao i vektor ije elemente elimo dohvatiti. Elementi logikog vektora odreuju koje elemente zadravamo (pozicije gdje se nalazi vrijednost TRUE) a koje odbacujemo (pozicije gdje se nalazi vrijednost FALSE). Zadatak 3.11 - uvjetno referenciranje x &lt;- 1:10 # napravite logiki vektor `y` duljine 10 sa proizvoljnom kombinacijom # vrijednosti TRUE i FALSE # indeksirajte vektor `x` vektorom `y`, ispiite i objasnite rezultat # ispiite sve elemente vektora `x` manje ili jednake 5 # kao logiki indeksni vektor upotrijebite odgovarajui izraz # koji koristi usporedni operator x &lt;- 1:10 # napravite logiki vektor `y` duljine 10 sa proizvoljnom kombinacijom # vrijednosti TRUE i FALSE y &lt;- c(T, T, F, T, F, F, F, T, F, T) # indeksirajte vektor `x` vektorom `y`, ispiite i objasnite rezultat x[y] # ispiite sve elemente vektora `x` manje ili jednake 5 # kao logiki indeksni vektor upotrijebite odgovarajui izraz # koji koristi usporedni operator x[x &lt;= 5] ## [1] 1 2 4 8 10 ## [1] 1 2 3 4 5 Zadnja naredba, naoko jednostavna, predstavlja jedan od kljunih principa odabira elemenata u jeziku R. Kombinacija indeksnog operatora i uvjetnog izraza predstavlja saet ali vrlo moan mehanizam rezanja vektora prema odabranom kriteriju. Isprobajmo ovaj princip na jo nekoliko primjera. Zadatak 3.12 - uvjetno referenciranje y &lt;- sample(1:100, 20) # nasumicni odabir 20 elemenata izmedju 1 i 100 studenti &lt;- c(&quot;Ivo&quot;, &quot;Petra&quot;, &quot;Marijana&quot;, &quot;Ana&quot;, &quot;Tomislav&quot;, &quot;Tin&quot;) # ispiite vektor koji sadri sve parne, a potom sve neparne elemente vektora `y` # ispiite sve elemente vektora `studenti` koji predstavljaju imena od 3 slova # (napomena: za prebrojavanje slova znakovnog niza u R-u koristimo funkciju `nchar`) y &lt;- seq(1, 100, 7) studenti &lt;- c(&quot;Ivo&quot;, &quot;Petra&quot;, &quot;Marijana&quot;, &quot;Ana&quot;, &quot;Tomislav&quot;, &quot;Tin&quot;) # ispiite vektor koji sadri sve parne, a potom sve neparne elemente vektora `y` c(y[y %% 2 == 0], y[y %% 2 != 0]) # ispiite sve elemente vektora `studenti` koji predstavljaju imena od 3 slova # (napomena: za prebrojavanje slova znakovnog niza u R-u koristimo funkciju `nchar`) studenti[nchar(studenti) == 3] ## [1] 8 22 36 50 64 78 92 1 15 29 43 57 71 85 99 ## [1] &quot;Ivo&quot; &quot;Ana&quot; &quot;Tin&quot; Ukoliko koncept uvjetnog referenciranja uz pomo uvjetnih izraza i dalje nije jasan, jedna od stvari koje mogu pomoi jest skiciranje meurezultata - jednostavno na papir ispiite rezultat izraza unutar uglatih zagrada indeksnog operatora i potom razmislite kako taj rezultat utjee na konano rjeenje. Preostao nam je jo samo zadnji tip referenciranja koji radi na principu dohvaanja elemenata vektora ovisno o njihovom imenu. 3.2.3 Imensko referenciranje Imensko referenciranje radi na principu eksplicitnog imenovanja elemenata koje elimo zadrati. Da bi mogli koristiti ovakav tip referenciranja moramo zadovoljiti nuan preduvjet - elementi vektora moraju imati definirana imena. Vektori koje smo do sada koristili nisu imali imenovane elemente. Svaki element imao je svoju predefiniranu poziciju unutar vektora te svoju vrijednost, ali nije imao nikakav poseban dodatni identifikator. Programski jezik R doputa pridavanje imena elementima vektora na vrlo jednostavan nain - koritenjem funkcije names, operatora pridruivanja te znakovnog vektora sa odabranim imenima. Moramo voditi rauna da vektor imena bude jednake duljine kao originalni vektor! Zadatak 3.13 - imensko referenciranje visine &lt;- c(165, 173, 185, 174, 190) names(visine) &lt;- c(&quot;Marica&quot;, &quot;Pero&quot;, &quot;Josip&quot;, &quot;Ivana&quot;, &quot;Stipe&quot;) # ispiite vektor `visine` # ispiite koliko su visoki Pero i Ivana visine &lt;- c(165, 173, 185, 174, 190) names(visine) &lt;- c(&quot;Marica&quot;, &quot;Pero&quot;, &quot;Josip&quot;, &quot;Ivana&quot;, &quot;Stipe&quot;) # ispiite vektor `visine` visine # ispiite koliko su visoki Pero i Ivana visine[c(&quot;Pero&quot;, &quot;Ivana&quot;)] ## Marica Pero Josip Ivana Stipe ## 165 173 185 174 190 ## Pero Ivana ## 173 174 Vidimo da se imensko referenciranje oekivano svodi na prosljeivanje odgovarajueg znakovnog vektora kao parametra referenciranja. (NAPOMENA: Paljiviji itatelj uoiti e jednu neobinu injenicu u gornjem programskom kodu - poziv funkcije se koristi kao lvalue! Odgovor na pitanje zato je ovo mogue zahtijeva malo vie znanja o internom funkcioniranju jezika R, a za sada je dovoljno rei da se ovdje zapravo radi o pozivu funkcije pravog imena names&lt;- koji se skriva iza puno intuitivnije i lako razumljive sintakse) Ukoliko iz nekog razloga poelimo obrisati imena elemenata vektora, jednostavno pozivu funkcije names proslijedimo NULL. names(visine) &lt;- NULL Ovime emo zakljuiti priu o vektorima. Nauili smo razliite naine stvaranja vektora te dohvaanja i izmjene njegovih elemenata. Sada je vrijeme da pokuamo vektorima dodati dodatnu dimenziju - upoznajmo matrice i polja. 3.3 Matrice i polja Matrice i polja su, jednostavno reeno, viedimenzionalni vektori. Matrica (engl. matrix) je tako vektor sa dvije dimenzije, tj. vektor koji elemente smijeta u retke i stupce. Polje (engl. array) je vektor sa tri ili vie dimenzija. Dok se matrice relativno esto koriste u praksi, polja su ipak neto vie ograniena na posebne scenarije. Zbog ove injenice u ovom poglavlju uglavnom emo se baviti matricama, iako se prikazani koncepti vrlo lako poopuju na polja. Ono to je zajedniko matricama i poljima, a to je poznata injenica itateljima sa programerskim iskustvom, jest da je njihova viedimenzionalnost zapravo prividna. I matrice i polja su zapravo jednodimenzionalni vektori kojima je dodan atribut dimenzionalnosti, a uz pomo tog atributa jezik R mapira nae viedimenzionalno referenciranje u stvarni indeks elementa jednodimenzionalnog vektora. Ova injenica nas ne ograniava - mi i dalje moemo u veini sluajeva tretirati matricu kao da je zaista dvodimenzionalna, a znanje o jednodimenzionalnoj prirodi nam moe samo dati dodatnu fleksibilnost u radu s matricama. Postoji nekoliko naina stvaranja nove matrice: uz pomo funkcije matrix kojoj prosljeujemo jednodimenzionalni vektor i eljeni broj redaka i stupaca kroz parametre nrow i ncol runim postavljanjem dimenzija jednodimenzionalnog vektora uz pomo funkcije dim i pridruivanja dvoelementnog numerikog vektora sa dimenzijama matrice ljepljenjem jednodimenzionalnih vektora koji predstavljaju retke ili stupce nove matrice uz pomo funkcija rbind (engl. row bind) i cbind (engl. column bind) Demonstrirajmo ove naine u primjerima koji slijede. Zadatak 3.14 - funkcija matrix x &lt;- 1:12 # uz pomo funkcije `matrix` i stvorite matricu sa 3 retka i 4 stupca # koja sadri elemente vektora `x` # ispiite rezultat na zaslon # ponovite postupak ali pozivu funkcije dodajte parametar `byrow = T` # ispiite rezultat na zaslon i usporedite s prethodnim rezultatom # uz pomo funkcije `matrix` stvorite matricu sa 3 retka i 4 stupca # koja sadri elemente vektora `x` # ispiite rezultat na zaslon matrix(x, nrow = 3, ncol = 4) # ponovite postupak ali pozivu funkcije dodajte parametar `byrow = T` # ispiite rezultat na zaslon i usporedite s prethodnim rezultatom matrix(x, nrow = 3, ncol = 4, byrow = T) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 Uoite da ga ukoliko eksplicitno ne zamolimo drugaije, R matricu popunjava po stupcima. Ovo je napravljeno zbog slinosti matrice sa tablinim prikazom podataka koje najee analiziramo gledajui pojedine stupce. No budui da nam je esto punjenje po retcima prirodnije, ne smijemo zaboraviti na vrlo korisni parametar byrow. Zadatak 3.15 - funkcija dim m &lt;- 1:10 # ispiite rezultat poziva funkcije `dim` nad vektorom `m` # pozivu funkcije `dim` nad vektorom `m` pridruite vektor c(2, 5) # ispiite `m` i komentirajte rezultat # ispiite rezultate poziva funkcija `nrow` i `ncol` nad matricom `m` m &lt;- 1:10 # ispiite rezultat poziva funkcije `dim` nad vektorom `m` dim(m) # pozivu funkcije `dim` nad vektorom `m` pridruite vektor c(2, 5) dim(m) &lt;- c(2, 5) # ispiite `m` i komentirajte rezultat m # ispiite rezultate poziva funkcija `nrow` i `ncol` nad matricom `m` nrow(m) ncol(m) ## NULL ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 ## [1] 2 ## [1] 5 Vidimo da obian vektor zapravo nema dimenziju, to se oituje preko NULL vrijednosti koju smo dobili kao rezultat. Pozivom funkcije dim mi vektoru zapravo dodajemo atribut naziva dim ime on formalno postaje matrica (tj. polje u openitom sluaju). Upravo dimenzije su te koje definiraju kako su elementi sloeni po retcima i stupcima a postavljanjem dimenzija moramo biti oprezni da one odgovaraju trenutnom broju elemenata. Jednom kad matrica ima dodane dimenzije, moemo ih dohvatiti zajedno uz pomo funkcije dim, ili samo broj redaka ili stupaca uz pomo funkcija nrow i ncol. Rezultantna matrica je poput one iz prethodnog primjera popunjena po stupcima. Budui da ovdje nemamo priliku koristiti parametar byrow, jedan od naina da dobijemo matricu popunjenu po retcima jest da transponiramo dobiveni rezultat uz pomo funkcije t. m &lt;- t(m) # transponiramo matricu i pohranjujemo natrag u varijablu `m` Konano, matricu moemo stvoriti ljepljenjem redaka i stupaca uz pomo funkcija rbind i cbind. Ovo je takoer zgodan nain dodavanja novih redaka i stupaca postojeoj matrici. Zadatak 3.16 - funkcije rbind i cbind a &lt;- 1:4 b &lt;- 5:8 c &lt;- c(0,0) # stvorite matricu `m` u kojoj e vektori `a` i `b` biti retci # dodajte novi redak na vrh matrice `m` sa elementima vektora `c` # ispiite matricu `m` a &lt;- 1:4 b &lt;- 5:8 c &lt;- c(0,0) # stvorite matricu `m` u kojoj e vektori `a` i `b` biti stupci m &lt;- cbind(a,b) # dodajte novi redak na vrh matrice `m` sa elementima vektora `c` # ispiite matricu `m` m &lt;- rbind(c, m) m ## a b ## c 0 0 ## 1 5 ## 2 6 ## 3 7 ## 4 8 Vidimo da su retci i stupci naslijedili imena vektora od kojih su nastali, to je ponekad zgodno kao vizualni podsjetnik ili jednostavnije referenciranje. Ukoliko elimo promijeniti (ili ukloniti) imena redaka ili stupaca, umjesto funkcije names kod matrica koristimo funkcije rownames ili colnames. 3.3.1 Rezanje matrica Sve nauene principe za rezanje vektora uz pomo indeksnih vektora moemo direktno primijeniti nad matricama. Razlike su sljedee: referenciramo svaku dimenziju zasebno prvo referenciramo retke, a potom stupce, a indeksne vektore odvajamo zarezom ako elimo sve retke ili sve stupce taj indeksni vektor jednostavno izostavimo (ali i dalje koristimo zarez) # pretpostavimo da je `m` matrica dimenzija 3 x 5, sa imenima stupaca od `a` do `e` m[1, 2:5] # prvi redak, svi stupci od drugog do petog m[c(F, T, T), c(&quot;a&quot;, &quot;b&quot;)] # drugi i trei redak, stupci `a` i `b` m[,] # svi retci i svi stupci (moe i samo `m`) U praksi kod matrica najee koristimo lokacijsko i imensko referenciranje; uvjetno referenciranje nije previe praktino zbog dvodimenzionalne prirode matrice (iako je izvedivo, samo moramo voditi rauna da logiki indeksni vektori duljinom odgovaraju pripadajuoj dimenziji). Jedna od stvari na koju moramo voditi rauna jest tendencija jezika R da nam pomae pojednostavljujui rezultat. Tako e rezultat operacije rezanja matrice koja ostavlja samo jedan redak ili stupac automatski postati vektor, tj. izgubiti e atribut dimenzije. Ovo nam nekad ne odgovara, pogotovo ako radimo programske skripte koje u daljnjoj proceduri oekuju matricu, pa makar ona imala dimenziju redaka ili stupaca 1. U tom sluaju kod referenciranja moramo postaviti i dodatni parametar drop = F. Ovo esto izgleda dosta nezgrapno, zbog ega danas postoje mnogi paketi proirenja jezika R koji ovo popravljaju, tj. koji se trude rezultat ostavljati u konzistentnom obliku. No parametar drop postavljen na FALSE treba imati u vidu, budui da e se pojavljivati i na drugim mjestima u slinoj funkciji. Zadatak 3.17 - rezanje matrica m &lt;- matrix(1:30, 6, 5, T) colnames(m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # ispiite sve elemente matrice m od drugog do etvrtog retka # te od treeg do petog stupca # sve elemente u stupcu naziva &quot;c&quot; postavite na nulu # a potom ispiite prva dva retka matrice `m` # ispiite samo stupac &quot;d&quot; # ispiite opet stupac &quot;d&quot;, ali kod referenciranja dodajte parametar `drop = FALSE` # parametar odvojite zarezom (kao da se radi o &quot;treoj&quot; dimenziji referenciranja) m &lt;- matrix(1:30, 6, 5, T) colnames(m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # ispiite sve elemente matrice `m` od drugog do etvrtog retka # te od treeg do petog stupca m[2:4, 3:5] # sve elemente u stupcu naziva &quot;c&quot; postavite na nulu # a potom ispiite prva dva retka matrice `m` m[, &quot;c&quot;] &lt;- 0 m[1:2,] # ispiite samo stupac &quot;d&quot; m[, &quot;d&quot;] # ispiite opet stupac &quot;d&quot;, ali kod referenciranja dodajte parametar `drop = FALSE` # parametar odvojite zarezom (kao da se radi o &quot;treoj&quot; dimenziji referenciranja) m[, &quot;d&quot;, drop = F] ## c d e ## [1,] 8 9 10 ## [2,] 13 14 15 ## [3,] 18 19 20 ## a b c d e ## [1,] 1 2 0 4 5 ## [2,] 6 7 0 9 10 ## [1] 4 9 14 19 24 29 ## d ## [1,] 4 ## [2,] 9 ## [3,] 14 ## [4,] 19 ## [5,] 24 ## [6,] 29 Ovdje emo zavriti priu o matricama. Ove strukture su vrlo korisne kod rjeavanja matematikih zadataka zasnovanih na matricama, pri emu je esto zgodno pogledati dokumentaciju jezika R kako bi vidjeli koje funkcije i operatori su nam dostupni za takav posao. Isto tako, neki prikazani principi upravljanja matricama biti e korisni kod upravljanja tzv. podatkovnim okvirima - vjerojatno najpopularnijem tipu objekta jezika R kojeg emo upoznati u jednom od nastupajuih poglavlja. Konano, iako se neemo detaljno baviti poljima, prikaimo radi potpunosti primjer programskog koda koji stvara trodimenzionalno polje te potom ispisuje jedan njegov dio standardnim principom rezanja kojeg smo upoznali kod vektora i matrica. polje &lt;- array(1:24, dim = c(2, 3, 4)) # polje dimenzija 2 x 3 x 4 polje[, 1:2, 3, drop = FALSE] # ispis svih redaka, prvog i drugog stupca # treeg &quot;sloja&quot;, uz zadravanje tipa polja Polja su koristan tip objekta za viedimenzionalne izraune i specijalizirane svrhe, npr. kod programiranja s tenzorima. Bitno je shvatiti da se usprkos dodatnoj kompleksnosti koju donosi viedimenzionalnost veliki dio funkcionalnosti direktno preslikava iz funkcija za upravljanje niedimenzionalnim objektima, moda uz manje preinake - npr. za imenovanje slojeva polja neemo koristiti names niti rownames/colnames ve funkciju dimnames uz eksplicitno navoenje indeksa dimenzije koju imenujemo. 3.4 Liste Lista je element programskog jezika R koji se koristi kao univerzalni spremnik bilo kakvih podataka. Za razliku od vektora (tj. od pojma vektora kakvog smo ga inicijalno definirali), lista moe sadravati razliite tipove podataka ili - ee - skupove razliitih tipova podataka. Listu stvaramo uz pomo funkcije list kojom dodajemo niz parova naziva elemenata i njihovih sadraja. Ovi elementi mogu biti bilo to, pa ak i druge liste. mojaLista &lt;- list(a = 1, b = 2:100, c = list(x = 1, y = 2)) Probajmo stvoriti vlastitu listu u sljedeem primjeru. Zadatak 3.18 - stvaranje liste # stvorite novu listu naziva `svastara` koja e imati sljedee elemente # element naziva `brojevi` sa cijelim brojevima od 1 do 3 # element naziva `slova` sa slovima &quot;A&quot; i &quot;B&quot; # bezimeni element sa logikim vektorom `c(T,F)` # element naziva `imena` sa imenima &quot;Ivo&quot; i &quot;Ana&quot; # ispiite listu `svastara` svastara &lt;- list(brojevi = c(1,2,3), slova = c(&quot;A&quot;, &quot;B&quot;), c(T,F), imena = c(&quot;Ivo&quot;, &quot;Ana&quot;)) # ispiite listu `svastara` svastara ## $brojevi ## [1] 1 2 3 ## ## $slova ## [1] &quot;A&quot; &quot;B&quot; ## ## [[3]] ## [1] TRUE FALSE ## ## $imena ## [1] &quot;Ivo&quot; &quot;Ana&quot; Uoite da lista zadrava poredak elemenata - element bez imena prikazan je indeksom 3. Funkcija str (engl. structure) omoguuje nam uvid u svojstva i sadraj liste bez ispisivanja cijele liste. Ovu funkciju analitiari esto koriste, kako za pregled lista tako i za brzi uvid u ve spomenute podatkovne okvire koje emo raditi u iduem poglavlju. Zadatak 3.19 - struktura liste # ispiite strukturu liste `svastara` # ispiite strukturu liste `svastara` str(svastara) ## List of 4 ## $ brojevi: num [1:3] 1 2 3 ## $ slova : chr [1:2] &quot;A&quot; &quot;B&quot; ## $ : logi [1:2] TRUE FALSE ## $ imena : chr [1:2] &quot;Ivo&quot; &quot;Ana&quot; Na poetku ove lekcije smo rekli da u R-u vrijedi princip sve je vektor te da su vektori zapravo ureeni skupovi elemenata istog tipa. Iz ovog bi se moglo zakljuiti da ta injenica ne vrijedi za liste - oni oito sadravaju elemente razliitih tipova. No pravi odgovor je - i liste su zapravo vektori, a definicija zapravo nije naruena. Naime, svi elementi liste su zapravo male jednoelementne liste, tako da su formalno svi elementi istog tipa. Zadatak 3.20 - tip elemenata liste # ispiite prvi element liste svastara # provjerite njegov tip # ispiite prvi element liste svastara svastara[1] # provjerite njegov tip typeof(svastara[1]) ## $brojevi ## [1] 1 2 3 ## ## [1] &quot;list&quot; Dakle, dokazali smo da su elementi liste zapravo male liste, to se vidi iz ispisa samog elementa, kao i provjere njezinog tipa. Moda nam se ini da bi elementi gore stvorene liste trebali biti vektori, budui da smo listu i stvorili slaganjem razliitih vektora, no u postupku stvaranja objekta R je umotao elemente u jednoelementne liste prije nego ih je uklopio u veliku listu. esto ne elimo raditi s elementom liste kao malom listom, nego ga trebao u njegovom originalnom obliku. Za ovo koristimo operator [[, tj. operator dvostruke uglate zagrade. Zadatak 3.21 - operator [[ # ispiite prvi element liste svastara koritenjem operatora `[[` # provjerite njegov tip # ispiite prvi element liste svastara svastara[[1]] # provjerite njegov tip typeof(svastara[[1]]) ## [1] 1 2 3 ## [1] &quot;double&quot; Navedeni operator najee koristimo kako bi dohvatili odabrani element liste kojeg definiramo brojem ili (ako ima ime) nazivom elementa. Kod ovakvog dohvata moramo koristiti kombinaciju simbola lista[[\"ime_elementa\"]] koja je poneto nespretna za tipkanja. Zbog toga R nudi alternativni nain pristupa elementima liste prema nazivu koritenjem operatora $, tj. lista$ime_elementa. Zadatak 3.22 - operator $ # ispiite element naziva &quot;slova&quot; liste svastara # koritenjem operatora `[[` # ispiite isti element koritenjem operatora `$` # ispiite element naziva &quot;slova&quot; liste svastara # koritenjem operatora `[[` svastara[[&quot;slova&quot;]] # ispiite isti element koritenjem operatora `$` svastara$slova ## [1] &quot;A&quot; &quot;B&quot; ## [1] &quot;A&quot; &quot;B&quot; Liste su iznimno popularni tip objekta u R-u budui da predstavljaju univerzalni predloak za kompleksnije podatkovne strukture, izmeu ostalog i kompleksnije objekte u uem smislu (kao to emo vidjeti kasnije). Lista je takoer temelj za daleko najpopularniji i najee koriteni element jezika R - podatkovni okvir - kojeg emo upoznati u iduoj lekciji. Za kraj nauimo dodati element u listu. Ovo je najjednostavnije uiniti koritenjem ve spomenutog operatora $ - kao npr. lista$noviElement &lt;- noviElement. Element briemo tako da mu dodijelimo vrijednost NULL. Zadatak 3.23 - dodavanje elementa u listu # listi `svastara` dodajte element `parniBrojevi` koji sadri # sve parne brojeve od 1 do 100 # obriite trei element liste # ispiite listu `svastara` # listi `svastara` dodajte element `parniBrojevi` koji sadri # sve parne brojeve od 1 do 100 svastara$parniBrojevi &lt;- seq(2, 100, 2) # obriite trei element liste svastara[[3]] &lt;- NULL # ispiite listu `svastara` print(svastara) ## $brojevi ## [1] 1 2 3 ## ## $slova ## [1] &quot;A&quot; &quot;B&quot; ## ## $imena ## [1] &quot;Ivo&quot; &quot;Ana&quot; ## ## $parniBrojevi ## [1] 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 ## [20] 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 ## [39] 78 80 82 84 86 88 90 92 94 96 98 100 U sljedeoj lekciji konano emo upoznati ve vie puta spominjane podatkovne okvire kao daleko najpopularniji i najee koritenu podatkovnu strukturu jezika R. Zadaci za vjebu Stvorite sljedee vektore: (11, 12, 13,, 99) (0, 0, 0, 0,  , 0) (100 nula) (0, 0.1, 0.2, ., 1.0) Kolika je suma svih brojeva od 101 do 1001, ako preskoimo sve brojeve djeljive sa 10? Koristite se funkcijom sum. Stvorite matricu 3 x 3 sa brojevima izvoenjem sljedeih naredbi (funkciju sample emo poblie upoznati u jednoj od sljedeih lekcija): # stvaramo matricu 3x3 nasumino odabranih elemenata iz skupa od 1 do 100 set.seed(1234) m &lt;- matrix(c(sample(1:100, 9, T)), nrow = 3, ncol = 3, byrow = T) Izraunajte inverznu matricu uz pomo funkcije solve. Provjerite da li umnoak originalne i inverzne matrice daje jedininu matricu (za mnoenje matrica koristite se operatorom %*%). Inicijalizirajte ponovo listu svastara koritenu u lekciji. Napravite sljedee: ispiite klasu drugog elementa liste ispiite element na treem mjestu elementa liste naziva slova provjerite duljinu elementa naziva imena te na zadnje mjesto dodajte ime \"Pero\" provjerite da li se broj 4 nalazi u prvom elementu liste na zadnje mjesto liste dodajte novu listu sa tri vektora a, b i c koji svi sadre elemente (1,2,3) Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["okviri.html", "4 Podatkovni okviri i faktori 4.1 Podatkovni okviri 4.2 Odabir redaka i stupaca podatkovnih okvira 4.3 Dodavanje i brisanje redaka i stupaca 4.4 Faktori Zadaci za vjebu", " 4 Podatkovni okviri i faktori 4.1 Podatkovni okviri Kao to je ve reeno, podatkovni okvir je daleko najpopularniji element programskog jezika R. Jezik R predvien je primarno analizi podataka, a podatkovni okvir zapravo predstavlja objektnu reprezentaciju podatkovnog skupa kojeg namjeravamo analizirati. Drugim rijeima, podatkovni okvir je objekt sline funkcije kao tablica u Microsoft Excel-u ili relacijskoj bazi podataka. Gotovo svaka sesija u R-u svodi se na manipuliranje podatkovnim okvirima - no dok u Excel-u tablicom upravljamo uz pomo grafikog suelja, a u bazi uz pomo upitnog jezika SQL, u R-u podatkovnim okvirima upravljamo gotovo iskljuivo programski. Uzmimo za primjer sljedeu tablicu: pbr nazivMjesta prosjPlacaKn brojStanovnika prirez 10000 Zagreb 6359.00 790017 18 51000 Rijeka 5418.00 128384 15 21000 Split 5170.00 167121 10 31000 Osijek 4892.00 84104 13 20000 Dubrovnik 5348.00 28434 10 Ovdje se radi o podatkovnom skupu koji sadrava odreene parametre vezane uz gradove u Republici Hrvatskoj (navedene vrijednosti ne odgovaraju nuno trenutnom stanju ve ih koristimo samo za demonstraciju). Lako moemo zamisliti kako ove podatke zapisujemo u Excel ili stvaramo relacijsku tablicu naziva npr. MJESTO u koju onda pohranjujemo navedene podatke. Pokaimo sada kako bi sa istim podacima manipulirati u sklopu jezika R, tj. pokuajmo stvoriti podatkovni okvir koji e sadravati ove podatke. U proloj lekciji smo napomenuli da je lista kao sloeni tip zapravo svojevrsni predloak uz pomo kojeg moemo raditi nove objekte. Podatkovni okvir tako zapravo nije nita drugo nego lista  tj. spremnik koji moe sadravati u sebi druge spremnike podataka razliitog tipa. No dok je lista zapravo univerzalni spremnik, tj. nemamo ogranienja totrpamo\" u nju, podatkovni okvir ima odreene restrikcije. Najvanije ogranienje koje podatkovni okvir namee jest da svaki element unutar podatkovnog okvira mora imati isti broj elemenata. Zato je tome tako? Zamislimo listu u kojoj svaki element ima isti broj podelemenata. Ako svaki element skiciramo vertikalno, sa podelementima napisanim jedan ispod drugog, onda e ti podelementi biti poravnati po retcima ime smo postigli klasinu organizaciju podataka u stupce (elemente liste) i retke (poravnati podelementi). Dakle, ova restrikcija zapravo direktno namee tablinu ili matrinu strukturu liste sa jasno definiranim retcima i stupcima, to nam zapravo omoguuje da podatkovnim okvirom upravljamo i uz pomo metoda vezanih uz liste, ali i uz pomo metoda primarno namijenjenih matricama. Postoji vie naina stvaranja podatkovnih okvira, a mi emo prikazati dva u praksi najee susretana scenarija: programsko stvaranje uz pomo funkcije data.frame uitavanje podataka iz vanjskog izvora uz pomo funkcije read.csv Prikaimo oba sluaja. Prvo emo stvoriti podatkovni okvir programski. Zadatak 4.1 - programsko stvaranje podatkovnog okvira mjesto &lt;- data.frame(pbr = c(10000, 51000, 21000, 31000, 2000), nazivMjesta = c(&quot;Zagreb&quot;, &quot;Rijeka&quot;, &quot;Split&quot;, &quot;Osijek&quot;, &quot;Dubrovnik&quot;), prosjPlacaKn = c(6359., 5418., 5170., 4892., 5348.), brojStanovnika = c(790017, 128384, 167121, 84104, 28434), prirez = c(18, 15, 10, 13, 10)) # ispiite podatkovni okvir `mjesto` mjesto &lt;- data.frame(pbr = c(10000, 51000, 21000, 31000, 2000), nazivMjesta = c(&quot;Zagreb&quot;, &quot;Rijeka&quot;, &quot;Split&quot;, &quot;Osijek&quot;, &quot;Dubrovnik&quot;), prosjPlacaKn = c(6359., 5418., 5170., 4892., 5348.), brojStanovnika = c(790017, 128384, 167121, 84104, 28434), prirez = c(18, 15, 10, 13, 10)) # ispiite podatkovni okvir `mjesto` mjesto ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 2000 Dubrovnik 5348 28434 10 Ukoliko elite, pokuajte ponovo stvoriti gornji podatkovni okvir ali uz razliite brojeve elemenata vektora koji ine stupce. Ova operacija rezultirati e grekom uz prikladnu poruku a podatkovni okvir nee biti stvoren - R se trudi da matrina priroda okvira uvijek bude ouvana. Mala napomena glede terminologije: u nastavku emo zbog jednostavnosti podatkovni okvir esto zvati jednostavno okvir ili tablica. Isto tako, esto emo za elemente podatkovnog okvira jednakopravno koristiti izraze stupac, varijabla ili atribut, dok emo paralelne podelemente elemenata okvira nazivati retcima ili obzervacijama. Ovi termini u skladu su sa standardnim nainom referenciranja elemenata tablice te statistikim terminima koji se odnose na tabline podatkovne skupove. Ukoliko iz konteksta postoji ansa za dvosmislenost, koristiti e se onaj termin koji jasno opisuje element koji se referencira. Pokuajmo sada uitati tablicu iz vanjskog izvora. Iako R doputa razliite oblike vanjskih podataka, mi emo pretpostaviti da podatke dobivamo u tzv. CSV obliku (engl. CSV - comma-separated values). Ovaj oblik jedan je od najpopularnijih naina pohrane podataka u istom tekstualnom obliku koji ima prednosti da se lako izrauje runo, a veina alata za upravljanje podacima implementira i logiku za izvoz podataka u obliku CSV datoteke. U nastavku moemo vidjeti primjer CSV datoteke koja odgovara podatkovnom okviru izraenom u prethodnom primjeru. Pretpostavimo da se datoteka zove mjesto.csv. Podaci su odvojeni zarezom (bez razmaknice!), svaka obzervacija u svojem retku, a opcionalni prvi redak predstavlja nazive stupaca. pbr,nazivMjesta,prosjPlacaKn,brojStanovnika,prirez 10000,Zagreb,6359.00,790017,18 51000,Rijeka,5418.00,128384,15 21000,Split,5170.00,167121,10 31000,Osijek,4892.00,84104,13 20000,Dubrovnik,5348.00,28434,10 Jedan od potencijalnih problema sa CSV datotekama jest taj to one koriste zarez kao razdvojnik (delimiter) elemenata zapisa, a na odreenim govornim podrujima kao standard se umjesto decimalne toke koristi upravo decimalni zarez. Zbog ove injenice postoji i alternativni CSV standard koji kao razdvojnik koristi toku-zarez, tako da bi naa CSV datoteka u tom sluaju izgledala ovako (nazovimo ju mjestoAlt.csv): pbr;nazivMjesta;prosjPlacaKn;brojStanovnika;prirez 10000;Zagreb;6359,00;790017;18 51000;Rijeka;5418,00;128384;15 21000;Split;5170,00;167121;10 31000;Osijek;4892,00;84104;13 20000;Dubrovnik;5348,00;28434;10 Obzirom da je decimalni zarez propisani standard i na podruju Republike Hrvatske, u radu sa CSV datotekama moramo biti oprezni koji od dva standarda zapisa se koristi. Na sreu, jezik R nudi funkcije za podrku oba standarda, tako da ne moramo posebno prilagoavati ulazne datoteke, tek biti oprezni koju funkciju emo odabrati. Pretpostavimo da u radnoj mapi imamo ove dvije datoteke: mjesto.csv mjestoAlt.csv Ukoliko nemamo dostupne ove datoteke lako ih moemo samostalno napraviti uz pomo obinog ureivaa teksta (npr. Notepad ili gedit) i kopiranja gore navedenih redaka. Za stvaranje podatkovnih okvira iz CSV datoteka koristimo funkcije: - read.csv - za normalne CSV datoteke sa zarezom kao razdvojnikom - read.csv2 - za alternativni CSV standard koji koristi toku-zarez Osnovni parametar ovih funkcija je staza do CSV datoteke koju uitavamo. Funkcije imaju i bogati niz dodatnih parametara koje omoguuju prilagodbu raznim scenarijima, a ukoliko smo dobili neki od egzotinijih oblika CSV datoteke, isplati se pogledati i funkciju read.table koja je vrlo fleksibilna glede broja razliitih parametara i postavki kod uitavanja podataka (read.csv i read.csv2 su zapravo izvedene iz funkcije read.table fiksiranjem odreenih parametara na standardne CSV znaajke). Neke od parametara i pripadajuih vrijednosti funkcija read.csv (ili read.table) koje je korisno znati su: header = FALSE - za datoteke bez zaglavlja sep = \"#\" - za datoteke koje koriste egzotini razdvojnik, u ovom sluaju # na.strings = \"NULL\" - naznaka koji standard podaci koriste za reprezentaciju nedostajuih vrijednosti a koji e u R-u postati NA nrows = 2000 - maksimalan broj redaka koji e se proitati, u ovom sluaju 2000 stringsAsFactors = F - sprjeavanje automatskog stvaranja faktorskih stupaca (o kojima emo uiti u nastavku ove lekcije) encoding = \"UTF-8\" - za standarde kodiranja teksta koji nisu ASCII (osobito bitno ako radimo sa podacima sa hrvatskog govornog podruja koji koriste dijakritike znakove) Pokuajmo sada uitati podatke iz dostupnih CSV datoteka. Ovi podaci nee zahtijevati posebne parametre te e se moi uitati samo pruanjem staze do pripadnih datoteka (jedne koja koristi zarez i druge koja koristi toku-zarez kao razdvojnik). Zadatak 4.2 - itanje podataka iz CSV datoteke # uitajte podatke iz datoteka `mjesto.csv` i `mjestoAlt.csv` # podatke spremite u okvire `mjesto2` i `mjesto3` # ispiite okvire `mjesto2` i `mjesto3` # uitajte podatke iz datoteka `mjesto.csv` i `mjestoAlt.csv` # podatke spremite u okvire `mjesto2` i `mjesto3` mjesto2 &lt;- read.csv(&quot;mjesto.csv&quot;) mjesto3 &lt;- read.csv2(&quot;mjestoAlt.csv&quot;) # ispiite okvire `mjesto2` i `mjesto3` mjesto2 cat(&quot;-----------\\n&quot;) mjesto3 ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 20000 Dubrovnik 5348 28434 10 ## ----------- ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 20000 Dubrovnik 5348 28434 10 Pogledajmo sada neke korisne funkcije za rad sa podatkovnim okvirima tj. tablicama. Dobar dio njih e nam ve otprije biti poznat iz iskustva u radu sa listama i matricama: nrow - broj redaka ncol ili length - broj stupaca (budui da se okvir ponaa i kao matrica i kao lista) dim - dimenzije tablice names - imena stupaca head - ispis nekoliko redaka s poetka tablice tail - ispis nekoliko redaka s kraja tablice str - ispis strukture tablice summary - saete statistike informacije o stupcima tablice Isprobajmo neke od ovih funkcija: Zadatak 4.3 - funkcije za rad sa podatkovnim okvirima # ispiite dimenzije tablice `mjesto` # ispiite strukturu tablice `mjesto` # ispiite prvih nekoliko redaka tablice `mjesto` # ispiite saete statistike informacije o stupcima tablice `mjesto` # ispiite dimenzije tablice `mjesto` dim(mjesto) cat(&quot;-----------\\n&quot;) # ispiite strukturu tablice `mjesto` str(mjesto) cat(&quot;-----------\\n&quot;) # ispiite prvih nekoliko redaka tablice `mjesto` head(mjesto) cat(&quot;-----------\\n&quot;) # ispiite saete statistike informacije o stupcima tablice `mjesto` summary(mjesto) ## [1] 5 5 ## ----------- ## &#39;data.frame&#39;: 5 obs. of 5 variables: ## $ pbr : num 10000 51000 21000 31000 2000 ## $ nazivMjesta : chr &quot;Zagreb&quot; &quot;Rijeka&quot; &quot;Split&quot; &quot;Osijek&quot; ... ## $ prosjPlacaKn : num 6359 5418 5170 4892 5348 ## $ brojStanovnika: num 790017 128384 167121 84104 28434 ## $ prirez : num 18 15 10 13 10 ## ----------- ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 2000 Dubrovnik 5348 28434 10 ## ----------- ## pbr nazivMjesta prosjPlacaKn brojStanovnika ## Min. : 2000 Length:5 Min. :4892 Min. : 28434 ## 1st Qu.:10000 Class :character 1st Qu.:5170 1st Qu.: 84104 ## Median :21000 Mode :character Median :5348 Median :128384 ## Mean :23000 Mean :5437 Mean :239612 ## 3rd Qu.:31000 3rd Qu.:5418 3rd Qu.:167121 ## Max. :51000 Max. :6359 Max. :790017 ## prirez ## Min. :10.0 ## 1st Qu.:10.0 ## Median :13.0 ## Mean :13.2 ## 3rd Qu.:15.0 ## Max. :18.0 4.2 Odabir redaka i stupaca podatkovnih okvira Ve smo rekli da se podatkovni okviri ponaaju i kao matrice i kao liste, to je svojstvo kojim se posebno esto sluimo kod odabira redaka i stupaca podatkovnih okvira. Konkretno, za rezanje okvira najee koristimo: dvodimenzionalno referenciranje uz pomo indeksnih vektora odabir pojedinog stupca uz pomo operatora $ Ovdje smo zapravo dosta fleksibilni - moemo npr. prvo izrezati odreene retke matrice uz pomo lokacijskog referenciranja i potom izdvojiti samo jedan stupac uz pomo operatora $. U praksi je jedna od najeih kombinacija uvjetni odabir redaka uz imenski odabir stupaca (poznavatelji SQL-a prepoznati e ovo kao standardnu kombinaciju WHERE uvjeta i SELECT liste). Pokuajmo primijeniti nae znanje o indeksnim vektorima, matricama i listama na rezanje podatkovnih okvira. Zadatak 4.4 - rezanje podatkovnih okvira # ispiite tablicu `mjesto` (za referencu) # ispiite prva tri retka, trei i peti stupac # ispiite stupac &quot;prirez&quot; # ispiite potanske brojeve i nazive svih mjesta koja # imaju prirez vei od 12% i broj stanovnika vei od 100,000 #ispiite tablicu `mjesto` (za referencu) mjesto cat(&quot;-----------\\n&quot;) #ispiite prva tri retka, trei i peti stupac mjesto[1:3, c(3,5)] cat(&quot;-----------\\n&quot;) #ispiite stupac &quot;prirez&quot; mjesto$prirez cat(&quot;-----------\\n&quot;) #ispiite potanske brojeve i nazive svih mjesta koji imaju # prirez vei od 12% i broj stanovnika vei od 100,000 mjesto[mjesto$prirez &gt; 12 &amp; mjesto$brojStanovnika &gt; 100000, c(&quot;pbr&quot;, &quot;nazivMjesta&quot;)] ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 2000 Dubrovnik 5348 28434 10 ## ----------- ## prosjPlacaKn prirez ## 1 6359 18 ## 2 5418 15 ## 3 5170 10 ## ----------- ## [1] 18 15 10 13 10 ## ----------- ## pbr nazivMjesta ## 1 10000 Zagreb ## 2 51000 Rijeka Uoite slinost izmeu zadnjeg izraza i SQL upita: ` SELECT pbr, nazivMjesta FROM mjesto WHERE mjesto.prirez &gt; 12 AND mjesto.brojStanovnika &gt; 100000 Odabir stupaca i redaka nije teak ako dobro baratamo znanjem o indeksnim vektorima, no kao to se vidi u zadnjem primjeru sintaksa esto nije previe itljiva (u usporedbi sa npr. SQL-ovom sintaksom koja obavlja isti posao). Zbog toga postoje razliita proirenja R-a koji ovaj posao uvelike olakavaju, a koja emo detaljno obraditi u jednoj od buduih lekcija koja e se baviti upravljanjem podatkovnim skupovima. 4.3 Dodavanje i brisanje redaka i stupaca Za dodavanje i brisanje redaka i stupaca opet se dovoljno sjetiti da je podatkovni okvir svojevrsni hibrid matrice i liste tj. ako znamo dodavati retke i stupce u matricu ili nove elemente u listu onda ekvivalentnim nainom moemo podatke dodavati i u podatkovni okvir. U radu sa podatkovnim okvirima neto ee dodajemo nove stupce (obino kao transformacije postojeih stupaca) nego retke tako da moemo primjere zapoeti sa dodavanjem stupaca. Kao to je reeno, stupce u podatkovni okvir dodajemo na isti nain kao to dodajemo elemente liste - uz panju da dodani stupac ima isti broj elemenata kao i ostali stupci. Novi stupci esto su izvedenice postojeih stupaca koje predstavljaju binarne indikatore, rezultate aritmetikih izraza podataka u drugim stupcima i sl. Zadatak 4.5 - dodavanje novih stupaca u tablicu # tablici `mjesto` dodajte logiki stupac `visokPrirez` # koji e pokazivati da li je prirez vei od 12% # pretpostavimo sljedei (fiktivni!) nain izrauna prireza # - mjesta imaju oko 60% radne populacije # - svaki radnik plaa porez koji je otprilike jednak 10% neto plae # - prirez kojeg radnik plaa raunamo kao (stopa prireza)*(iznos poreza) # # dodajte stupac `mjesecniPrihod` koji e uz pomo prosjene plae, prireza # i broja stanovnika procijeniti koliki prihod pojedino mjesto dobija od prireza # (izraeno u milijunima Kn) # iznos zaokruite uz pomo funkcije round ( primjer: round(100.12345, 2) ==&gt; 100.12 ) # ispiite tablicu mjesto # tablici `mjesto` dodajte logiki stupac `visokPrirez` # koji e pokazivati da li je prirez vei od 12% mjesto$visokPrirez &lt;- mjesto$prirez &gt; 12 # pretpostavimo sljedei (fiktivni!) nain izrauna prireza # - mjesta imaju oko 60% radne populacije # - svaki radnik plaa porez koji je otprilike jednak 10% neto plae # - prirez kojeg radnik plaa raunati emo (stopa prireza)*(iznos poreza) # # dodajte stupac `mjesecniPrihod` koji e uz pomo prosjene plae, prireza # i broja stanovnika procijeniti koliki prihod pojedino mjesto dobija od prireza # (izraeno u milijunima Kn) # iznos zaokruite uz pomo funkcije round ( primjer: round(100.12345, 2) ==&gt; 100.12 ) mjesto$mjesecniPrihod &lt;- round(0.6 * mjesto$brojStanovnika * 0.1 * mjesto$prosjPlacaKn * 0.01 * mjesto$prirez / 1e6 , 2) # ispiite tablicu mjesto mjesto ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez visokPrirez ## 1 10000 Zagreb 6359 790017 18 TRUE ## 2 51000 Rijeka 5418 128384 15 TRUE ## 3 21000 Split 5170 167121 10 FALSE ## 4 31000 Osijek 4892 84104 13 TRUE ## 5 2000 Dubrovnik 5348 28434 10 FALSE ## mjesecniPrihod ## 1 54.26 ## 2 6.26 ## 3 5.18 ## 4 3.21 ## 5 0.91 Retke i stupce smo takoer mogli dodati slino dodavanju redaka i stupaca u matricu - uz pomo funkcija rbind i cbind. Kod funkcije rbind obino dodajemo novi podatkovni okvir sa retcima koji imaju odgovarajui redoslijed i vrstu elemenata, dok kod funkcije cbind moemo dodati i obini vektor no moramo paziti da broj elemenata odgovara broju redaka originalnog okvira. Isprobajmo ove funkcije na malim umjetnim podatkovnim okvirima kako bi lake predoili njihovu funkcionalnost. Zadatak 4.6 - funkcije rbind/cbind i podatkovni okviri df1 &lt;- data.frame(a = c(1,2,3), b = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), c = c(T, F, T)) df2 &lt;- data.frame(a = 1, b = &quot;A&quot;, c = 3) #spojite df1 i df2 u podatkovni okvir df12 uz pomo funkcije `rbind` # okviru df12 dodajte stupac `imena` sa imenima Ivo, Ana, Pero i Stipe # koristite funkciju `cbind` # ispiite okvir df12 df1 &lt;- data.frame(a = c(1,2,3), b = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), c = c(T, F, T)) df2 &lt;- data.frame(a = 1, b = &quot;A&quot;, c = 3) #spojite df1 i df2 u podatkovni okvir df12 uz pomo funkcije `rbind` df12 &lt;- rbind(df1, df2) # okviru df12 dodajte stupac `imena` sa imenima Ivo, Ana, Pero i Stipe # koristite funkciju `cbind` df12 &lt;- cbind(df12, imena = c(&quot;Ivo&quot;, &quot;Ana&quot;, &quot;Pero&quot;, &quot;Stipe&quot;)) # ispiite okvir df12 df12 ## a b c imena ## 1 1 A 1 Ivo ## 2 2 B 0 Ana ## 3 3 C 1 Pero ## 4 1 A 3 Stipe Za brisanje redaka i stupaca takoer se moemo koristiti istim metodama za upravljanje matricama i listama. Konkretno: brisanje redaka i stupaca moemo obaviti dvodimenzionalnim referenciranjem redaka i stupaca koje elimo zadrati brisanje stupaca moemo obaviti pridjeljivanjem vrijednosti NULL odabranom stupcu Isprobajmo ovo na primjeru. Zadatak 4.7 - brisanje redaka i stupaca # obriite prvi redak i drugi stupac iz df12 metodom 2d referenciranja # obriite stupac `imena` uz pomo pridjeljivanja `NULL` vrijednosti # ispiite df12 # obriite prvi redak i drugi stupac iz df12 metodom 2d referenciranja df12 &lt;- df12[-1, -2] # obriite stupac `imena` uz pomo pridjeljivanja `NULL` vrijednosti df12$imena &lt;- NULL # ispiite df12 df12 ## a c ## 2 2 0 ## 3 3 1 ## 4 1 3 Podatkovnim okvirima emo se nastaviti baviti u poglavlju o upravljanju podatkovnim skupovima, gdje emo nauiti kako raditi sa okvirima sa daleko vie podataka od primjera koje smo koristili u ovoj lekciji, te kako raditi sa dodatnim paketima koji znaajno olakavaju este radnje nad podacima u podatkovnim okvirima. U nastavku emo se pozabaviti jo jednim novim (i poneto kontroverznim) tipom podatkovne strukture. 4.4 Faktori Faktor u R-u je zapravo tip podataka koji predstavlja ono onoga to se u statistici naziva nominalnom ili kategorijskom varijablom. Naime, atribut neke obzervacije esto poprima neku vrijednost iz skupa otprije poznatih kategorija (npr. varijabla spola, dobne kategorije, obrazovanja, mjesta roenja, stranake preferencije i sl.). Kategorije se esto identificiraju jedinstvenim nizom znakova, a u procesu analize uz pomo njih esto provodimo razna agregiranja i grupacije (npr. u nekoj utrci moemo gledati prosjeno vrijeme ovisno o spolu ili dobnoj kategoriji) ili pak dijelimo skup podataka ovisno o kategorijskoj pripadnosti. Faktori u R-u su esto i predmet rasprava budui da se radi o konstruktu koji moe olakati rad nad podacima, ali i uzrokovati brojne probleme, pogotovo ako nismo svjesni da u nekom trenutku radimo sa faktorom (ovaj scenarij se zapravo vrlo lako izbjegava, to emo objasniti na kraju ovog poglavlja). Za poetak emo predoiti to su zapravo faktori uz pomo jednostavnog primjera. Zamislimo da sljedei znakovni vektor opisuje razinu krvnog tlaka kod deset pacijenata: tlak &lt;- c(&quot;nizak&quot;, &quot;visok&quot;, &quot;visok&quot;, &quot;normalan&quot;, &quot;normalan&quot;, &quot;nizak&quot;, &quot;visok&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;normalan&quot;) Ovo je oito kategorijska varijabla budui da moe poprimiti jednu od tri diskretne vrijednosti - \"nizak\", \"normalan\" i \"visok\". Prema tome, ovaj vektor je tipian kandidat za faktoriziranje, tj. za pretvorbu u objekt klase factor. Faktorizaciju znakovnog vektora provodimo uz pomo funkcije factor kojoj prosljeujemo (u pravilu) znakovni vektor kao parametar. Zadatak 4.8 - faktoriziranje znakovnog vektora tlak &lt;- c(&quot;nizak&quot;, &quot;visok&quot;, &quot;visok&quot;, &quot;normalan&quot;, &quot;normalan&quot;, &quot;nizak&quot;, &quot;visok&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;normalan&quot;) # ispiite varijablu `tlak` # ispiite klasu varijable `tlak` # stvorite varijablu `tlak.f` koja e biti faktorizirana # inaica varijable `tlak` # ispiite varijablu `tlak.f` # ispiite klasu varijable tlak.f tlak &lt;- c(&quot;nizak&quot;, &quot;visok&quot;, &quot;visok&quot;, &quot;normalan&quot;, &quot;normalan&quot;, &quot;nizak&quot;, &quot;visok&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;normalan&quot;) # ispiite varijablu `tlak` tlak # ispiite klasu varijable `tlak` class(tlak) # stvorite varijablu `tlak.f` koja e biti faktorizirana # inaica varijable `tlak` tlak.f &lt;- factor(tlak) cat(&quot;-----------\\n&quot;) # ispiite varijablu `tlak.f` tlak.f # ispiite klasu varijable tlak.f class(tlak.f) ## [1] &quot;nizak&quot; &quot;visok&quot; &quot;visok&quot; &quot;normalan&quot; &quot;normalan&quot; &quot;nizak&quot; ## [7] &quot;visok&quot; &quot;nizak&quot; &quot;normalan&quot; &quot;normalan&quot; ## [1] &quot;character&quot; ## ----------- ## [1] nizak visok visok normalan normalan nizak visok nizak ## [9] normalan normalan ## Levels: nizak normalan visok ## [1] &quot;factor&quot; Vidimo da je ispis faktora dobio dodatni atribut Levels. To znai da se sada ovdje radi o pravoj kategorijskoj varijabli sa tono definiranim kategorijama koje smije poprimiti. Ako pokuamo dodati novu vrijednost u faktor koja nije zastupljena u trenutnim kategorijama (npr. prenizak) dobiti emo upozorenje, a umjesto kategorije koju smo naveli nova stavka imati e vrijednost NA. Ovo ponekad nije scenarij kojeg prieljkujemo. Ukoliko unaprijed znamo da znakovni vektor kojeg kategoriziramo ne sadri sve mogue kategorije koje se openito mogu pojaviti, imamo opciju dodavanja parametra levels u kojem emo uz pomo znakovnog vektora eksplicitno navesti niz moguih kategorija. Zadatak 4.9 - nezastupljene kategorije i parametar levels # dodajte 11. element u vektor `tlak.f` sa sadrajem &quot;prenizak&quot; # ispiite `tlak.f` # napravite varijablu `tlak.f2` uz pomo varijable `tlak` # kategorijske razine navedite eksplicitno tako da sadre # i kategorije &quot;prenizak&quot; i &quot;previsok&quot; # dodajte 11. element u vektor `tlak.f2` sa sadrajem &quot;prenizak&quot; # ispiite `tlak.f2` # dodajte 11. element u vektor `tlak.f` sa sadrajem &quot;prenizak&quot; tlak.f[11] &lt;- &quot;prenizak&quot; ## Warning in `[&lt;-.factor`(`*tmp*`, 11, value = &quot;prenizak&quot;): invalid factor level, ## NA generated # ispiite `tlak.f` tlak.f cat(&quot;-----------\\n&quot;) # napravite varijablu `tlak.f2` uz pomo varijable `tlak` # kategorijske razine navedite eksplicitno tako da sadre # i kategorije &quot;prenizak&quot; i &quot;previsok&quot; tlak.f2 &lt;- factor(tlak, levels = c(&quot;prenizak&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;visok&quot;, &quot;previsok&quot;)) # dodajte 11. element u vektor `tlak.f2` sa sadrajem &quot;prenizak&quot; tlak.f2[11] &lt;- &quot;prenizak&quot; # ispiite `tlak.f2` tlak.f2 ## [1] nizak visok visok normalan normalan nizak visok nizak ## [9] normalan normalan &lt;NA&gt; ## Levels: nizak normalan visok ## ----------- ## [1] nizak visok visok normalan normalan nizak visok nizak ## [9] normalan normalan prenizak ## Levels: prenizak nizak normalan visok previsok Koja je prednost faktora? Zato varijable ne bismo ostavili u originalnom, znakovnom obliku? Razlog potrebe za faktoriziranjem kategorijskih stupaca tj. varijabli je poglavito u tome to odreene statistike i vizualizacijske funkcije znaju na ispravan nain interpretirati i koristiti faktore te ih tretiraju drugaije od obinih znakovnih stupaca. Zbog toga je vrlo dobra dugorona strategija ve u poetku uenja R-a naviknuti se da kod rada sa podatkovnim okvirima faktoriziramo stupce koji su zaista kategorijske varijable (ali takoer i pripazimo da nemamo faktorizirane stupce koji nisu kategorijske varijable, to se moe dogaati ako nismo paljivi). Jedno od pitanja koje se esto pitamo vezano uz kategorijske varijable jest - kolika je zastupljenost pojedinih kategorija? Odgovor na ovo pitanje daje nam funkcija table kojoj prosljeujemo odabrani faktor. Zadatak 4.10 - funkcija table # ispiite zastupljenost pojedinih kategorija u faktoru `tlak.f2` # ispiite zastupljenost pojedinih kategorija u faktoru `tlak.f2` table(tlak.f2) ## tlak.f2 ## prenizak nizak normalan visok previsok ## 1 3 4 3 0 Funkcija table ne zahtijeva nuno faktor i uredno e raditi ak i sa znakovnim vektorom. No u tom sluaju ne bismo dobili informaciju o kategorijama koje nisu uope zastupljene. Kategorijska varijabla iz naih primjera zapravo ima prirodu tzv. ordinalne kategorijske varijable, to znai da kategorije imaju prirodni poredak (nizak tlak je manji od normalnog koji je manji od visokog). Ukoliko elimo, ovu injenicu moemo ugraditi u faktor kod njegove inicijalizacije, jednostavnim dodavanjem parametra ordered postavljenog na TRUE. Prednost ordinalnog faktora jest ta to nam omoguuje usporedbu vrijednosti faktora uz pomo usporednih operatora. Zadatak 4.11 - ordinalni faktor # napravite varijablu `tlak.f3` na isti nain kao i `tlak.f2` # ali uz dodatni parametar `ordered = TRUE` # pripazite da poredak kategorija odgovara ordinalnom rasporedu # ispiite `tlak.f3` # provjerite radi li se uistinu o ordinalnom faktoru # uz pomo funkcije `is.ordered` # provjerite da li je tlak prvog pacijenta # (okvirno) nii od tlaka treeg pacijenta # napravite varijablu `tlak.f3` na isti nain kao i `tlak.f2` # ali uz dodatni parametar `ordered = TRUE` # pripazite da poredak kategorija odgovara ordinalnom rasporedu tlak.f3 &lt;- factor(tlak, levels = c(&quot;prenizak&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;visok&quot;, &quot;previsok&quot;), ordered = TRUE) # ispiite `tlak.f3` tlak.f3 # provjerite radi li se uistinu o ordinalnom faktoru # uz pomo funkcije `is.ordered` is.ordered(tlak.f3) # provjerite da li je tlak prvog pacijenta # (okvirno) nii od tlaka treeg pacijenta tlak.f3[1] &lt; tlak.f3[3] ## [1] nizak visok visok normalan normalan nizak visok nizak ## [9] normalan normalan ## Levels: prenizak &lt; nizak &lt; normalan &lt; visok &lt; previsok ## [1] TRUE ## [1] TRUE Ve smo uvidjeli da je u R-u zapravo sve vektor - brojevi su jednodimenzionalni numeriki vektori, matrice su vektori sa dodanim parametrom dimenzionalnosti, liste su vektori malih listi, podatkovni okviri su liste za dodanom restrikcijom. Moemo se zapitati - to su zapravo faktori? Implementacijski, faktor je zapravo kodirani ili enumerirani skup vrijednosti inicijalno definiranih znakovnih nizova, uz pridruenu kodnu tablicu istih. Jednostavnije reeno, faktorizacija znakovnog vektora ukljuuje: popisivanje svih uoenih kategorija (ili preuzimanje eksplicitnog popisa iz parametra levels) pridjeljivanje numerikih vrijednosti redom svakoj kategoriji (npr: \"nizak\" -&gt; 1, \"normalan\" -&gt; 2 itd.) pakiranje novostvorenog numerikog vektora i pripadajue kodne tablice Iako ove korake R radi automatski, u internu strukturu faktora moemo se uvjeriti ako faktor probamo pretvoriti u isti numeriki, odnosno isti znakovni tip. Zadatak 4.12 - interna struktura faktora # ispiite vrijednost varijable tlak.f3 pretvorene u znakovni tip # ispiite vrijednost varijable tlak.f3 pretvorene u numeriki tip # ispiite vrijednost varijable tlak.f3 pretvorene u znakovni tip as.character(tlak.f3) # ispiite vrijednost varijable tlak.f3 pretvorene u numeriki tip as.numeric(tlak.f3) ## [1] &quot;nizak&quot; &quot;visok&quot; &quot;visok&quot; &quot;normalan&quot; &quot;normalan&quot; &quot;nizak&quot; ## [7] &quot;visok&quot; &quot;nizak&quot; &quot;normalan&quot; &quot;normalan&quot; ## [1] 2 4 4 3 3 2 4 2 3 3 Pretvaranjem faktora u znakovni tip zapravo radimo operaciju inverzne faktorizacije, tj. moemo se vratiti na izvorni znakovni vektor. S druge strane, pretvaranjem faktora u numeriki tip, dobit emo popis kodiranih brojeva kojima se interni faktor koristi za predstavljanje svake kategorije. Sada se moe postaviti jedno pitanje - ima li ikakve koristi od pretvaranja faktora u njegovu znakovnu ili numeriku kopiju? Openiti odgovor bio bi - ne. Varijable faktora automatski e se ponaati kao znakovi gdje god je to potrebno (na primjer ako elimo filtrirati sva imena s tri slova). S druge strane, interni numeriki prikaz je besmislen bez dodatne informacije kojoj kategoriji dani broj zapravo pripada. Meutim, saznanje to se dogaa kada pretvaramo faktor u znakovni ili numeriki vektor moe nam pomoi da izbjegnemo posebno nezgodnu pogreku do koje moe doi ako analitiar pogreno rukuje faktorskim varijablama. Dobra je vijest da je izlaskom inaice R 4.0 mogunost ove pogreke znatno smanjena, ali jo uvijek vrijedi znati to ona podrazumijeva i kako je izbjei. Pogreka o kojoj je rije dogaa se kada je numeriki stupac pogreno identificiran kao kategoriki stupac, to je prije inaice R 4.0 bila relativno esta pojava kada je analitiar dopustio R-u da automatski zakljui vrste stupaca koji se uitavaju iz vanjskog izvora podataka. Obzirom da je nazivna vrijednost parametra stringsAsFactors bila TRUE, ukoliko se ovaj parametar nije naveo R-ov algoritam prepoznavanja tipa stupaca bi prvo razdvojio radi li se o numerikim ili znakovnim stupcima, a potom bi se znakovni stupci automatski faktorizirali. Zato bi ovo predstavljalo problem? Pogledajmo sljedei primjer, gdje imamo runo unesene tabline podatke gdje jedan unos ima pogreku ( 7.07 je grekom umetnut kao 7.O7). Simulirajmo to se moglo dogoditi u starijim verzijama R-a. 4.4.1 Primjer 4.1 - problem automatske kategorizacije # simulirana &quot;pogreka runog unosa&quot; df &lt;- data.frame(id = 1:5, measures = c(&quot;1.45&quot;, &quot;5.77&quot;, &quot;1.12&quot;, &quot;7.O7&quot;, &quot;3.23&quot;), stringsAsFactors = TRUE) # imitiramo ponaanje starijih inaica R-a # analitiar rauna prosjek mjera, uoava neobino ponaanje mean(df$measures) ## Warning in mean.default(df$measures): argument is not numeric or logical: ## returning NA # sumnjajui na problem s tipom podatka, analitiar radi # eksplicitnu konverziju stupca u numeriki df$measures &lt;- as.numeric(df$measures) # mjere se zamjenjuju numerikim identifikatorima &quot;kategorija&quot; # stvarni iznosi mjera se nepovratno gube # daljnji numeriki izrauni sa ovim stupcem nee rezultirati grekom # ali e biti besmisleni df ## [1] NA ## id measures ## 1 1 2 ## 2 2 4 ## 3 3 1 ## 4 4 5 ## 5 5 3 Zadaci za vjebu U mapi zajedno sa ovom biljenicom pronaite datoteku mjestoNOHEADER.csv koja predstavlja datoteku istovjetnu datoteci mjesto.csv osim sljedeih znaajki: nedostaju imena stupaca koriten je razmak kao razdvojnik Pokuajte uz pomo dokumentacije uitati podatke iz ove datoteke u varijablu mjestoNH koja e biti istovjetna varijabli mjesto koritenoj u lekciji. U mapi zajedno sa ovom biljenicom pronaite datoteku racun.csv i uitajte ju u varijablu racun. Pripazite da nizovi znakova nisu automatski pretvoreni u faktore. Ispiite na zaslon: broj redaka ove tablice broj stupaca tablice imena stupaca tablice Za tablicu racun napravite sljedee: faktorizirajte stupac katArtikl ispiite ifru, naziv i cijenu svih artikala kategorije slatkisi i grickalice jeftinijih od 12 Kn ispiite koliko proizvoda koje kategorije se nalazi u raunu dodajte stupac ukupno koji e sadravati ukupnu cijenu pojedine stavke uraunavajui i cijenu i koliinu izraunajte ukupni iznos rauna Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["kontrola.html", "5 Kontrola toka i objekti 5.1 Naredbe kontrole toka Zadaci za vjebu", " 5 Kontrola toka i objekti 5.1 Naredbe kontrole toka Pod naredbama kontrole toka smatramo uglavnom konstrukte za uvjetno izvoenje naredbi i/ili tzv. programske petlje gdje se segment programa kontinuirano izvodi sve do (opcionalnog) ispunjavana odreenih uvjeta koji e rezultirati izlaskom iz petlje i nastavljanjem programa. 5.1.1 Uvjetno izvoenje naredbi Uvjetno izvoenje naredbi ve smo upoznali. Radi se o konstruktu if (uvjet) { blok } else { blok } pri emu se vitiaste zagrade mogu izbaciti ako imamo samo jednu uvjetnu naredbu. Ovdje je moda zgodno napomenuti kako izbjei jednu relativno estu poetniku greku kod pisanja if naredbe. Pokuajte ju samostalno uoiti i ispraviti u sljedeem primjeru. Zadatak 5.1 - naredba if # izvrite sljedeu naredbu uvjetnog izvoenja if (2 &gt; 1) print(&quot;Uspjeh!&quot;) # pronaite greku u sljedeoj `if-else` naredbi i ispravite ju if (1 &gt; 2) print(&quot;Uspjeh!&quot;) else print(&quot;Neuspjeh!&quot;) # izvrite sljedeu naredbu uvjetnog izvoenja if (2 &gt; 1) print(&quot;Uspjeh!&quot;) # pronaite greku u sljedeoj `if-else` naredbi i ispravite ju if (1 &gt; 2) { print(&quot;Uspjeh!&quot;) } else print(&quot;Neuspjeh!&quot;) ## [1] &quot;Uspjeh!&quot; ## [1] &quot;Neuspjeh!&quot; Greka se javlja zbog toga to je R interpreterski jezik koji se u pravilu izvrava redak po redak, osim u sluajevima kada smo R-u proslijedili nedovrenu naredbu pri emu e on ekati na ostatak prije no to krene sa izvravanjem. U prethodnom primjeru druga naredba if je zapravo zavrena u prvom retku, tako da se R iznenadi kada idui redak poinje sa else. Kako bi sprijeili ovaj scenarij, dovoljno je na nekim nain objasniti R-u da naredba jo nije dovrena, to je najlake izvesti otvaranjem bloka u prvom retku i zatvaranjem u retku sa else. itateljima koji programiraju u jezicima C ili Java biti e poznat pojam tzv. ternarnog operatora koji zapravo predstavlja kompaktnu verziju if-else bloka: x = (a &lt; b) ? c : d # nije primjer iz jezika R! Ulogu ovog operatora u R-u obavlja funkcija ifelse. Zadatak 5.2 - funkcija ifelse a &lt;- 1:3 b &lt;- c(0, 2, 4) # kako izgleda vektor `x` nakon izvravanja sljedee naredbe? # razmislite o odgovoru a potom provjerite ispravnost rjeenja x &lt;- ifelse(a &lt; b, 2, 5) x &lt;- ifelse(a &lt; b, 2, 5) x ## [1] 2 2 2 2 Uoite da je funkcija ifelse (oekivano) vektorizirana, zbog ega je posebno pogodna za stvaranje novih stupaca podatkovnih okvira koji su izvedeni iz odreenih uvjeta vezanih uz postojee stupce. 5.1.2 Programske petlje U programskom jeziku R imamo tri tipa petlji: repeat - beskonana petlja while - petlja s provjerom uvjeta na poetku for - iteratorska petlja (petlja s poznatim brojem ponavljanja) 5.1.3 Petlja repeat Petlja repeat je najjednostavnija petlja. Ona ima sljedeu sintaksu: repeat {blok} Ovdje se radi o beskonanoj petlji gdje se nakon zavretka bloka on ponovo izvrava i tako unedogled. Jedini nain izlaska iz ovakve petlje jest koritenje naredbe break. Pored ove naredbe imamo i naredbu next koja e preskoiti ostatak bloka, ali nee izai iz petlje ve e nastaviti izvravati blok. Pogledajmo kako radi ova petlja u sljedeoj vjebi. Zadatak 5.3 - Petlja repeat # prije izvravanja sljedeeg bloka odgovorite na pitanja: # - hoe li se petlja izvravati beskonano? # - to e se ispisati na zaslonu? i &lt;- 1 repeat { i &lt;- i + 1 if (i %% 2 == 0) next print(i) if (i &gt; 10) break } ## [1] 3 ## [1] 5 ## [1] 7 ## [1] 9 ## [1] 11 esto unaprijed znamo uvjet izlaska iz petlje te bismo ga htjeli staviti na jasno vidljivo mjesto tako da nije skriven u tijelu petlje. Za to nam pomae tzv. while petlja. 5.1.4 Petlja while Petlja while predstavlja najii oblik programske petlje ija sintaksa doslovno glasi dok je uvjet ispunjen, ponavljaj navedeni kod: while (uvjet) {blok} Zadatak 5.4 - Petlja while # dodajte uvjet petlje tako da se ona izvri # tono 7 puta i &lt;- 1 while() { print(i) i &lt;- i+1 } # dodajte uvjet petlje tako da se ona izvri # tono 7 puta i &lt;- 1 while(i &lt;= 7) { print(i) i &lt;- i+1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 Kod ove petlje moramo paziti da se u odreenoj iteraciji moraju stvoriti uvjeti za izlaz, inae ona takoer postaje beskonana petlja. Usprkos tome to imamo jasno definiran nain izlaska iz petlje, mi i u ovoj petlji moemo slobodno koristiti kljune rijei next i break, koje imaju istu funkciju kao i kod petlje repeat. Isprobajmo ovu petlju u neto sloenijem zadataku. Zadatak 5.5 - Petlja while (2) n &lt;- 1234 nbin &lt;- numeric(0) # napunite vektor `nbin` znamenkama `n` pretvorenog u binarni oblik # primjer: ako je `n` bio 12, `nbin` bi trebao biti c(1,1,0,0) # koristite se petljom `while` # naputak: prouite kako radi funkcija `rev` koja se u ovom zadatku moe pokazati korisnom # ispiite `nbin` na zaslon n &lt;- 1234 nbin &lt;- numeric(0) while (n != 0) { nbin &lt;- c(nbin, n %% 2) n &lt;- n %/% 2 } nbin &lt;- rev(nbin) nbin ## [1] 1 0 0 1 1 0 1 0 0 1 0 5.1.5 Petlja for Petlja for ili iteratorska petlja slui za lako etanje po nekoj programskoj strukturi (najee vektoru), uzimajui element po element i neto radei s njim. Ona koristi kljunu rije for, ime nove (iteratorske) varijable, kljunu rije in te vektor ije vrijednosti se uzimaju jedna po jedna i koriste unutar petlje (uoite da navedeni in nije isto to i operator %in% koji provjerava da li se neki element nalazi u nekom skupu!). Sintaksa ove petlje je sljedea: for (i in v) {radi neto sa i} Uoimo da ovdje varijabla i nije broja - u svakoj iteraciji petlje ona postaje vrijednost elementa do kojeg smo doli. Ukoliko ba elimo iterirati po indeksima, a ne po samim elementima, onda moemo koristiti konstrukt for (i in 1:length(a)). Trea varijanta jest iteriranje po imenima (ako smo definirali imena elemenata vektora) - for (i in names(a). Zadatak 5.6 - Petlja for a &lt;- seq(-10, 10, 4) # ispiite elemente vektora `a` jedan po jedan # uz pomo petlje `for` # pristupajte elementima direktno # ponovite isto ali iterirajte po indeksima a &lt;- seq(-10, 10, 4) # ispiite elemente vektora `a` jedan po jedan # uz pomo petlje `for` # pristupajte elementima direktno for (i in a) print(i) # ponovite isto ali iterirajte po indeksima for (i in 1:length(a)) print(a[i]) ## [1] -10 ## [1] -6 ## [1] -2 ## [1] 2 ## [1] 6 ## [1] 10 ## [1] -10 ## [1] -6 ## [1] -2 ## [1] 2 ## [1] 6 ## [1] 10 Uoite da je drugi nain bolji ako elite mijenjati elemente vektora ili imati informaciju na kojem mjestu unutar originalnog vektora se trenutno nalazite. Isprobajmo i ovu petlju na malo sloenijem primjeru. Zadatak 5.7 - Petlha for (2) # proitajte podatke iz datoteke &quot;people.csv&quot; u podatkovni okvir `people` # potom uz pomo petlje `for` za svaki numeriki stupac # ispiite njegov naziv i aritmetiku sredinu njegovih vrijednosti (funkcija `mean`) # proitajte podatke iz datoteke &quot;people.csv&quot; u podatkovni okvir `people` # potom uz pomo petlje `for` za svaki numeriki stupac # ispiite njegov naziv i aritmetiku sredinu njegovih vrijednosti (funkcija `mean`) people &lt;- read.csv(&quot;people.csv&quot;) for (i in 1:length(people)) { if (is.numeric(people[[i]])) { print(names(people)[i]) print(mean(people[[i]])) } } ## [1] &quot;birthyear&quot; ## [1] 1978.404 ## [1] &quot;weight&quot; ## [1] 75.1223 ## [1] &quot;height&quot; ## [1] 160.5191 Pripazite na razliku izmeu operatora [ i [[. Takoer, uoite kako smo koritenjem pozicijskom iteriranja i funkcije names lako doli do imena stupca, to ne bi bilo toliko jednostavno da smo se odluili na iteriranje po samim stupcima. Sad kad smo nauili sintaksu petlji vano je naglasiti jednu injenicu - u programskom jeziku R u pravilu se ne preporuuje koritenje programskih petlji . Iako ovo inicijalno moda djeluje neoekivano i pomalo okantno, razlog je jednostavan - R je jezik dizajniran upravo da radi po principu sve odjednom. Ve smo vidjeli da principu vektoriziranosti i recikliranja uinkovito obavljaju poslove koji bi u drugim programskim jezicima zahtijevali petlju, a u poglavljima koje slijede vidjet emo da R nudi i mnoge druge konstrukte koji izbjegavaju eksplicitno ponavljanje koda uz uvjet nautrb deklarativne sintakse koja to obavlja automatski. Na primjer, sljedei primjer je sintaksno potpuno ispravan: # primjer nepotrebnog koritenja petlje a &lt;- 1:5 b &lt;- 6:10 c &lt;- numeric() for (i in 1:length(a)) c[i] &lt;- a[i] + b[i] ali vjerojatno radi sporije i puno je neitljiviji od: # R-ovska sintaksa a &lt;- 1:5 b &lt;- 6:10 c &lt;- a + b Sve navedeno naravno ne znai da petlje u R-u ne smijemo koristiti, samo da bi njihovo koritenje trebalo biti popraeno dodatnim razmatranjem da li je na tom mjestu petlja zaista potrebna te da li postoji alternativna sintaksa koji isti posao obavlja deklarativno (i potencijalno bre, budui da su mnoge rutine R-a implementirane u jeziku C). Rano prihvaanje R-ovskog naina razmiljanja rezultirati e dugoronim benefitom koji e se oitovati kompaktnijim, iim i esto uinkovitijim programskim kodom. Zadaci za vjebu Stvorite podatkovni okvir mjesto uz pomo sljedee naredbe: mjesto &lt;- data.frame( pbr = c(10000, 51000, 21000, 31000, 2000), nazivMjesta = c(&quot;Zagreb&quot;, &quot;Rijeka&quot;, &quot;Split&quot;, &quot;Osijek&quot;, &quot;Dubrovnik&quot;), prirez = c(18, 15, 10, 13, 10)) Dodajte ovom okviru stupac prirezOpis koji e biti ordinalna faktorska varijabla sa razinama \"mali\", \"srednji\" i \"visok\" ovisno o tome da li je postotak prireza strogo manji od 12, izmeu 12 i 15 ili strogo vei od 15. Koristite se naredbom ifelse. Zamijenite petlje u sljedeem bloku ekvivalentnim vektoriziranim operacijama (za drugu petlju prouite dokumentaciju funkcije sum). a &lt;- numeric() i &lt;- 1 while (i &lt;= 100) { a &lt;- c(a, i) i &lt;- i + 1 } suma &lt;- 0 for (i in a) { if (i %% 2 == 0) suma &lt;- suma + i*i } print(suma) Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["paketi.html", "6 Paketi, ugraene funkcije i okoline 6.1 Rad s paketima 6.2 Ugraene funkcije 6.3 Okoline Zadaci za vjebu", " 6 Paketi, ugraene funkcije i okoline 6.1 Rad s paketima Standardna R distribucija dolazi sa dvije kolekcije paketa (nazvanih r-base i r-recommended) koje sadre svojevrsnu jezgru jezika R - skup elemenata dostatnih za provoenje standardnih tipova podatkovnih analiza uz pomo programskog jezika R. Uz to, CRAN (Comprehensive R Archive Network) predstavlja bogati repozitorij dodatnih paketa za najrazliitije primjene, od popravljanja osnovnih elemenata jezika R do strogo specijaliziranih paketa za posebne tipove analiza. Kao to je uobiajena praksa u drugim programskim jezicima, R koristi sustav paketa ili biblioteka (engl. package ili library) kako bi logiki organizirao ve isprogramirane kolekcije podataka, skupova i prevedenog programskog koda. Kod podizanja R okoline automatski se uitavaju odreeni paketi u radnu memoriju ime njihovi elementi postaju dostupni za koritenje. Popis uitanih paketa moemo dobiti koritenjem funkcije search. Zadatak 6.1 - staza pretrage # pozovite funkciju `search` (bez parametara) i pogledajte koji paketi su uitani u okolinu # pozovite funkciju `search` (bez parametara) i pogledajte koji paketi su uitani u okolinu search() ## [1] &quot;.GlobalEnv&quot; &quot;package:kernlab&quot; &quot;package:ranger&quot; ## [4] &quot;package:caret&quot; &quot;package:e1071&quot; &quot;package:corrplot&quot; ## [7] &quot;package:broom&quot; &quot;package:car&quot; &quot;package:carData&quot; ## [10] &quot;package:Hmisc&quot; &quot;package:Formula&quot; &quot;package:survival&quot; ## [13] &quot;package:lattice&quot; &quot;package:sn&quot; &quot;package:stats4&quot; ## [16] &quot;package:gridExtra&quot; &quot;package:RSQLite&quot; &quot;package:hflights&quot; ## [19] &quot;package:lubridate&quot; &quot;package:GGally&quot; &quot;package:forcats&quot; ## [22] &quot;package:stringr&quot; &quot;package:dplyr&quot; &quot;package:purrr&quot; ## [25] &quot;package:readr&quot; &quot;package:tidyr&quot; &quot;package:tibble&quot; ## [28] &quot;package:ggplot2&quot; &quot;package:tidyverse&quot; &quot;package:MASS&quot; ## [31] &quot;package:stats&quot; &quot;package:graphics&quot; &quot;package:grDevices&quot; ## [34] &quot;package:utils&quot; &quot;package:datasets&quot; &quot;package:methods&quot; ## [37] &quot;Autoloads&quot; &quot;package:base&quot; Vidimo da veina paketa ima svoju stavku oblika \"package:ime_paketa\". Raspored paketa predstavlja i njihov prioritet glede pretrage imenskog podruja, o emu e vie rijei biti kasnije. Ukoliko elimo uitati novi paket u nau okolinu, to moemo izvesti uz pomo funkcije library kojoj dajemo ime paketa (bez navodnika). Zadatak 6.2 - uitavanje paketa u radnu okolinu # uitajte paket `dplyr` u R okolinu # uitajte paket `dplyr` u R okolinu library(dplyr) Naredba iz prethodnog primjera moe imati dva ishoda: ukoliko paket postoji na lokalnom raunalu (u mapi predodreenoj za dodatne pakete), on e biti uitan u radnu okolinu. Uitavanje paketa moe biti popraeno porukama o objektima koji su nakon uitavanja maskirani. To konkretno znai da je novi paket privremeno uskratio dostupnost pojedinim elementima iz ranije uitanih paketa iz razloga to im se podudaraju imena. Ovo esto ne predstavlja nikakav problem, ali ukoliko korisnik ima potrebu za pristupom maskiranim elementima morati e koristiti njihovo puno ime tj. morati e navesti i ime paketa gdje se nalaze. Na primjer, ako je funkcija filter iz paketa stats maskirana nakon uitavanja novog paketa, ona je i dalje dostupna preko punog imena stats::filter ali ne direktno preko filter, budui da e to pozivati funkciju iz najnovije uitanog paketa. Vie detalja o tome kako R razrjeava nazive varijabli i funkcija biti e dano u nastavku ove lekcije. Ukoliko na lokalnom raunalu nemamo navedeni paket dobivamo poruku o greci da taj paket ne postoji. U tom sluaju potrebno je prvo dohvatiti paket iz CRAN repozitorija uz pomo funkcije install.packages kojoj dajemo naziv jednog ili vie paketa (s navodnicima!) kao parametre. Navedena funkcija pretpostavlja da R okolina ima definiran CRAN mirror tj. konkretnu adresu CRAN repozitorija odakle e se paket dohvatiti. Veliki broj drava ima svoju kopiju CRAN repozitorija, no naalost Republika Hrvatska iz nejasnih razloga vie nema svoj CRAN repozitorij te u trenutku pisanja ove biljenice nema pokazatelja da e se isti uspostaviti. Ako radimo u suelju RStudio, CRAN repozitorij smo vrlo vjerojatno postavili kod prvog pokretanja, (tj. odabrali smo opciju Global koja nae zahtjeve za instaliranjem paketa automatski prosljeuje najbliem CRAN repozitoriju) no ako to nismo obavili ili radimo u nekom drugom razvojnom suelju onda uz pomo dokumentacije moramo potraiti nain postavljanja CRAN repozitorija ako elimo uitavati dodatne pakete. Zadatak 6.3 - instalacija paketa sa CRAN repozitorija # instalirajte paket `hflights` sa CRAN repozitorija # (ovo moete uiniti ak i ako ve imate navedeni paket) # uitajte paket u radnu okolinu # ispiite stazu pretrage # instalirajte paket `hflights` sa CRAN repozitorija # (ovo moete uiniti ak i ako ve imate navedeni paket) install.packages(&quot;hflights&quot;) # uitajte paket u radnu okolinu library(dplyr) # ispiite stazu pretrage search() ## [1] &quot;.GlobalEnv&quot; &quot;package:kernlab&quot; &quot;package:ranger&quot; ## [4] &quot;package:caret&quot; &quot;package:e1071&quot; &quot;package:corrplot&quot; ## [7] &quot;package:broom&quot; &quot;package:car&quot; &quot;package:carData&quot; ## [10] &quot;package:Hmisc&quot; &quot;package:Formula&quot; &quot;package:survival&quot; ## [13] &quot;package:lattice&quot; &quot;package:sn&quot; &quot;package:stats4&quot; ## [16] &quot;package:gridExtra&quot; &quot;package:RSQLite&quot; &quot;package:hflights&quot; ## [19] &quot;package:lubridate&quot; &quot;package:GGally&quot; &quot;package:forcats&quot; ## [22] &quot;package:stringr&quot; &quot;package:dplyr&quot; &quot;package:purrr&quot; ## [25] &quot;package:readr&quot; &quot;package:tidyr&quot; &quot;package:tibble&quot; ## [28] &quot;package:ggplot2&quot; &quot;package:tidyverse&quot; &quot;package:MASS&quot; ## [31] &quot;package:stats&quot; &quot;package:graphics&quot; &quot;package:grDevices&quot; ## [34] &quot;package:utils&quot; &quot;package:datasets&quot; &quot;package:methods&quot; ## [37] &quot;Autoloads&quot; &quot;package:base&quot; Napomena: u pravilu pakete instaliramo samo jednom i to preko konzole tako da nikad nema potrebe naredbe za instalaciju paketa ugraivati u R Markdown dokumente; takoer, zbog lake organizacije izvjetaja, uitavanje svih potrebnih paketa se po konvenciji obavlja na poetku dokumenta, u isjeku koda nazvanom setup. Uoimo da e instalacija i uitavanje paketa automatski sa sobom povui i uitavanje svih paketa koji su preduvjeti za koritenje traenog paketa, to uvelike olakava rad korisniku koji se ne mora brinuti o tome to dodatno treba instalirati kako bi mogao koristiti elemente paketa. Ako elimo saznati vie informacija o nekom paketu, to takoer moemo izvesti uz pomo funkcije library uz parametar help postavljen na ime paketa. library(help = dplyr) # preporuka: isprobati direktno u konzoli Jo jedan prilino popularan nain dokumentiranja paketa je uz pomo tzv. vinjeta (engl. vignettes). Vinjete su zapravo mini-tutorial nekog paketa u HTML obliku koji slui za predstavljanje funkcionalnosti paketa na pristupaan, itljiv nain uz pomo detaljnih objanjenja i pripadajueg programskog koda. Moemo pogledati koje vinjete su instalirane na sustav pozivom funkcije browseVignettes() bez parametara (ili opcionalno dodati kao parametar imena paketa ako nas zanimaju samo njegove vinjete). Ako paket ima samo jednu vinjetu (npr. paket stringr). Moemo takoer odmah otvoriti vinjetu uz pomo funkcije vignette(ime_paketa). vignette(&quot;stringr&quot;) # preporuka: isprobati direktno u konzoli 6.2 Ugraene funkcije U prethodnim poglavljima ve smo upoznali neke od gotovih funkcija koje dobijamo zajedno sa naom R distribucijom. To su npr. numerike funkcije (log, abs, sqrt, round i sl.), funkcije za stvaranje vektora (rep, seq i sl.), funkcije za rad s paketima (install.packages, library i sl.) i tako dalje. U R-u se rijetko govori o ugraenim funkcijama budui da - kao to je ve prikazano - R okolina automatski uitava neke esto koritene pakete iji su elementi odmah dostupni za koritenje, bez nunog navoenja imena paketa u kojem se nalaze. Npr. paket stats sadri bogati skup funkcija vezanih uz statistike obrade. Jedna od tih funkcija je i rnorm koja vraa numeriki vektor eljene duljine iji su elementi nasumino odabrani iz normalne distribucije sa aritmetikom sredinom 0 i standardnom devijacijom 1 (ove vrijednosti moemo i promijeniti uz pomo parametara mean i sd). Ukoliko elimo, ovu funkciju moemo pozvati uz pomo sintakse ime_paketa::ime_funkcije(parametri). Zadatak 6.4 - poziv funkcije iz definiranog paketa # stvorite vektor x koji e imati 10 sluajnih elemenata # izvuenih iz standardne normalne distribucije # koristite puni naziv funkcije `rnorm` iz paketa `stats` # zaokruite elemente vektora x na dvije decimale # koristite puni naziv funkcije `round` iz paketa `base` # ispiite vektor x # stvorite vektor x koji e imati 10 sluajnih elemenata # izvuenih iz standardne normalne distribucije # koristite puni naziv funkcije `rnorm` iz paketa `stats` x &lt;- stats::rnorm(10) # zaokruite elemente vektora x na dvije decimale # koristite puni naziv funkcije `round` iz paketa `base` x &lt;- base::round(x, 2) # ispiite vektor x x ## [1] 0.04 0.11 1.43 0.98 -0.62 -0.73 -0.52 -1.75 0.88 1.37 Iako je ovo sintaksno korektan nain pozivanja funkcije, R nam omoguuje da izuzmemo nazive paketa i jednostavno navedemo samo naziv funkcije. Zadatak 6.5 - poziv funkcije bez imena paketa # stvorite vektor y po istom principu kao i vektor x # obavite sve u jednom retku # koristite nazive funkcija bez naziva paketa # ispiite y # stvorite vektor y po istom principu kao i vektor x # obavite sve u jednom retku # koristite nazive funkcija bez naziva paketa y &lt;- round(rnorm(10), 2) # ispiite y y ## [1] -1.69 -0.63 0.02 0.71 -0.65 0.87 0.38 0.31 0.01 -0.04 Moemo se zapitati - kako R zna gdje se nalazi funkcija koju elimo pozvati, ako nismo eksplicitno uitali niti naveli paket koji sadri tu funkciju? Toan razlog objasniti emo u iduem poglavlju koje se bavi okolinama i ve vienom stazom pretrage. Popisivanje svih dostupnih funkcija, pa ak i onih ee koritenih, bilo bi redundantno budui da se R jezik najbolje ui uz konkretnu primjenu, pri emu nakon odreenog vremena koritenja korisnik polako oformi vlastiti skup funkcija koje predstavljaju njegov uobiajeni alat za analize. U svakom sluaju, svakako se preporuuje odabir nekog od javno dostupnih R podsjetnika (reference card ili cheat sheet) koji e onda uvijek biti pri ruci za vrijeme R programiranja. Pojedini R podsjetnici dostupni su i na samom CRAN-u (dovoljno je upisati CRAN reference card u trailicu i pregledati rezultate), no ovdje emo iskoristiti priliku i preporuiti izvrsne alabahtere na stranicama suelja RStudio dostupne na sljedeoj poveznici: https://www.rstudio.com/resources/cheatsheets/ (alternativno, upiite RStudio cheat sheets u trailicu). Ovi podsjetnici sadrajno pokrivaju veinu korisnih stvari vezanih uz openite elemente jezika R (Base R, Advanced R) ali i konkretne pakete koje emo kasnije upoznati (dplyr, ggplot2) te predstavljaju vrlo vrijedne resurse kako za uenje R-a, tako i za dugorono koritenje. Za lake praenje lekcija koje slijede, preporuujemo ispis navedenih podsjetnika i upoznavanje sa elementima koje sadravaju, budui da se predstavlja o dugorono korisnom pomagalu za programiranje u jeziku R. Za kraj, spomenimo da nam R omoguuje brzo dohvaanje pomoi o funkciji jednostavnim pozivom ?ime_funkcije ili help(ime_funkcije) te da moemo dobiti primjere koritenja funkcije kroz example(ime_funkcije). Ove pozive bismo trebali vrlo esto koristiti ak i ako smatramo da smo dobro upoznati sa funkcijom koju pozivamo - lako je mogue da postoji neki dodatni parametar (ili srodna funkcija koje se takoer esto navode u dokumentaciji) a koji e nam dodatno pomoi u obavljanju zadatka zbog kojeg funkciju i koristimo. 6.3 Okoline Kao to je ve reeno, rad u R-u svodi se na upravljanje razliitim objektima. Kako bismo uope mogli upravljati tim objektima, potrebni su nam mehanizmi uz pomo kojih referenciramo dotine objekte. U R-u se to zove povezivanje (engl. binding). Kada stvorimo varijablu x numerikog tipa i njoj pridruimo broj 5, mi smo zapravo stvorili (jednoelementni) numeriki vektor i povezali taj podatak sa nizom znakova \"x\" kojeg potom moemo koristiti za daljnje referenciranje tog podatka (ili tih podataka). Stoga, kada elimo pristupiti nekoj varijabli, R mora pretraiti svoj interni zapisnik koje varijable trenutno postoje, kojeg su tipa te kako im pristupiti. Kako bi R pronaao varijablu, on koristi mehanizam zvan leksiko uokviravanje (engl. lexical scoping) koji se temelji na konceptu zvanom okoline (engl. environments). Okolina se esto naziva vreom za nazive (engl. bag of names). Ona nam pomae da logiki grupiramo nazive objekata koje koristimo i da pomognemo R-u nai naziv u drugim okolinama ako isti ne postoji u trenutnoj okolini. Ovo potonje je omogueno na nain da (gotovo) svaka okolina ima poveznicu na svoju okolinu-roditelja (engl. parent environment). Ovakav sustav poveznica na okoline-roditelje stvara svojevrsnu hijerarhiju okolina koja se esto naziva i staza pretrage (engl. search path); R, traei zadano ime varijable, pretrauje okoline uzlazno sve dok ne pronae prvu pojavu traenog naziva ili naleti na krajnju okolinu bez roditelja (tzv. prazna okolina - engl. empty environment). Ono to je interesantno jest injenica da je i sama okolina objekt - moemo stvoriti referencu na nju, slati ju u funkcije i sl. Osnovna okolina u kojoj radimo i u kojoj stvaramo nove varijable je tzv. globalna okolina, ili .GlobalEnv (paziti na toku!). Ona je na dnu hijerarhije okolina. Moemo dohvatiti referencu na nju preko istoimene varijable, ili se posluiti funkcijom globalenv(). Zadatak 6.6 - globalna okolina # stvorite varijablu e i u nju pohranite referencu na globalnu okolinu # ispiite varijablu e # stvorite varijablu x i u nju ubacite broj 5 # izvrite funkciju `ls` bez parametara # izvrite funkciju `ls` sa varijablom `e` kao parametrom # ispiite x # ispiite e$x (uoite sintaksu liste!) # stvorite varijablu e i u nju pohranite referencu na globalnu okolinu e &lt;- .GlobalEnv # ili e &lt;- globalenv() # ispiite varijablu e e # stvorite varijablu x i u nju ubacite broj 5 x &lt;- 5 # izvrite funkciju `ls` bez parametara #ls() # probati na konzoli! # izvrite funkciju `ls` sa varijablom `e` kao parametrom #ls(e) # probati na konzoli! # ispiite x x # ispiite e$x (uoite sintaksu liste!) e$x ## &lt;environment: R_GlobalEnv&gt; ## [1] 5 ## [1] 5 Iz zadnjeg primjera moemo vidjeti da okolina bez problema moe uvati i referencu na samu sebe obliku varijable e, tako da je ovo zapravo potpuno ispravna (iako nepotrebno komplicirana) sintaksa za ispis varijable x: e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$x Okoline su u izvjesnoj mjeri sline listama, koje su isto zapravo svojevrsni nain enkapsulacije niza objekata u jedinstvenu strukturu. Najbitnije razlike izmeu okoline i liste su: poredak elemenata u okolini je nebitan okolina (u pravilu) ima poveznicu na okolinu roditelja Pogledajmo tko je okolina-roditelj globalnoj okolini uz pomo funkcije parent.env. Zadatak 6.7 - okoline roditelji # ispiite okolinu-roditelja globalne okoline i objasnite rezultat # ispiite okolinu-roditelja globalne okoline i objasnite rezultat parent.env(e) ## &lt;environment: package:kernlab&gt; ## attr(,&quot;name&quot;) ## [1] &quot;package:kernlab&quot; ## attr(,&quot;path&quot;) ## [1] &quot;C:/R/R-4.1.2/library/kernlab&quot; Pomalo neoekivano, roditelj globalne okoline jest zadnje uitani paket! Ovo zapravo nije neobino - globalna okolina ima prioritet kod referenciranja varijable, ali prioritetno odmah ispod nje su oni objekti i funkcije koje smo zadnje uitali u okolinu (to nam odgovara budui da je pretpostavka da je najsvjeije uitani paket onaj kojeg namjeravamo odmah koristiti). Drugim rijeima, uitavanjem paketa novi paket se uvijek namjesti izmeu globalne okoline i paketa koji je prije njega bio zadnji uitan. Kada smo pozivali funkciju search, zapravo smo dobili hijerarhiju okolina koje predstavljaju uitane pakete. Ova hijerarhija okolina ujedno predstavlja i ve spominjanu stazu pretrage. Uz pomo funkcije parent.env moemo sami odrediti koju okolinu e neka okolina smatrati roditeljem. Na ovaj nain moemo napraviti vlastitu hijerarhiju okolina. Nadalje varijable koje stvaramo ne moraju koristiti reference iz globalne okoline (to je zapravo i osnovna funkcija operatora &lt;-), mi ih moemo pohraniti u bilo koju okolinu koju elimo, no za to se moramo koristiti funkcijama assign i get ili kombinacijom operatora $ i &lt;-. # primjer - stvaramo malu hijerarhiju okolina i pohranjujemo # te ispisujemo varijablu koristei jednu od njih e2 &lt;- new.env() e3 &lt;- new.env() # hijerarhija `e3` --&gt; `e2` --&gt; `e` (globalna) parent.env(e2) &lt;- e parent.env(e3) &lt;- e2 # stvaramo varijablu `x` u okolini `e2` assign(&quot;x&quot;, 5, e2) # ili e2$x &lt;- 5 # provjera postoji li varijabla `x` u okolini `e2` exists(&quot;x&quot;, e2) # ispis varijable `x` iz okoline e2 get(&quot;x&quot;, e2) #ili e2$x ## [1] TRUE ## [1] 5 Zato bi koristili okoline u praksi? Okolina predstavlja zgodan nain omatanja skupa varijabli koje onda zajedno moemo slati u neku funkciju - to je pogotovo zgodno ako dotine varijable referenciraju neke velike skupove podataka. Kao to emo vidjeti u sljedeoj lekciji, R ne podrava tzv. call-by-reference princip ve kod slanja objekata u funkciju R koristi tzv. copy-on-modify mehanizam. Ovo znai da e funkcija koristiti referencu na originalni objekt poslan u nju kao parametar sve do naredbe koja taj objekt odlui mijenjati; u tom trenutku stvara se kopija tog objekta i tek onda se provode izmjene. Ovo moe dovesti do znaajnih usporavanja programa kod programera koji nisu upoznati s ovom injenicom a koji npr. programiraju funkciju koja transformira podatkovni okvir. Ako funkciji umjesto reference na podatkovni okvir poaljemo referencu na okolinu u koju je zamotan okvir, onda nee doi do kopiranja varijable jer je okolina jedini objekt za kojeg copy-on-modify ne vrijedi. Uoimo da je specijalni sluaj ove metode slanje globalne okoline u funkciju, to se zapravo svodi na koritenje globalne varijable - neega to se u drugim programskim jezicima esto izbjegava, ali u R-u nije pretjerano rijetka pojava upravo zbog injenice da nas znatno usporavanje programa puno vie smeta od potencijalnih problema koje globalne varijable sa sobom donose. Za kraj demonstrirajmo rad funkcije attach koju analitiari esto koriste kako bi ubrzali postupak analize ali koja moe uzrokovati probleme ako nismo paljivi sa njenim koritenjem. Ova funkcija ubaciti e podatkovni okvir direktno u stazu pretrage kako bi nam omoguila laki pristup varijablama, ni uz potencijalne nezgodne nuspojave. Pogledajmo ovo na primjeru. Zadatak 6.8 - funkcija attach mjesto &lt;- data.frame( pbr = c(10000, 51000, 21000, 31000, 2000), nazivMjesta = c(&quot;Zagreb&quot;, &quot;Rijeka&quot;, &quot;Split&quot;, &quot;Osijek&quot;, &quot;Dubrovnik&quot;), prosjPlacaKn = c(6359., 5418., 5170., 4892., 5348.), brojStanovnika = c(790017, 128384, 167121, 84104, 28434), prirez = c(18, 15, 10, 13, 10)) # pozovite funkciju `attach` i proslijedite podatkovni okvir `mjesto` kao parametar # ovo napravite samo jednom kako ne bi okvir ubacili vie puta u stazu pretrage # ispiite stazu pretrage i komentirajte rezultat # ispiite varijablu pbr (bez reference na `mjesto`!) # promjenite trei element varijable prirez na 12 # ispiite tablicu `mjesto` # ispiite varijable globalne okoline # uz pomo funkcije `detach` uklonite tablicu `mjesto` iz staze pretrage # pozovite funkciju `attach` i proslijedite podatkovni okvir `mjesto` kao parametar # ovo napravite samo jednom kako ne bi okvir ubacili vie puta u stazu pretrage attach(mjesto) # ispiite stazu pretrage i komentirajte rezultat search() cat(&quot;-------------------------\\n&quot;) # radi preglednijeg ispisa # ispiite varijablu pbr (bez reference na `mjesto`!) pbr cat(&quot;-------------------------\\n&quot;) # radi preglednijeg ispisa # promjenite trei element varijable prirez na 12 prirez[3] &lt;- 12 # ispiite tablicu `mjesto` mjesto cat(&quot;-------------------------\\n&quot;) # radi preglednijeg ispisa # ispiite varijable globalne okoline #ls() # probati na konzoli! # uz pomo funkcije `detach` uklonite tablicu `mjesto` iz staze pretrage detach(mjesto) ## [1] &quot;.GlobalEnv&quot; &quot;mjesto&quot; &quot;package:kernlab&quot; ## [4] &quot;package:ranger&quot; &quot;package:caret&quot; &quot;package:e1071&quot; ## [7] &quot;package:corrplot&quot; &quot;package:broom&quot; &quot;package:car&quot; ## [10] &quot;package:carData&quot; &quot;package:Hmisc&quot; &quot;package:Formula&quot; ## [13] &quot;package:survival&quot; &quot;package:lattice&quot; &quot;package:sn&quot; ## [16] &quot;package:stats4&quot; &quot;package:gridExtra&quot; &quot;package:RSQLite&quot; ## [19] &quot;package:hflights&quot; &quot;package:lubridate&quot; &quot;package:GGally&quot; ## [22] &quot;package:forcats&quot; &quot;package:stringr&quot; &quot;package:dplyr&quot; ## [25] &quot;package:purrr&quot; &quot;package:readr&quot; &quot;package:tidyr&quot; ## [28] &quot;package:tibble&quot; &quot;package:ggplot2&quot; &quot;package:tidyverse&quot; ## [31] &quot;package:MASS&quot; &quot;package:stats&quot; &quot;package:graphics&quot; ## [34] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; ## [37] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; ## ------------------------- ## [1] 10000 51000 21000 31000 2000 ## ------------------------- ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 2000 Dubrovnik 5348 28434 10 ## ------------------------- Objasnimo to se dogodilo u gornjem primjeru. Uz pomo funkcije attach podatkovni okvir mjesto postao je mini-okolina, tj. njegovi stupci postali su dostupni unutar staze pretrage. Oiti benefit ovoga jest to da ih moemo referencirati direktno, bez reference na originalni podatkovni okvir i operatora $. No ovaj naoigled praktian trik ima skrivene zamke - prvo, ako se imena stupaca podudaraju sa postojeim varijablama globalne okoline, onda ti stupci nee biti vidljivi (o ovom emo biti obavijeteni adekvatnim upozorenjem). Drugo - i puno problematinije - ako pokuamo mijenjati stupac okvira direktnim referenciranjem, R e to sprijeiti i potiho e primijeniti copy-on-modify princip stvaranjem nove, globalne varijable koja e biti kopija referenciranog stupca. Neopreznom analitiaru tako moe promaknuti injenica da se promjene koje naizgled unosi uope ne odraavaju na samom podatkovnom okviru, to moe imati dalekosene posljedice. Ovi potencijalni problemi su vrlo raireni meu poetnicima u jeziku R tako da se u literaturi esto moe nai preporuka da se funkcija attach ne koristi ukoliko to iz nekog razloga nije nuno. Npr. Google-ov stilski vodi za R kae mogunosti greke kod koritenja funkcije attach su brojne, zato ju izbjegavajte. Jo jedna mogunost koju imamo jest koritenje funkcije with kojoj prvo dajemo referencu na okolinu, a potom izraz koji koristi varijable iz te okoline: with(mjesto, prosjPlacaKn[prirez &gt; 12]) no u veini sluajeva koritenje ove funkcije nee rezultirati itljivom sintaksom ve upravo naprotiv - programski kod se dodatno komplicira. Ukoliko elimo izbjei stalno referenciranje podatkovnog okvira u izrazima, za to postoje novi paketi upravo namjenjenih lakom upravljanju podatkovnih okvirima uz pomo iste i pregledne sintakse, kao npr. dplyr ili tidyr. Ove pakete upoznati emo u jednoj od nastupajuih lekcija. Zadaci za vjebu Uitajte sljedee pakete u radnu okolinu: magrittr, dplyr, tidyr, ggplot2. Ispiite stazu pretrage i provjerite gdje se nalaze uitani paketi. Sljedea naredba stvoriti e vektor od 20 nasumino odabranih prirodnih brojeva od 1 do 100. Uz pomo podsjetnika i/ili slubene dokumentacije pronaite ugraene funkcije koje izvravaju zadane zadatke. # uitavamo 20 prirodnih brojeva od 1 do 100, sa ponavljanjem set.seed(1234) a &lt;- sample(1:100, 20, replace = T) ispiite: vektor a vrijednosti vektora a poredane obrnutim redoslijedom jedinstvene vrijednosti iz vektora a vrijednosti vektora a poredane uzlazno Spomenuli smo da su uitani paketi zapravo okoline. Ukoliko elimo dobiti direktnu referencu na njih, moramo se posluiti funkcijom as.environment i imenom paketa. Pokuajte dobiti referencu na paket package:magrittr u obliku okoline te uz pomo funkcije ls provjerite koje nazive ona sadri u sebi. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["korisnik.html", "7 Korisniki definirane funkcije 7.1 Kako definirati funkciju 7.2 to su apply funkcije? 7.3 Funkcija apply 7.4 Funkcije lapply, sapply i vapply 7.5 Ostale funkcije iz porodice apply i dostupne alternative Zadaci za vjebu", " 7 Korisniki definirane funkcije Programski jezik R, iako objektnog tipa, u svojoj je sri jezik za funkcijsko programiranje. Ova programska paradigma nije nova (datira jo iz 50-tih godina prolog stoljea), no u posljednje vrijeme dobiva znatno na popularnosti kao svojevrsni komplement objektno-orijentiranom programiranju, za koje bi se moglo rei da je dominantna programska paradigma u zadnjih nekoliko desetljea. Kako ne bi preduboko ulazili u znaajke funkcijskog programiranja te provodili detaljnu usporednu analizu sa objektno-orijentiranim principima, navesti emo samo nekoliko okvirnih znaajki i smjernica vezano uz te dvije paradigme. Objektno-orijentirano programiranje u principu program gleda kao sustav imenica gdje komponente realiziramo u obliku objekata koji enkapsuliraju atribute spomenute imenice te metoda koje izvravaju odreene zadatke vezane uz navedenu imenicu. Isto tako, objektno-orijentirani sustavi usredotoavaju se na kontroliranu izmjenu stanja komponenata informacijskog sustava kao rezultat razmjene poruka izmeu njih. Funkcijsko programiranje program gleda kao sustav glagola gdje funkcije, tj zadaci koje elimo izvravati imaju prioritet naspram komponenata nad kojima se ti zadaci izvravaju. Funkcijsko programiranje modelira informacijski sustav kroz komponente koje u pravilu ne mijenjaju vlastito stanje, tako da rezultat programa strogo ovisi o ulazima to olakava testiranje i odravanje. Ukratko, razlika izmeu objektno-orijentiranog programiranja i funkcijskog programiranje se esto navodi na sljedei nain: Kod objektno-orijentiranog programiranja stvaramo podatke koji sadre funkcije; kod funkcijskog stvaramo funkcije koje sadre podatke. Za uenje R-a ne moramo se previe zamarati sa karakteristikama funkcijskog programiranja niti biti primorani usvojiti potpuno novu programsku paradigmu. No za uspjeno uenje R-a svladavanje nekih koncepata funkcijskog programiranja moe se pokazati iznimno korisnim budui da e nam omoguiti pisanje ieg i uinkovitijeg programskog koda koji e biti u skladu sa nainom na koji je R kao jezik i dizajniran. U R-u vrijedi sljedee: funkcije su punokrvni objekti, moemo ih referencirati varijablom iz birane okoline, slati u funkcije kao argumente, primati kao povratnu vrijednost funkcije ili pohranjivati u podatkovne strukture kao to je npr. lista. Funkcija u R-u je jednostavno objekt kojeg se moe izvriti tj. natjerati da obavi neki posao. Veliki broj funkcija - pogotovo onih koje zamjenjuju konstrukt programske petlje - radi na principu funkcijskih jezika gdje posao obavljamo na nain da deklarativno navedemo koju funkciju elimo primijeniti na kojoj podatkovnoj strukturi te pustimo da programski jezik sam obavlja niskorazinske poslove kao to je iteriranje po strukturi i pripremanje rezultata. Primjere ovoga emo nauiti uskoro, a sada se prvo upoznajmo sa sintaksom definiranja funkcije u R-u. 7.1 Kako definirati funkciju U openitom sluaju, definicija nove funkcije izgleda ovako: ime_funkcije &lt;- function(ulazni argumenti) { tijelo funkcije } Uoimo da kod definicije funkcije koristimo operator &lt;-. Ovo nije sluajno - definicija funkcije nije nita drugo nego stvaranje objekta klase function kojeg onda pridruujemo odreenoj varijabli; ime varijable zapravo je naziv funkcije. U R-u ne definiramo tipove ulaznih i izlaznih argumenata. Ulazni argumenti imaju ime i opcionalnu nazivnu vrijednost. Funkcija formalno vraa jednu vrijednost, to nije nuno restrikcija ukoliko elimo vratiti vie vrijednosti - jednostavno ih enkapsuliramo u obliku vektora ili liste. Kljuna rije return je opcionalna - funkcija vraa rezultat zadnjeg izraza u funkciji pa je esto dovoljno navesti samo varijablu koja predstavlja povratnu vrijednost kao zadnji red funkcije. Zadatak 7.1 - prva korisniki definirana funkcija # stvorite funkciju `myAbs` koja e imitirati # rad R-ove funkcije `abs` (ali ju nee direktno pozivati!) # stvorite funkciju `myAbs` koja e imitirati # rad R-ove funkcije `abs` (ali ju nee direktno pozivati!) # LOE RJEENJE! myAbs &lt;- function(x) { if (x &lt; 0) -x else x } # probajte pozvati myAbs(c(1, -1)). Zato ovo nije u redu? # stvorite funkciju `myAbs` koja e imitirati # rad R-ove funkcije `abs` function (ali ju nee direktno pozivati!) # DOBRO RJEENJE myAbs &lt;- function(x) { ifelse(x &lt; 0, -x, x) } Ukoliko elimo poveati robusnost funkcije na nain da emo odbiti izvoenje logike unutar funkcije ako nisu zadovoljeni odreeni uvjeti, za to moemo koristiti funkciju stopifnot(&lt;logiki izraz&gt;) Ova funkcija izraunava zadani logiki izraz i prekida funkciju ako navedeni uvjet nije istinit. Zadatak 7.2 - koritenje funkcije stopifnot # napiite funkciju `veci` koja prima dva numerika vektora iste duljine # i vraa vektor koji sadri vei od dva elementa na istim mjestima # ukoliko jedan ili oba vektora nisu numeriki ili nisu iste duljine, # funkcija mora izbaciti greku # u funkciji nemojte koristiti petlje # pozovite funkciju `veci` nad kombinacijama vektora # c(T, F, T) i c(1, 2, 3) # c(1, 2, 3, 4) i c(5, 6, 7) # c(1, 2, 3) i c(0, 4, 2) # (preporuka - drugi dio zadatka isprobati direktno u konzoli!) # napiite funkciju `veci` koja prima dva numerika vektora iste duljine # i vraa vektor koji sadri vei od dva elementa na istim mjestima # ukoliko jedan ili oba vektora nisu numeriki ili nisu iste duljine, # funkcija mora izbaciti greku # u funkciji nemojte koristiti petlje veci &lt;- function(a, b) { stopifnot(is.numeric(a) &amp;&amp; is.numeric(b) &amp;&amp; length(a) == length(b)); ifelse(a &gt; b, a, b) } Kod poziva funkcije moemo ali ne moramo navesti imena parametara, a R dozvoljava mijeanje imenovanih i neimenovanih parametara (iako to nije neto to bismo trebali esto koristiti u praksi). Kada R bude povezivao poslane vrijednosti sa formalnim parametrima, imenovani parametri imati e prioritet te e se prvi razrijeiti, a potom e se redom razrjeavati neimenovani parametri. U ovo se moemo uvjeriti u sljedeem zadatku, u kojem emo usput iskoristiti priliku i pokazati rad jedne vrlo esto koritene funkcije - paste. Ova funkcija konkatenira znakovne nizove uz dodavanje razmaka (za spajanje bez razmaka postoji alternativna funkcija paste0). Zadatak 7.3 - parametri funkcije ispisiABC &lt;- function(a, b, c) { print(paste(&quot;A:&quot;, a, &quot;B:&quot;, b, &quot;C:&quot;, c)) } # razmislite - to ispisuje sljedei poziv funkcije? ispisiABC(1, a = 2, 3) ispisiABC &lt;- function(a, b, c) { print(paste(&quot;A:&quot;, a, &quot;B:&quot;, b, &quot;C:&quot;, c)) } ispisiABC(1, a = 2, 3) ## [1] &quot;A: 2 B: 1 C: 3&quot; U praksi bismo se trebali drati konvencije da prvo koristimo neimenovane parametre, a potom imenovane. Uobiajeno je da postavljamo samo one imenovane parametre ija nazivna vrijednost nam ne odgovara pri emu strogi raspored nije bitan (iako e praenje rasporeda zadanog potpisom funkcije poveati itljivost naeg koda). Ako elimo napisati funkciju koja prima proizvoljan broj argumenata, koristimo se elementom ..., tj. trotokom. Primjer ovakve funkcije jest gore prikazana ugraena funkcija paste koja moe primiti proizvoljan broj znakovnih nizova. Ako koristimo trotoku u naoj funkciji, u potpisu ju u pravilu stavljamo na kraj liste argumenata, a unutar same funkcije ju potom jednostavno pretvorimo u listu te potom pristupamo njenim parametrima na nain koji nam odgovara. Zadatak 7.4 - funkcija sa proizvoljnim brojem parametara ispisiParametre &lt;- function(...) { parametri &lt;- list(...) for (p in parametri) print(p) } # pozovite gornju funkciju sa proizvoljnim parametrima ispisiParametre(c(1, 2, 3), 5, T, data.frame(x = 1:2, y = c(T, F))) ## [1] 1 2 3 ## [1] 5 ## [1] TRUE ## x y ## 1 1 TRUE ## 2 2 FALSE 7.1.1 Princip kopiranja kod izmjene (copy-on-modify) Jedno od eih pitanja koje se postavlja kod uenja novih programskih jezika jest da li funkcije rade na nain poziva preko vrijednosti (engl. call-by-value) ili poziva preko reference (engl. call-by-reference). Razlika se svodi na sposobnost funkcije da mijenja vrijednosti varijabli koje su poslane na mjestu formalnih argumenata funkcije; kod call-by-value principa u funkciju se alju samo vrijednosti parametara, tj. kopije originalnih argumenata. S druge strane, kod call-by-reference principa funkcija prima reference originalnih varijabli, tj. ponaa se kao da su originalne varijable proslijeene funkciji i sve izmjene nad njima odraziti e se u pozivajuem programu. Jezik R koristi hibridni princip poznat po nazivom kopiranje kod izmjene (engl. copy-on-modify). Kod ovog principa u funkciju se prosljeuju reference argumenata, to nam omoguuje da prenosimo i velike varijable bez straha da e doi do nepotrebnog kopiranja. No ovo vrijedi samo ukoliko funkcija ne mijenja vrijednost dobivenih varijabli - u trenutku kada funkcija pokua provesti bilo kakvu izmjenu, provodi se kopiranje varijable i funkcija dalje nastavlja rad na kopiji. Zbog ovoga se kae da R kao takav ne podrava call-by-reference (jedan razlog uvoenja objekata tipa reference classes tj. RC objekata u jezik R upravo je uvoenje ovog principa). Provjerimo gore navedene tvrdnje na konkretnom primjeru. # pokuaj izmjene varijable iz pozivajue okoline f &lt;- function() { cat(&quot;x u funkciji:&quot;, x, &quot;\\n&quot;) x &lt;- x + 1 cat(&quot;x nakon izmjene:&quot;, x, &quot;\\n&quot;) } x &lt;- 5 f() cat(&quot;x nakon povratka:&quot;, x, &quot;\\n&quot;) ## x u funkciji: 5 ## x nakon izmjene: 6 ## x nakon povratka: 5 Funkcija pri izvoenju stvara privremenu vlastitu okolinu unutar koje se pohranjuju lokalne varijable. U gornjem primjeru unutar tijela funkcije f pojavljuje se varijabla x koja maskira vanjsku varijablu x tako da se sve izmjene vie ne odraavaju na vrijednost vanjske varijable. Vano je uoiti da funkcija pristupa vanjskoj varijabli ak i bez njenog slanja u funkciju, budui da referenciranje varijable x koja ne postoji u lokalnoj okolini funkcije R pretragu nastavio u okolini roditelju to bi u ovom sluaju bila globalna okolina. Pokuaj izmjene ove varijable ipak ne uspijeva - R detektira pokuaj izmjene varijable i stvara lokalnu kopiju istog imena. Da li ovo znai da funkcija nikada ne moe mijenjati varijable iz pozivajue okoline? Naravno da ne - jedan od naina kako ovo izvesti jest taj da funkciji poaljemo referencu na okolinu unutar kojeg se nalazi objekt kojeg mijenjamo (ili pustimo funkciju da sama dohvati referencu na globalnu okolinu ukoliko se varijabla tamo nalazi). Primjer 7.1 - princip copy-on-modify # stvaramo podatkovni okvir `df` df &lt;- data.frame(id = 1:5, name = LETTERS[1:5]) # funkcija pokuava promijeniti prvi element drugog stupca # u glavni program se ne vraa nita # (operator pridruivanja nema povratnu vrijednost!) f &lt;- function(x) { x$name[1] &lt;- &quot;izmjena!&quot; } # originalni podatkovni okvir ostaje nepromijenjen! f(df) df ## id name ## 1 1 A ## 2 2 B ## 3 3 C ## 4 4 D ## 5 5 E Primjer 7.2 - princip copy-on-modify (2) # stvaramo podatkovni okvir `df` df &lt;- data.frame(id = 1:5, name = LETTERS[1:5]) # pokuaj drugi - funkcija nema ulaznih parametara # referencom na varijablu iz globalne okoline # pokuavamo provesti izmjenu f &lt;- function() { df$name[1] &lt;- &quot;izmjena!&quot; } # originalni podatkovni okvir ostaje nepromijenjen! f() df ## id name ## 1 1 A ## 2 2 B ## 3 3 C ## 4 4 D ## 5 5 E Primjer 7.3 - princip copy-on-modify (3) # stvaramo podatkovni okvir `df` # i &quot;zamotavamo&quot; ga u okolinu `e` e &lt;- new.env() parent.env(e) &lt;- emptyenv() e$df &lt;- data.frame(id = 1:5, name = LETTERS[1:5]) # funkcija prima referencu na okolinu # i mijenja varijablu unutar nje f &lt;- function(e) { e$df$name[1] &lt;- &quot;izmjena!&quot; } # promjena je konano vidljiva f(e) e$df ## id name ## 1 1 izmjena! ## 2 2 B ## 3 3 C ## 4 4 D ## 5 5 E Jednostavniji nain rjeavanja gornjeg zadatka bio bi koritenjem operatora &lt;&lt;-. Ovo je tzv. operator dodjele vanjskom opsegu (engl. scoping assignment operator), a njegova funkcija jest da izmjeni varijablu zadanog imena koja se nalazi negdje\" na stazi pretrage. R ide sekvencijalno po stazi pretrage i mijenja prvu pojavu navedene varijable. Ukoliko varijabla tog naziva ne postoji nigdje u stazi pretrage, R e stvoriti novu varijablu u prvoj okolini iznad okoline funkcije. Primjer 7.4 - operator &lt;&lt;- # operator `&lt;&lt;-` f &lt;- function(x) { x &lt;&lt;- 7 x &lt;- 6 } x &lt;- 5 f() x ## [1] 7 Ovaj operator je potencijalno nepredvidiv tako da emo veu robusnost ipak postii koritenjem funkcije assign ili operatora $ uz referencu na okolinu gdje se nalazi varijabla koju elimo mijenjati. Primjer 7.5 - operator &lt;&lt;- (2) # stvaramo podatkovni okvir `df` df &lt;- data.frame(id = 1:5, name = LETTERS[1:5]) f &lt;- function() { df$name[1] &lt;&lt;- &quot;change!&quot; } f() df ## id name ## 1 1 change! ## 2 2 B ## 3 3 C ## 4 4 D ## 5 5 E Za kraj spomenimo samo jedno svojstvo funkcija u R-u - tzv. lijena evaluacija (engl. lazy evaluation). Ovo jednostavno znai da R nee evaluirati primljeni parametar sve do trenutka kada ga eksplicitno koristimo. Do tog trenutka taj objekt je tzv. obeanje (engl. promise) - R zna kako evaluirati taj objekt ali to ne radi dok zaista ne treba a do tada imamo samo njegovo obeanje da e to uiniti :) . Na ovaj nain poveava se uinkovitost jezika; ako se neki parametar koristi samo u nekoj uvjetnoj grani, onda se u scenarijima kada on nije potreban nee na njega troiti memorija. No isto tako, moramo biti oprezni jer lijena evaluacija moe dovesti do neoekivanih problema ako ne vodimo rauna o njenom postojanju. 7.1.2 Funkcija kao objekt Ve smo rekli da R ima kvalitetnu podrku za tzv. funkcionalno programiranje to predstavlja programsku paradigmu koja naglasak stavlja na dizajniranje funkcija bez oslanjanja na objekte sa izmjenjivim stanjima. Jedna od karakteristika ovakvih jezika su i tzv. funkcije prve klase (engl. first class functions), to zapravo znai da jezik podrava definiciju funkcija na nain da su one ravnopravni objekti svim drugim tipovima objekata - mogu se pohraniti u varijablu, koristiti kao ulazni argument druge funkcije ili kao njezina povratna vrijednost, pohranjivati u druge podatkovne strukture i sl. Iako koncepti funkcionalnog programiranja izlaze iz okvira gradiva kojeg elimo prikazati, injenicu da R tretira funkcije kao sve druge objekte je vrlo vano znati budui da se ova injenica iznimno esto koristi kod programiranja u jeziku R. Pokaimo ovo na trivijalnom primjeru. Znamo da R nudi funkciju sum unutar paketa base koja rauna aritmetiku sumu elemenata vektora koje joj proslijedimo. No sum je zapravo ime varijable koja referencira kod koji implementira dotinu funkciju. Ukoliko elimo, moemo vrlo lako pridruiti ovu funkciju nekoj drugoj varijabli ime smo joj efektivno promijenili ime ili bolje rei dodali alternativni nain pozivanja iz potpuno druge okoline. zbroji &lt;- sum zbroji(1:10) # isto kao sum(1:10) Ovo je najlake shvatiti na nain da je funkcija jednostavno varijabla koja se moe pozvati, pri emu pod pozivom smatramo koritenje sintakse koja ukljuuje referencu na funkciju i ulazne argumente uokvirene u zagrade, a koja e nakon izvravanja u R okolini vratiti nekakvu vrijednost. Funkcija moe uredno vraati i neku drugu funkciju. stvoriteljFje &lt;- function() { f &lt;- function(x) x + 1 return(f) } novaFja &lt;- stvoriteljFje() # dobili smo funkciju &quot;dodavanja jedinice&quot; novaFja(5) ## [1] 6 Funkcija je jednostavno stvorila novu funkciju i vratila ju pozivajuem programu kao to bi uinila sa bilo kojim drugim objektom. Povratnu vrijednost spremili smo u varijablu koja je sad pozivljiva - ako joj dodamo zagrade i parametre ona e se izvriti na nain na koji je definirana unutar funkcije koja ju je stvorila. Uoite da smo mogli iskoristiti injenicu da funkcija vraa rezultat zadnjeg izraza i funkciju definirati i krae: #kraa definicija stvoriteljFje &lt;- function() { function(x) x + 1 } Ovakve funkcije esto se zovu i tvornicama ili generatorima funkcija, a za razliku od gornjeg primjera u praksi generatoru funkcija esto aljemo i neke parametre koji odreuju kako e se vraena funkcija ponaati. Pokuajte samostalno napraviti generator funkcija koji vraa funkcije za mnoenje sa unaprijed postavljenim parametrom. Zadatak 7.5 - generator funkcija # stvorite funkciju `tvornicaMnozenja` koja stvara funkcije mnoenja primljenog broja # sa nekom predefiniranom konstantom # uz pomo gornje funkcije napravite funkciju `puta2` koja udvostruuje primljeni broj # pozovite funkciju `puta2` s parametrom 3 i ispiite rezultat # stvorite funkciju `tvornicaMnozenja` koja stvara funkcije mnoenja primljenog broja # sa nekom predefiniranom konstantom tvornicaMnozenja &lt;- function(x) { function(a) a*x } # uz pomo gornje funkcije napravite funkciju `puta2` koja udvostruuje primljeni broj puta2 &lt;- tvornicaMnozenja(2) # pozovite funkciju `puta2` s parametrom 3 i ispiite rezultat puta2(3) ## [1] 6 Funkcija tvornicaMnozenja zapravo stvara porodicu funkcija koje sve pruaju mogunost mnoenja sa odabranim brojem - tj. parametrom kojeg odabire sam programer. Ovakav nain upravljanja funkcijama je moda inicijalno zbunjujui, no koritenjem istoga u praksi (to emo prikazati ve u iduem poglavlju) lako se uoava dodatna fleksibilnost i uinkovitost ovakvog pristupa. Ako definiramo funkciju, a ne pridruimo ju nekoj varijabli, onda smo stvorili tzv. anonimnu funkciju. # anonimna funkcija function(x) x * x Uoimo da je svaka funkcija inicijalno anonimna. Ako se vratimo na sintaksu definicije funkcije, vidimo da je ona zapravo kombinacija stvaranja anonimne funkcije i pridjeljivanja iste nekoj varijabli uz operator pridruivanja. Naravno, ostavljanje funkcije anonimnom kao to smo izveli u gornjem primjeru nema previe smisla, isto kao to nema smisla definirati neki vektor ili listu bez pridjeljivanja reference na taj objekt - u tom sluaju stvoreni objekt nije ni na koji nain iskoristiv jer nema nijedne poveznice prema njemu te e ga R vrlo brzo obrisati u sklopu rutine ienja smea. Moemo se zapitati - kako onda izgleda scenarij gdje je koritenje anonimne funkcije smisleno i korisno? Eksplicitne anonimne funkcije koristimo kada nam dobro doe jednokratna funkcija, recimo kao argument neke druge funkcije. Ako je funkciju koju elimo poslati kao argument lako definirati u jednom retku, a ne planiramo ju vie koristiti u programu, onda nema smisla zasebno ju definirati i dodijeliti joj vlastitu referencu. Primjer ovoga vidjet emo u lekciji o apply porodici funkcija. Za kraj ovog dijela ponovimo najbitnije stvari - u R-u je funkcija objekt kao i svaki drugi, jedina specifinost jest da se radi o objektu koji je izvriv, tj. koji uz koritenje sintakse za poziv funkcije obavlja neki posao i vraa neku vrijednost. ak i anonimnu funkciju moemo bez problema izvriti (iako samo jednom, budui da nemamo referencu za njezino ponovno zvanje). # anonimna funkcija s pozivom (function(x) x + 1)(2) ## [1] 3 7.2 to su apply funkcije? Vrlo esto se poznavanje osnova jezika R procjenjuje znanjem koritenja tzv. apply porodice funkcija dostupnih u paketu base. Ove funkcije specifino su dizajnirane za provoenje repetitivnih zadataka nad skupovima podataka i kao takve zamjenjuju programsku logiku koja bi se u nekom drugom jeziku realizirala programskom petljom. Dodatno, ove funkcije u pravilu primaju druge funkcije kao ulazne argumente i tako u izvjesnoj mjeri potiu paradigmu funkcionalnog programiranja. Naziv porodice potie od injenice da funkcije iz nje imaju sufiks apply. Neke funkcije iz ove porodice su: apply lapply sapply vapply tapply, mapply, rapply Sve ove funkcije rade na slian nain - kao ulazne argumente primaju skup podataka, funkciju koju elimo primijeniti na elemente tog skupa te opcionalne dodatne parametre, a kao izlaz daju skup rezultata funkcije, najee upakirane u prigodni format. Razlika se uglavnom svodi na tipove ulaznih i izlaznih argumenata, te konkretne detalje oko provedbe same funkcije i/ili pripreme rezultata. Ovu porodicu funkcija najlake je upoznati preko primjera. Zaponimo sa osnovnom funkcijom - apply. 7.3 Funkcija apply Funkcija apply jedina je koja doslovno dijeli ime sa porodicom ovih funkcija. Namijenjena je radu s matricama (zapravo sa poljima, ali budui da se relativno rijetko radi sa strukturama koje imaju vie od dvije dimenzije, ovdje emo se usredotoiti samo na matrice). Sintaksa naredbe je sljedea: rezultat &lt;- apply( &lt;matrica&gt;, &lt;redovi (1) ili stupci (2)&gt;, &lt;funkcija&gt; ) Ili, opisano rijeima, za provoenje funkcije apply: odaberemo matricu odluimo se da li ju reemo po retcima ili stupcima primjenjujemo odabranu funkciju na svaki redak (ili stupac) Ovisno o tome to funkcija radi, kao rezultat dobivamo matricu ili (to je ei sluaj) vektor. Pokuajmo primijeniti ovu funkciju na konkretnom primjeru. Zadatak 7.6 - funkcija apply m &lt;- matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE) # ispiite matricu `m` # uz pomo funkcije `apply` izraunajte # i ispiite zbrojeve stupaca matrice `m` # uz pomo funkcije `apply` izraunajte # i ispiite umnoke redaka matrice `m` m cat(&quot;------------\\n&quot;) # za pregledniji ispis apply(m, 2, sum) cat(&quot;------------\\n&quot;) apply(m, 1, prod) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## ------------ ## [1] 12 15 18 ## ------------ ## [1] 6 120 504 Ukoliko elimo nad retcima / stupcima provesti neki specifian zadatak, za to vrlo esto koristimo anonimnu funkciju, npr: apply(m, 1, function(x) x[1]) # izvlaimo prvi element svakog retka Zadatak 7.7 - funkcija apply i anonimne funkcije # uz pomo funkcije `apply` za svaki redak matrice `m` # izraunajte prirodni logaritam sume elemenata # zaokruen na 2 decimale (funkcija `round`!) apply(m, 1, function(x) round(log(sum(x)),2)) ## [1] 1.79 2.71 3.18 Ponovimo - funkcija apply (i srodne funkcije) implicitno rastavljaju ulaznu podatkovnu strukturu na elemente. U primjerima gore ti elementi - retci ili stupci - su zapravo numeriki vektori. Argument x kojeg prima anonimna funkcija je upravo taj vektor, ili bolje rei svaki od tih vektora koji joj se prosljeuju jedan po jedan. Rezultati funkcije se pamte i pakiraju u konani rezultat. Pokuajmo isprogramirati zadnji primjer bez koritenja funkcije apply. Zadatak 7.8 - petlja kao alternativa funkciji apply # uz pomo programske petlje za svaki redak matrice `m` # izraunajte prirodni logaritam sume elemenata # zaokruen na 2 decimale (funkcija `round`!) rez &lt;- numeric(nrow(m)) for (i in 1:nrow(m)) rez[i] &lt;- round(log(sum(m[i,])), 2) rez ## [1] 1.79 2.71 3.18 Ako usporedimo sintakse primjera sa i bez koritenja funkcije apply, moemo se uvjeriti koliko je sintaksa koja koristi apply zapravo ia i jasnija. Ako koristimo petlje moramo eksplicitno navesti logiku prolaenja strukturom i uvanja meurezultata, to odvlai panju od opisa posla kojeg zapravo elimo obaviti. to ako apply funkciji elimo proslijediti vie parametara? Npr. recimo da umjesto gornje funkcije koja izvlai prvi element retka elimo funkciju sa dva parametra - prvi je vektor a drugi cijeli broj koji oznaava koji broj treba izvui. Odgovor je jednostavan - dodatne parametre jednostavno navedemo na kraju poziva funkcije. # apply funkcija i ulazna funkcija sa vie parametara apply(m, 1, function(x,y) x[y], 2) # izvlaimo drugi element svakog retka Konano, treba napomenuti da za slinu obradu podataka u matrinom obliku ne moramo nuno koristiti apply - dosta popularnih operacija kao to su zbrajanje elemenata redaka ili stupaca, raunanje prosjeka elemenata redaka i stupaca i sl. ve je implementirano kroz funkcije kao to su rowSums, colSums, rowMeans, colMeans i sl. One su jednostavnije za uporabu, no specijalizirane - za dodatnu fleksibilnost najee je apply najpogodnija opcija. 7.4 Funkcije lapply, sapply i vapply Ime funkcije lapply dolazi od list apply - tj. apply funkcija koja radi sa listama. Jednostavno - radi se o funkciji koja e kao ulazni argument primiti listu i neku funkciju, primijeniti funkciju na svaki pojedini element liste i vratiti opet rezultat u obliku liste. Zadatak 7.9 - funkcija lapply l &lt;- list(a = 1:3, b = rep(c(T, F), 10), c = LETTERS) # pomou funkcije `lapply` izraunajte duljinu (broj elemenata) # svakog elementa liste `l` lapply(l, length) ## $a ## [1] 3 ## ## $b ## [1] 20 ## ## $c ## [1] 26 Isto kao kod funkcije apply, kod funkcije lapply esto kao parametar koristimo anonimne funkcije. Sljedei zadatak nema posebnu praktinu uporabu, ali e nam pomoi da shvatimo funkcioniranje funkcije lapply te usvojimo injenicu kako anonimne funkcije ne moraju nuno biti kratke i jednostavne. Zadatak 7.10 - funkcija lapply i anonimne funkcije # obradite elemente liste `l` na sljedei nain: # - izraunajte srednju vrijednost ako se radi o numerikom vektoru # - prebrojite vrijednosti TRUE ako se radi o logikom vektoru # - ispiite duljinu vektora za sve ostale sluajeve # koristite funkciju `lapply` i anonimnu funkciju # ne zaboravite da i anonimna funkcija moe koristiti blokove! # obradite elemente liste `l` na sljedei nain: # - izraunajte srednju vrijednost ako se radi o numerikom vektoru # - prebrojite vrijednosti TRUE ako se radi o logikom vektoru # - ispiite duljinu vektora za sve ostale sluajeve # koristite funkciju `lapply` i anonimnu funkciju # ne zaboravite da i anonimna funkcija moe koristiti blokove! lapply(l, function(x) { if (is.numeric(x)) { mean(x) } else if (is.logical(x)) { sum(x) } else length(x) }) ## $a ## [1] 2 ## ## $b ## [1] 10 ## ## $c ## [1] 26 Funkcija lapply je u sutini dosta jednostavna za koritenje i ba zbog te injenice vrlo popularna. No nakon to ju koristimo jedno vrijeme moe nas zasmetati injenica da ona uvijek kao rezultat vraa listu, iako bi nam nekad vie odgovarala neka druga podatkovna struktura, kao npr. vektor, pogotovo ako rezultantna lista ima kao elemente jednostavne brojeve. Upravo iz ovog razloga R nudi funkciju unlist za pojednostavljivanje liste u vektor ako ona sadri jednostavne elemente. Zadatak 7.11 - funkcija unlist l &lt;- list(a = 1:10, b = 10:20, c = 100:200) # izraunajte srednje vrijednosti elemenata liste `l` # rezultate ispiite kao numeriki vektor # koristite lapply i unlist unlist(lapply(l, mean)) ## a b c ## 5.5 15.0 150.0 Prikazana kombinacija lapply i unlist e nam kao rezultat dati jednodimenzionalni vektor, to nam u velikom broju sluajeva odgovara. No ponekad bi nam vie odgovarala neka druga podatkovna struktura - npr. matrica. U ovom sluaju potreban nam je i dodatni korak preoblikovanja jednodimenzionalnog vektora u matricu uz pomo funkcije matrix, pri emu moramo eksplicitno zadati broj redaka i stupaca. Moe se postaviti pitanje - zato funkcija lapply ne bi mogla pogledati rezultat kojeg je dobila i sama odrediti optimalnu podatkovnu strukturu za oblikovanje rezultata (vektor, matrica ili lista)? Upravo je to ideja iza funkcije sapply, ili simplified list apply. Ova funkcija prvo interno obavlja lapply, a potom se rezultat pojednostavljuje na vektor, matricu ili polje, ovisno o karakteristikama dobivenih rezultata. Zadatak 7.12 - funkcija sapply l &lt;- list(a = 1:10, b = 10:20, c = 100:200) # izraunajte medijane elemenata liste `l` # i rezultate ispiite kao numeriki vektor # koristite funkciju `sapply` # izvucite prvi i zadnji element svakog od elemenata liste `l` # koristite `sapply` i anonimnu funkciju sapply(l, median) cat(&quot;------------\\n&quot;) # za pregledniji ispis sapply(l, function(x) c(x[1], x[length(x)])) ## a b c ## 5.5 15.0 150.0 ## ------------ ## a b c ## [1,] 1 10 100 ## [2,] 10 20 200 Uoite da smo kao rezultat zadnjeg primjera dobili matricu, ali da ju je R oblikovao po stupcima. Ukoliko bismo htjeli matricu sa elementima poredanim po retcima, za to naalost ne moemo koristiti sapply jer se matrica formira interno, bez mogunosti prosljeivanja parametra byrow = T. Za dobivanje takve matrice jedna opcija nam je ve spomenuta kombinacija funkcija lapply, unlist i matrix ili - to je jednostavnije - transponiranje rezultata sapply uz pomo funkcije t (od engl. transpose). Funkcija sapply je prilino omiljena zbog svoje jednostavnosti i uinkovitosti tako da se relativno esto koristi u interaktivnoj analizi. S druge strane, koritenje ove funkcije u programskim skriptama se ne preporuuje budui da je rezultat u openitom sluaju nepredvidiv - npr. skripta moe u nastavku programskog koda oekivati matricu, a funkcija sapply je zbog specifinosti ulaznih podataka vratila vektor, to moe uzrokovati nepredviene rezultate u nastavku skripte a to nije lako naknadno uoiti te dijagnosticirati gdje je nastala greka. Ukoliko razvijamo vlastite programe u R-u i elimo koristiti sapply, onda e nam bolji izbor predstavljati funkcija vapply (od engl. verified sapply) koja radi identino funkciji sapply, ali koristi dodatni parametar nazvan FUN.VALUE pomou kojeg eksplicitno definiramo kakvo pojednostavljenje oekujemo. Npr. numeric(3) znai da bi rezultat primjene funkcije na svaki element originalne liste trebao biti numeriki vektor od tri elementa. Ukoliko se rezultat za bilo koji element liste razlikuje od oekivanog, funkcija e izbaciti greku. Zadatak 7.13 - funkcija vapply podaci &lt;- list(brojevi &lt;- c(1:5), imena &lt;- c(&quot;Ivo&quot;, &quot;Pero&quot;, &quot;Ana&quot;), abeceda &lt;- LETTERS) # razmislite koji e od sljedeih poziva biti uspjean, # a koji e izbaciti greku # rezultate provjerite na konzoli vapply(podaci, length, FUN.VALUE = numeric(1)) vapply(podaci, function(x) as.character(c(x[1], x[2])), FUN.VALUE = character(2)) vapply(podaci, function(x) as.logical(x), FUN.VALUE = character(1)) Konano, vratimo se nakratko funkciji lapply i razmotrimo jednu bitnu injenicu - ona je namijenjena uporabi nad listama, a podatkovni okviri su zapravo liste. Drugim rijeima, funkcija lapply je vrlo zgodna za obradu tablinih podataka kada elimo odreenu funkciju primijeniti na stupce podatkovnog okvira. Jedna od eih operacija koje se provode kod analize podataka jest tzv. normalizacija numerikih stupaca podatkovnog okvira - tj. svoenje svih numerikih vrijednosti na normalnu distribuciju aritmetike sredine 0 i standardne devijacije 1. Ovo moemo uraditi tako da svaku pojedinu vrijednost umanjimo za aritmetiku sredinu stupca (funkcija mean) te podijelimo sa standardnom devijacijom stupca (funkcija sd). Ovo je odlian scenarij za demonstraciju koritenja funkcije lapply. Zadatak 7.14 - funkcija lapply i podatkovni okviri df &lt;- data.frame( a = 1:10, b = seq(100, 550, 50), c = LETTERS[1:10], d = rep(c(T,F), 5), e = -10:-1) # normalizirajte numerike stupce uz pomo funkcije `lapply` # ostale stupce nemojte mijenjati # normalizirane vrijednosti zaokruite na tri decimale # rezultat pohranite u varijablu df # ispiite df df &lt;- lapply(df, function(x) { if (is.numeric(x)) { round((x - mean(x))/sd(x), 3) } else x }) df ## $a ## [1] -1.486 -1.156 -0.826 -0.495 -0.165 0.165 0.495 0.826 1.156 1.486 ## ## $b ## [1] -1.486 -1.156 -0.826 -0.495 -0.165 0.165 0.495 0.826 1.156 1.486 ## ## $c ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; ## ## $d ## [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE ## ## $e ## [1] -1.486 -1.156 -0.826 -0.495 -0.165 0.165 0.495 0.826 1.156 1.486 Vidimo da smo nakon koritenja lapply dobili listu te da ukoliko elimo rezultat u obliku podatkovnog okvira moramo dodati jo jedan korak koritenja funkcije as.data.frame. Ukoliko traimo jednostavniji nain koji odmah daje podatkovni okvir kao rezultat, postoji jedan zgodan trik kojeg emo objasniti u nastavku. Pogledajmo rjeenje prethodnog zadatka, konkretno red gdje rezultat poziva funkcije lapply pohranjujemo u varijablu df koji se sastoji u tome da umjesto pridruivanja rezultata samoj varijabli (df &lt;-) rezultat pridruimo varijabli sa praznim operatorom indeksiranja (df[] &lt;-): df[] &lt;- lapply(...) Na ovaj nain R nee napraviti novu varijablu imena df, ve e rezultat funkcije lapply upisati u sve retke i stupce okvira df. Time smo postigli da smo umjesto liste rezultat dobili u obliku podatkovnog okvira, to smo zapravo i htjeli. Upravo zbog ovoga vrlo esto emo u R skriptama vidjeti slinu sintaksu (df[] &lt;- lapply...). Pokuajte preinaiti gornji primjer na navedeni nain i uvjerite se da e rezultat biti podatkovni okvir. Jo jedan esto koriteni trik u radu sa podatkovnim okvirima i funkcijama iz porodice apply jest sljedea naredba: sapply(df, class) Ova naredba nam zapravo daje odgovor na pitanje - kojeg su tipa stupci navedenog podatkovnog okvira? Iako postoje i drugi naini da doemo do ove informacije, ovaj nain popularan je kako zbog kompaktnosti rezultata, tako i neovisnosti o dodatnim paketima. 7.5 Ostale funkcije iz porodice apply i dostupne alternative U prethodnim poglavljima naveli smo vjerojatno najpopularnije lanove porodice apply. Ova porodica broji jo lanova, ukljuujui i neke koji nemaju sufiks -apply: mapply, koja primjenjuje funkcije paralelno nad vie podatkovnih struktura rapply, koja rekurzivno primjenjuje funkcije unutar strukture tapply, koja primjenjuje funkcije nad podskupovima unutar strukture definirane faktorima Map, inaica mapply koja ne pojednostavljuje rezultat by, inaica tapply predviena za podatkovne okvire itd. Razlog zato ove funkcije neemo detaljno obraivati jest dvojak: prvo, kao to je ve reeno, ove funkcije se u praksi primjenjuju puno rjee od funkcija koje smo prikazali u prethodnim poglavljima. Drugo, porastom popularnosti jezika R pojavio se i veliki broj paketa orijentiranih upravo poboljanju postojeih funkcija jezika R u smislu lakeg i uinkovitijeg programiranja, poglavito u radu s podatkovnim okvirima. Ukoliko traimo zgodne alternative funkcijama iz porodice apply, preporuuje se pogledati neke od sljedeih paketa plyr - iznimno popularan paket koji izmeu ostalog nudi niz funkcija vrlo srodnih apply¸funkcijama, ali izvedenih na nain da imaju konzistentan potpis te eksplicitno definirane ulazne i izlazne oblike koji se lako itaju iz samog imena funkcije (konkretno, prvih slova); tako funkcija llply kao ulaz prima te kao izlaz daje listu, dok funkcija mdply kao ulaz prima matricu a kao izlaz daje podatkovni okvir purrr - paket koji zamjenjuje funkcije porodice apply sa funkcijama koje odgovaraju slinim funkcijama iz drugih programskih jezika za funkcijsko programiranje; budui da se primjena iste funkcije na niz elemenata neke podatkovne strukture u funkcijskim jezicima esto zove mapiranje, niz funkcija ovog paketa nosi prefiks map_ a imena funkcija esto odgovaraju oekivanim rezultatima (npr. map2_lgl znai da kao rezultat oekujemo logiki vektor, a map2_df podatkovni okvir) dplyr - relativno novi paket koji u izvjesnom smislu predstavlja nasljednika paketa plyr za rad sa podatkovnim okvirima; funkcije ovog paketa nisu toliko orijentirane zamjeni funkcijama porodice apply koliko pruanju svojevrsne platforme za rad sa podatkovnim okvirima na nain slian jezicima domenski orijentiranim upravo za tu svrhu, kao to je npr. jezik SQL U lekciji o upravljanju podatkovnim skupovima upoznati emo se upravo sa paketom dplyr, upravo zbog injenice da ovaj paket uvelike olakava i ubrzava proces analize podataka te je iznimno dobro prihvaen u R zajednici. Zadaci za vjebu R ima funkciju which koja pretvara logiki vektor u numeriki sa rednim brojevima elemenata koji su TRUE (tako c(T, F, F, F, F, T, F, T) postaje c(1, 6, 8)). Implementirajte vlastitu inaicu ove funkcije. Uzmimo numeriki vektor x duljine n. U statistici standardiziranim momentom k-tog reda zovemo vrijednost: \\[\\frac{1}{n}\\sum_{i=1}^n{(x_i - \\bar{x})}^{k+1}\\] Stvorite generator funkcija moment(k) koji e stvarati funkcije za raunanje standardiziranog centralnog momenta k-tog reda. Stvorite funkcije nulti_moment(x) i prvi_moment(x) sa vrijednosti parametra k redom 0 i 1. Testirajte funkcije na vektoru 1:1000. Usporedite rezultate koje daje funkcija sd (standardna devijacija) nad vektorom 1:1000 i korijen rezultata funkcije prvi_moment nad istim vektorom. Uzmimo matricu m stvorenu sljedeom naredbom: m &lt;- rbind(1:5, seq(2, 10, 2), rep(3, 5), 3:7, seq(100, 500, 100)) Uz pomo funkcije apply i nove anonimne funkcije stvorite vektor koji e sadravati prvi parni element svakog retka, ili nulu ako pripadajui redak nema parnih elemenata. Sljedee naredbe stvoriti e listu od 100 elemenata gdje e svaki element biti numeriki vektor nasumine duljine od 1 do 10. set.seed(1234) lista &lt;- replicate(100, sample(1:10, sample(1:10, 1))) Uz pomo funkcija lapply / sapply (i dodatnih naredbi ako je potrebno) stvorite: numeriki vektor v sa duljinama elemenata liste listu l sa normaliziranim numerikim vektorima originalne liste numeriki vektor ind4 sa indeksima svih elemenata liste koji sadre broj 4 podatkovni okvir df5 koji kao stupce sadri sve elemente liste duljine 5 Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
