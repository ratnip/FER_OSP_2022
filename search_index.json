[["index.html", "Programirajmo u R-u (Udbenik za predmet Osnove statistikog programiranja) Predgovor", " Programirajmo u R-u Damir Pintar 2022-10-12 (Udbenik za predmet Osnove statistikog programiranja) ** NAPOMENA: Za vrijeme odvijanja predmeta Osnove statistikog programiranja u tekuoj akademskoj godini provodi se revizija poglavlja udbenika. Nakon to se materija odradi na predavanjima te zavri ciklus predaje radnih biljenica nova poglavlja e se dinamiki dodavati u ovaj HTML dokument. Ukoliko vam je nuno potreban pristup cjelokupnim materijalima kontaktirajte autora udbenika na damir.pintar@fer.hr ** Predgovor Ovaj udbenik nastao je iz interaktivnih lekcija koritenih na predmetu Osnove statistikog programiranja na Fakultetu elektrotehnike i raunarstva Sveuilita u Zagrebu. No teme koje se ovdje obrauju nisu korisne samo studentima navedenog fakulteta - poznavanje jezika R dobro e doi kako u akademskom, tako i u poslovnom svijetu. Iako je R poznat kao programski jezik napravljen od statistiara, za statistiare te se najee povezuje sa poljem podatkovne znanosti unutar kojeg se koristi za sloene statistike i dubinske analize, on se moe pokazati vrlo koristan i za poslove vezane uz upravljanje manjim ili veim podatkovnim skupovima koji nisu nuno strogo orijentirani naprednoj analitici. Naime, popularni grafiki alati sa svojim interaktivnim tablinim prikazom vrlo su intuitivni i odlini za jednostavnije poslove, no kako se pojavljuju potrebe za sloenijim zadacima oni vrlo brzo gube na uinkovitosti i jednostavnosti; s druge strane, interaktivni programski pristup kojeg nudi R inicijalno je neto zahtjevniji, no dugorono vrlo isplativ jer se i vrlo sloeni zadaci mogu rjeavati na uinkovit, konzistentan i pregledan nain. Upravo iz tog razloga u poslovnom svijetu pojavljuje se jasna tendencija odmaka od klasinih grafikih alata prema platformama sa boljom podrkom za provoenje sloenijih izrauna i stvaranje atraktivnih vizualizacija. Ovo se oituje snanim porastom popularnosti jezika R i drugih platformi sa slinim pristupom analizi podataka. Navedena popularnost jezika R rezultira i poveanom potrebom za resursima za uenje, kojih na hrvatskom jeziku trenutno nema ba previe. Ovaj udbenik svojim pristupom uenja kroz primjere pokuati e uenje R-a uiniti to lakim i zanimljivijim. Naglasak e biti stavljen prvenstveno na svladavanje R-a kao programskog jezika. Upravo zbog toga poetna poglavlja baviti e se poglavito programerskim aspektima, a potom e biti dan pregled dostupnih alata za zadatke za koje pretpostavlja da su korisni najirem skupu itatelja - upravljanje podatkovnim skupovima, izvlaenje korisnih informacija i stvaranje vizualizacija. Budui da je R ipak domenski orijentirani jezik, pria o R-u zaokruiti e se kratkim uvidom u njegovu podrku za statistike analize te pregledom odabranih metoda strojnog uenja i njihove primjene. Iako e biti dano dovoljno informacija da se sve prikazane metode stave u kontekst, ideja ovog udbenika nije nauiti itatelja statistiku niti duboko ui u polje strojnog uenja - namjera autora jest zaintrigirati itatelja da nastavi istraivanje ovog interesantnog podruja, adekvatno naoruanog znanjem platforme koje e omoguiti da sva novousvojena znanja odmah praktino primjeni u svojim daljnjim istraivanjima. "],["uvod.html", "1 Uvod 1.1 to je programski jezik R? 1.2 Instalacija programske podrke 1.3 Pregled razvojnog suelja RStudio 1.4 Kako koristiti ovaj udbenik?", " 1 Uvod 1.1 to je programski jezik R? 1.1.1 Openito o R-u Programski jezik R proizaao je iz programskog jezika S, razvijenog za potrebe Bell Telephone Laboratorija u vlasnitvu AT &amp; T korporacije. Zamiljen je kao interni alat za statistiku analizu. Osnovna filozofija jezika S (koju je naslijedio i programski jezik R) bila je domenska orijentiranost - tj. olakavanje posla podatkovnim analitiarima bez potrebe za prilagoavanjem konvencijama tradicionalnih programskih jezika. Jezik S je kroz 80.-te i 90.-te dosegnuo znaajnu popularnost u krugovima poslovnih analitiara i statistiara, no dostupan samo kroz komercijalnu varijantu nazvanoj S-PLUS. Programski jezik R nastao je na sveuilitu u Aucklandu (NZ) po uzoru na S, a 2000. objavljuje se pod GNU licencom otvorenog koda. Standardna distribucija R programskog jezika sastoji se od: jezgre R-a, sa temeljnim funkcijama i tzv. base paketom koji omoguuje osnovnu funkcionalnost kolekcijom dodatnih paketa (osnovni - base i preporueni - recommended) za upravljanje podacima, vizualizacije i statistike analize Ovdje ne treba zanemariti izvrsnu integraciju R-a sa bogatim repozitorijem paketa zvanom CRAN (Coprehensive R Archive Network) koja omoguuje brzu i jednostavnu instalaciju bilo kojeg paketa iz navedenog repozitorija nakon ega on postaje dio lokalne R instalacije. Budui da je za jezik R specifian iznimno jaki utjecaj R zajednice na razvoj novih paketa, esto se nakon pojavljivanja novih eksperimentalnih metoda i pristupa podatkovne analize vrlo brzo na CRAN-u mogu pronai paketi koji iste implementiraju, a takoer treba spomenuti i snani i kontinuirani entuzijazam R zajednice za razvoj poboljanja postojeih elemenata R-a koji ublaavaju ili uklanjaju veliki broj uoenih manjkavosti jezika. R se zbog toga esto zna usporeivati sa uradi sam projektom gdje korisnik, nakon upoznavanja sa isporuenim tvornikim komponentama (u ovom sluaju temeljnim funkcijama i paketima), poinje prilagoavati svoju razvojnu okolinu odabirom paketa koji tono odgovaraju njegovim potrebama i preferencama. Kreativnost i fleksibilnost u koritenju R-a se smatra njegovom velikom prednou, iako rezultira odreenom neformalnou i liberalnim pristupom programiranju koji nije omiljen korisnicima naviknutim na stroge i formalne programske okvire sa jasnim skupom smjernica i pravila koja se moraju slijediti. Usprkos iznimno velikoj prihvaenosti jezika R za podatkovne analize te mnotvu opcija koje nudi korisniku, potrebno je odmah u poetku biti svjestan i njegovih odreenih ogranienja: R jako intenzivno koristi radnu memoriju to je dugo vremena smatrano ozbiljnim ogranienjem; porastom kapaciteta modernih hardverskih sustava ovo ogranienje je danas puno prihvatljivije, a takoer su se pojavili brojni paketi koji racionaliziraju koritenje memorije. Ipak ostaje injenica da R brzo pojede RAM naeg raunala, iako je to esto i rezultat nepanje ili neznanja programera koji nije dovoljno dobro usvojio R-ovski nain programiranja. R je prilino nekonvencionalan tako da je krivulja uenja inicijalno neto strmija, pogotovo za programere naviknute na standardne konvencije drugih programskih jezika. S druge strane, ako se gleda dugorono, programiranje u R-u je prilino jednostavno budui da je veina kompleksnih zadataka apstrahirana u visokorazinske funkcije koje transparentno obavljaju operativne poslove niske razine. esto se kae da je R vie orijentiran cilju kojeg elimo postii a manje detaljima oko puta kojim do njega stiemo. R nije brzi jezik; iako se radi o jeziku koji oekivano radi nad velikim skupovima podataka, R nije optimiziran za brzinu izvoenja, pa ak ni za viedretvenost; iako je veliki trud uloen da se gotovo sve kljune rutine implementiraju u C-u i da se sprijee znatna usporavanja, a postoji i niz paketa koji omoguuju viedretveno izvoenje R programa, i dalje stoji injenica da R nije dizajniran s ciljem da se izvrava to je bre mogue; ukoliko je brzina prioritet, esto je potrebno traiti alternativna rjeenja - zbog ega se esto zna rei da je R primarno istraivaki jezik, ne produkcijski. R je prvenstveno namijenjen za interaktivni rad, tj. izvoenje niza strojnih instrukcija koje se dinamiki upisuju i izvode uz pomo programske konzole. Ovo je prilagoeno standardnom procesu analize podataka gdje analitiar moe uitavati podatke, istiti ih, transformirati, razvijati modele, testirati i sl. uz konstantnu povratnu informaciju od raunala, mogunost pregleda meurezultata, izmjene procesa prema trenutnim saznanjima i sl. Ovo ne znai da se u programskom jeziku ne moe programirati na klasian proceduralni nain, razvojem algoritama enkapsuliranih u funkcije koje onda nakon pozivanja automatski obavljaju svoje zadatke, ali injenica jest da se uinkovitost R-a upravo odraava u interaktivnom radu. Ovaj princip se prenosi i na uenje R-a; programski jezik R puno se lake ui interaktivnim pristupom uz izvravanje konkretnih zadataka, eksperimentiranjem s podatkovnim skupovima, dostupnim metodama i sl. nego klasinim pristupom izrade programskih skripti koje implementiraju neke niskorazinske poslove. 1.1.2 Alternative jeziku R Programski jezik R je popularno, ali ne i jedino rjeenje za interaktivnu analizu podataka i statistiko programiranje. U nastavku emo dati kratki pregled nekih popularnijih tehnologija i rjeenja koje se danas koriste u ovu svrhu, uz kratku usporedbu i osvrt na prednosti i nedostatke u usporedbi sa onim to nudi jezik R. SAS i SPSS  SAS (Statistical Analysis System, razvijen od strane SAS Institute) i SPSS (Software Package for Statistical Analysis, razvijen od strane IBM-a) su dva razliita softverska paketa koje stavljamo pod istu stavku prvenstveno zato to se radi o komercijalnim alatima, tj. alatima koji za svoju punu funkcionalnost zahtijevaju plaanje licence. Isto tako, SAS i SPSS se relativno lako ue a svoju funkcionalnost u velikoj mjeri zasnivaju na pomno dizajniranim korisnikim sueljima. Ovi alati naglasak stavljaju na uinkovitost i odlina su opcija za velike tvrtke koje trae konzistentno, robusno rjeenje za svoju analitiku i kojima ne smeta komercijalna priroda takvih rjeenja. Weka i Orange  Weka (Waikato Environment for Knowledge Analysis, razvijen od strane sveuilita Waikato na Novom Zelandu) i Orange (alat za dubinsku analizu podataka razvijen na sveuilitu u Ljubljani) su besplatan softver za eksploratornu analizu podataka i dubinsku analizu koji svoju funkcionalnost zasnivaju na relativno jednostavnim grafikim sueljima i vizualnom pristupu programiranju. Ova rjeenja vrlo su dobra za korisnike koji nisu previe zahtjevni glede fleksibilnosti i kompleksnosti svojih analiza jer na vrlo pristupaan i jasan nain omoguuju provedbu definiranih koraka procesa analize. To ne znai da se u ovim alatima ne mogu raditi i kompleksnije analize, samo da su oni ipak prilagoeniji analizama kroz predefinirane funkcionalnosti pruenog grafikog suelja. Python (Numpy / Pandas / Scikit)  u zadnjih nekoliko godina upravo je Python najozbiljniji konkurent jeziku R, prvenstveno zbog injenice da je Python sam po sebi vrlo popularan programski jezik koji za potrebe analize podataka koristi pakete s vrlo slinim pristupom procesu analize onom kojeg koristi i jezik R. Rasprava o tome koji jezik odabrati je vrlo esta u polju znanosti o podacima, obino bez jasnog konanog zakljuka. Lako s uvjeriti da su razlike zapravo u nijansama - dok je R snano domenski orijentiran i vei naglasak stavlja na lakou i jednostavnost koritenja uz iroku paletu dostupnih paketa sa preklapajuim funkcionalnostima kako bi korisnik mogao odabrati onaj koji mu najvie odgovara, Python naglaava rigidnu formalnu strukturu i princip za jedan posao jedan nain obavljanja. Stoga bi se moglo rei da je R neto pogodniji za istraivanje podataka dok je prednost Pythona laki razvoj i integracija analitikih modula u nekom produkcijskom okruenju, pogotovo ako je navedeno okruenje ve izvedeno u Pythonu. No snanim razvojem oba jezika i meusobnim praenjem funkcionalnosti i ova navedena razlika postaje sve manje relevantna - danas vie nije problem integrirati R skripte u postojee sustave neovisno o platformi na kojoj su izvedeni, a u Python zajednica razvija svoje inaice popularnih paketa iz R-a koje vjerno preslikavaju njihovu funkcionalnost. U konanici se moe rei da inicijalni odabir izmeu ove dvije alternative i nije toliko bitan - pristup kojeg koriste je toliko slian a praenje funkcionalnosti toliko izraeno da se uenjem jednog jezika svladava veina bitnih koncepata iz drugog tako da se podatkovni znanstvenici esto na kraju odluuju na svladavanje oba jezika, kako bi se lako prilagodili velikom broju okruenja u kojima moraju provoditi svoje analize. 1.2 Instalacija programske podrke Instalacija programske podrke za jezik R je prilino jednostavna, pogotovo ako se kao platforma koristi preporueno razvojno suelje RStudio. Ovo nije jedina opcija - jedna od popularnih alternativa jest i viejezina platforma Jupyter Notebook koja nudi vlastitu podrku za R. itateljima se dugorono preporuuje istraivanje svih dostupnih opcija i konani odabir onog suelja koje osobno procijene najboljim za svoje potrebe, no ovaj udbenik e se usredotoiti na RStudio ponajvie zbog jasnog, preglednog suelja, lake instalacije i vrlo bogate podrke za razliite funkcionalnosti - od instalacije novih paketa, lakog dohvaanja dokumentacije, prikaza vizualizacija do stvaranja i objave izvjetaja. Radne biljenice o kojima e vie rijei biti u nastavku uglavnom pretpostavljaju da ste odabrali suelje RStudio. Za uspjeno postavljanje razvojne platforme potrebno je instalirati dvije stvari distribuciju jezika R razvojno suelje RStudio Preporuuje se koristiti najnovije dostupne inaice. U trenutku pisanja ovog dokumenta to su R 4.2.2 i RStudio 2022.07.2. Ukoliko se ove inaice razlikuju od one koje se nalaze na vaem raunalu, vjerojatno nee biti problema ukoliko su brojevi inaica vii od navedenih; u suprotnom preporuuje se njihova nadogradnja. U nastavku e se opisati postupak za instalaciju navedenog softvera na operacijski sustav Microsoft Windows. Ukoliko radite na nekom od drugih operacijskih sustava, kao to je neka od Linux distribucija ili Mac OS procedura je neto drugaija, no i dalje ne previe sloena - dovoljno je pratiti upute na web stranicama spomenutim u nastavku koje su orijentirane platformi koju koristite. Kako bi pronali spomenuti softver u trailicu upiite sljedee pojmove: download R download RStudio U oba sluaja dobiti ete stranice sa poveznicama na izvrne datoteke koje morate pokrenuti kako bi se softver instalirao na vae raunalo. U sluaju jezika R to moe biti datoteka R-4.2.2-win.exe (toni brojevi se mogu razlikovati). Kod suelja RStudio moete vidjeti vie opcija - odaberite besplatnu desktop inaicu. Komercijalne inaice imaju neke dodatne funkcionalnosti koje su veinom orijentirane uporabi u profesionalnim, viekorisnikim okruenjima te nisu bitne za uobiajeni rad. Izvrne datoteke moete pokrenuti i pustiti arobnjaka da instalira sve potrebne komponente na vae raunalo. Preporuuje se prihvatiti sve nazivne opcije osim mape instalacije - umjesto podmape Program Files bolje je instalirati R direktno u osnovnu mapu (npr. C:\\R\\R-4.2.2). Na ovaj nain biti e lake pronai trenutno instaliranu inaicu i eventualno kasnije aurirati. Iz istih razloga preporuuje se RStudio instalirati u mapu C:\\R\\RStudio. U sluaju da niste mogunosti ili ne elite odabrati ove mape, moete definirati neke druge ili zadrati nazivne opcije - ovaj izbor ne bi u konanici trebao bitno utjecati na daljnji rad. Nakon instalacije suelja RStudio dovoljno je isto jednostavno pokrenuti uz pomo stvorene kratice na radnoj mapi (ili alternativno, uz pomo izvrne datoteke RStudio.exe u odabranoj mapi za instalaciju). Nakon pokretanja aplikacija bi trebala izgledati slino sljedeoj slici: Slika 1.1: Izgled suelja RStudio Ukoliko je dolo do nekih problema, provjerite da li ste ispravno proveli sve navedene korake instalacije. U nastavku emo se pozabaviti detaljima prikazanog suelja. 1.3 Pregled razvojnog suelja RStudio Pogledajmo suelje RStudio. Vidimo da je podijeljeno na tri prozora - lijevi dio je radni i u njega upisujemo programski kod. S desne strane se nalaze pomoni prozori koji prikazuju razliite stvari, ovisno o odabranoj kartici; u gornjem desnom dijelu izmeu ostalog moemo vidjeti to se trenutno nalazi u naoj radnoj okolini (koja je na poetku prazna) te povijest naredbi koje smo izvravali. Donji dio slui za prikaz dokumentacije, datoteka u radnoj mapi, instaliranih paketa, vizualizacija i sl. 1.3.1 Interaktivna konzola Vratimo se na lijevi dio suelja. Ovdje se zapravo radi o tzv. interaktivnoj konzoli. Naime, po svojoj prirodi R je tzv. interpreterski jezik u smislu da se naredbe odmah interpretiraju i izvravaju. Iako je mogue izraivati i vee skripte koje se onda izvravaju u komadu, rad sa jezikom R vrlo esto se svodi na princip naredba - odgovor. Upravo zbog toga govorimo o interaktivnoj programskoj analizi podataka - analitiar programira upisivanjem naredbi te u svakom trenutku moe prouiti dobivene meurezultate i odluiti se na daljnje korake. Prikaimo kako radi interaktivna konzola. Uz pomo tipkovnice moemo utipkati jednostavan matematiki izraz - npr. 3 + 2 i stisnuti tipku ENTER. Vidimo da e nam R odmah pruiti rezultat - moemo ga koristiti i kao kalkulator! Za matematike izraze koje nije jednostavno utipkati moramo koristiti funkcije. Tako npr. drugi korijen moemo izraunati uz pomo funkcije sqrt(). Pokuajmo u konzolu utipkati sqrt(10) i stisnuti ENTER. R nam opet odmah prikazuje rezultat. U ovom trenutku zaslon bi nam trebao izgledati otprilike kao na sljedeoj slici. Slika 1.2: R kao kalkulator Jedan od problema ovakvog naina koritenja R-a jest taj to nam se mijeaju naredbe i rezultati, a povijest niza naredbi postaje sve tee vidljiva kako se koritenjem konzole sputamo sve nie i nie. Isto tako, ako iz nekog razloga naredba koju izvravamo rezultira grekom koju pokuavamo ispraviti, konzola vrlo brzo postaje prljava budui da se mijeaju korektni pozivi sa izvjetajima o grekama ime bilo kakva sloenija procedura koju elimo provesti postaje rastrgana i nepregledna. Zbog toga analitiari vrlo esto koriste tzv. R skripte koje omoguuju da vizualno izdvojimo naredbe koje elimo izvriti od same konzole, ali i dalje uz mogunost da ih lako upiemo u konzolu, slijedno izvrimo i pogledamo rezultat. 1.3.2 Pisanje R skripti Na alatnoj traci odaberimo File -&gt; New File -&gt; R Script (ili stisnemo kombinaciju tipaka CTRL + SHIFT + N). Vidimo da se radni dio na lijevoj strani razdvojio na dva dijela. Gornji dio predstavlja prostor za nau skriptu - zapravo niz naredbi koje elimo izvriti - dok interaktivna konzola sada zauzima donji dio radne plohe. Ukoliko elimo, moemo pomicanjem granice promijeniti veliinu ovih (a i ostalih prozora), no za sada je bitno da imamo pregled i skripte i konzole. Upiimo dvije naredbe u prozor za pisanje skripte - prva neka bude print(\"Pozdrav!\") a ispod nje opet jednostavan matematiki izraz 3 + 4. Vratimo kursor na prvi redak i stisnimo kombinaciju tipki CTRL + ENTER. Ukoliko smo ispravno pratili navedene korake, naredba na mjestu koje se nalazio kursor automatski e se preslikati u interaktivnu konzolu i izvriti. Kursor e sada biti na mjestu sljedee naredbe koju takoer moemo izvriti sa CTRL + ENTER. Zaslon bi sada trebao izgledati slino sljedeoj slici. Slika 1.3: R skripta Ovo je zapravo uobiajeni nain rada u jeziku R - u prostor za skripte upisujemo naredbe koje potom izvravamo njihovim automatskim preslikavanjem u konzolu. Ako neto ne tima s naredbom, lako ju preinaimo i ponovo izvrimo. Ukoliko elimo izvesti blok naredbi, odaberemo ih povlaenjem mia i izvrimo kombinacijom tipaka CTRL + ENTER. Skripte moemo proiriti komentarima (koji poinju znakom # kojeg R interpretira kao ovaj redak ignoriraj), a na kraju rada spremiti pod odabranim imenom na vrsti disk. No moemo otii i korak dalje. Iako su R skripte sasvim adekvatne za ugodan rad u jeziku R, postoji dodatna tehnologija koja nam omoguuje jo veu fleksibilnost u radu sa programskim jezikom R - R Markdown. 1.3.3 R Markdown Pisanje R skripti vrlo je slino klasinom poimanju programiranja - piemo programske naredbe koje se u pravilu izvravaju slijedno te kojima opcionalno dodajemo komentare u svrhu dokumentacije. No budui da je rad u R-u vrlo esto interaktivne prirode te da se kao zavrni korak neke analize podataka obino oekuje oblikovanje izvjetaja koji e na adekvatan nain prikazati dobivene rezultate, suelje RStudio podrava tehnologiju koja omoguuje uinkovitu kombinacije programiranja i strukturiranog dokumentiranja na principu interaktivne biljenice; analitiar moe pisatiisti\" tekst, opcionalno sa formulama, slikama te izmjenama veliine i prirode tekstualnog fonta, da bi potom u takav tekst ugradio izvrivi programski kod zajedno sa njegovim rezultatima. Tehnologija koja ovo omoguuje je tzv. R Markdown, koji je relativno nedavno proiren novim konceptom nazvanim R Notebook. Rad ove tehnologije najlake je prikazati preko primjera - u alatnoj traci odaberimo File -&gt; New File -&gt; R Markdown... te u iduem prozoru odaberimo proizvoljni naslov (npr. Proba), opcionalno ime autora te jednu od opcija za konani oblik izvjetaja (preporueno HTML zbog najmanje ovisnosti o dodatnim paketima). Za razliku od R skripte, R e kod novog R Markdown dokumenta stvoriti popunjeni dokument. Ovo je izvedeno na ovaj nain iz jednostavnog razloga da korisnik dobije predloak koji istovremeno slui i kao podsjetnik te kojeg onda lako izmjeni prema svojem nahoenju. Mi emo za nae potrebe obrisati vei dio ovog predloka - sve poslije inicijalnog zaglavlja, tj. ispod druge pojave znakova ---. Potom moemo ispod napisati bilo kakav tekst. Znakovima #, ##, ### itd. moemo postaviti naslov odreene kategorije (to sada nisu komentari, jer ovo zapravo nije R kod!), dok znakovima * i ** ispred i iza odabranih rijei odabiremo nakoeni ili masni otisak u konanom izvjetaju. Ovo je tzv. isti markdown, tj. obian tekst koji se uz pomo dodatnih alata moe pretvoriti u oblikovani tekst, ukoliko elimo. Kada elimo u ovaj na izvjetaj ugraditi programski kod, moramo stvoriti tzv. isjeak (engl. chunk). To moemo uiniti odabirom Insert -&gt; R na alatnoj traci ili kombinacijom tipaka CTRL + ALT + I. Uoite da isjeak poinje i zavrava posebno odabranim nizom znakova - tri apostrofa nalijevo (engl. backticks). Isto tako, poetak isjeka u vitiastim zagradama opisuje parametre isjeka, od ega je najvaniji programski jezik kojeg emo koristiti. U ovom udbeniku emo gotovo iskljuivo koristiti jezik R, iako je mogue koristiti i druge jezike ukoliko su oni instalirani na platformi na kojoj je pokrenut RStudio. Isjeak koda ponaa se isto kao i standardna R skripta - moemo upisivati naredbe i izvravati ih. Razlika je samo u tome to - ukoliko elimo - rezultate moemo vidjeti i odmah u samom R Markdown dokumentu. Ako nam ova opcija smeta moemo ju iskljuiti (klik na zupanik u alatnoj traci i odabir Chunk output in console) no u pravilu nam odgovara da se rezultat ugradi u dokument kako bi naknadno mogli ponovo pregledavati rezultate prethodnih isjeaka. Ako smo pratili upute, zaslon bi mogao izgledati slino sljedeoj slici: Slika 1.4: R Markdown dokument Ukoliko elimo, moemo pokuati stvoriti izvjetaj od trenutnog dokumenta. Prvo ga moramo spremiti pod odreenim imenom (npr. Proba.rmd), a potom moemo kliknuti na gumb Knit koji e dokument iz istog teksta pretvoriti u HTML datoteku. R Markdown dokumenti su puno moniji nego to se moda daje naslutiti do sada prikazanim elementima. Isjecima moemo dodavati niz parametara kako bismo utjecali na njihovo ponaanje. Izlazni oblik moe biti PDF, DOCX ali i drugi oblici kao to slajdovi raznih tehnologija, knjige namijenjene mobilnim ureajima, interaktivna Web aplikacija i sl. Udbenik kojeg itate zapravo nije nita drugo do niz RMD datoteka pretvoren u adekvatni oblik kojeg trenutno koristite. Kao to emo objasniti u sljedeem poglavlju, RMD datoteke su takoer i glavni nain na kojeg ete moi na interaktivan nain pratiti ovaj udbenik i isprobavati primjere i zadatke koje slijede. Univerzalnost i fleksibilnost tehnologije R Markdown je iznimno velika, emu u prilog govori i njezina velika popularnost u R zajednici. 1.4 Kako koristiti ovaj udbenik? Osnovna ideja ovog udbenika jest uenje kroz primjenu. Zbog toga se u lekcijama u nastavku nee koristiti previe primjera, ve se itatelja potie da svaki novi koncept usvoji kroz rjeavanje niza lakih i teih zadataka. Svako poglavlje koje slijedi ima prateu radnu biljenicu. Jednostavno reeno, radi se o RMD datoteci koja sadri sve primjere iz zadatke iz ovog udbenika, popraene saetim tekstom radi lakeg snalaenja i referenciranja na koncepte koji se obrauju. Osnovna ideja je da itatelj paralelno ita udbenik i rjeava radnu biljenicu, gledajui rjeenje zadatka tek nakon to ga samostalno rijei unutar programskog alata. Poneki zadaci zahtijevati e jednostavno uklanjanje znaka # (koji oznaava komentar) sa poetka naredbe te njezino izvravanje. Usprkos trivijalnom pristupu, na ovaj nain se ipak jasnije potie itatelja za samostalno isprobavanje naredbe, umjesto da samo pogleda njezin rezultat. Drugi zadaci zahtijevati e neto vei angaman. Konano, nakon svake lekcije nalazi se niz Zadataka za vjebu uz koje se nee nalaziti rjeenje te koji e predstavljati svojevrsnu provjeru svih danih koncepata lekcije. itateljima se snano preporuuje rjeavanje svih primjera i zadataka prije prelaska na iduu lekciju, budui da lekcije koje slijede pretpostavljaju dobro usvojeno znanje svih do tada obraenih tema. Naravno, udbenik je mogue itati i bez navedenog interaktivnog pristupa. Rjeenja uz zadatke otkrivaju ispravnu metodu pristupa problemu, a veina naredbi popraena je ispisom kojeg bi korisnik dobio na zaslonu njihovim izvravanjem. Usprkos tome, stav autora udbenika jest da se programski jezici ne mogu uiti itanjem te da se dodatni trud isprobavanja svih, pa ak i najjednostavnijih koncepata, u konanici viestruko isplati. Upoznajmo se poblie sa konceptom radnih biljenica. Prvo je potrebno pronai i otvoriti radnu biljenicu koja odgovara lekciji koju itate. Nju je lako prepoznati prema odgovarajuem broju lekcije - radna biljenica za ovu lekciju nosi naziv 01_Uvod_RB.Rmd. Preporuuje se da sve radne biljenice na kojima namjeravati raditi kopirate negdje na lokalno raunalo zajedno sa svim prateim datotekama koje se nalaze u istoj mapi ako ih ima. Kao to je reeno, radna biljenica e u pravilu sadravati sav programski kod lekcije na koje se odnosi, ali samo dio teksta koliko je dovoljno za lake snalaenje. Ukoliko ovaj tekst itate direktno iz radne biljenice, a ne kao dio udbenika, moete vidjeti da nedostaje cijeli prethodni dio lekcije; to je zato to se uvodni koraci opisani u njemu tiu koncepata koje je potrebno usvojiti prije koritenja radne biljenice. Ako ih niste proli, preporuka je da se vratite i proete ih te potom nastavite sa primjerima i zadacima koji slijede. Radne biljenice razlikuju Primjere i Zadatke. Primjere je u pravilu potrebno samo izvriti. Zadaci s druge strane oekuju izvjesne preinake ili unos novog programskog koda. Kao to je reeno, udbenik e postaviti daleko vei naglasak na zadatke. Primjer moe izgledati ovako: Primjer - nekoliko jednostavnih naredbi R programskog jezika 3+2 #zbrajanje log(10) # prirodni logaritam! log10(10) # ovo je logaritam baze 10! Usput, komentare piemo znakom &quot;#&quot; sin(0.5 * pi) # pi je jedna od ugraenih konstanti ## [1] 5 ## [1] 2.302585 ## [1] 1 ## [1] 1 Naredbe iz primjera moete izvriti pojedinano, ili cijeli isjeak odjednom kombinacijom tipaka CTRL + SHIFT + ENTER. Nikakve preinake koda nisu nune (iako esto nije loe eksperimentirati sa danim naredbama!). Zadaci s druge strane uvijek trae odreenu - makar minimalnu - intervenciju. Zadatak 1.1 - naredbe za provjeru i izmjenu radne mape # izvrite sljedee naredbe uklanjanjem znaka komentara #getwd() # mapa u kojoj trenutno radimo #setwd(&quot;.&quot;) # ovdje moemo navesti novu radnu mapu ukoliko elimo getwd() # mapa u kojoj trenutno radimo setwd(&quot;.&quot;) # ovdje moemo navesti novu radnu mapu ukoliko elimo Zadatak e se esto odnositi na upravo uvedeni koncept. Npr. zgodno je za napomenuti da, iako jezik R podrava operator = za pridruivanje vrijednosti nekoj varijabli, preporuuje se koritenje operatora &lt;- u tu svrhu koji je neto vie R-ovski. Takoer, uoimo da R podrava tzv. autoprint, tj. uvijek e ispisati rezultat zadnje naredbe na zaslon. To znai da ako u isjeku stvaramo novu varijablu x te ju elimo ispisati na zaslon, ne moramo kao zadnju naredbu staviti print(x) ve je dovoljno staviti samo x. Isprobajmo ovo u zadatku. Zadatak 1.2 - R-ovski operator pridruivanja # upiite `5` u varijablu `x` # potom ispiite varijablu `x` na zaslon x &lt;- 5 x ## [1] 5 Sada kada smo se dobro upoznali sa radnom platformom, moemo poeti sa uenjem osnovnih elemenata programskog jezika R. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["tipovi.html", "2 Osnovni tipovi podataka i operatori 2.1 Osnovni tipovi podataka 2.2 Operatori 2.3 Nedostajue, nepoznate i nemogue vrijednosti Zadaci za vjebu", " 2 Osnovni tipovi podataka i operatori Osnovni ili primitivni tipovi podataka su temeljni izgradbeni blokovi programskih jezika. Ovdje se najee misli na ugraene mehanizme koji omoguuju pohrane elementarne informacije - najee logikog, numerikog ili znakovnog tipa. Veina programskih jezika koristi iste ili vrlo sline naine pohrane takvih informacija, to znai da implementira sline osnovne tipove podataka - razlika je esto u detaljima kao to su sam naziv tipa, nazivni broj bajtova za odreeni tip podatka i sl. U svakom sluaju najei prvi korak kod uenja novog programskog jezika jest upoznavanje osnovnih tipova podataka koje isti podrava. Sljedea stvar koja nas potom moe zanimati jest sintaksa jezika, tj. nain na kojeg piemo naredbe koje interpreter jezika moe razumjeti i izvriti. Jezik R u svojoj sintaksi slijedi sline konvencije viene u jezicima kao to su Python, Ruby ili Java, naravno uz izvjesne specifinosti to je uobiajeno za svaki novi programski jezik. Neka sintaksna pravila koje je korisno znati su sljea: svaka naredba (u pravilu) mora ii u svoj redak uvlaenje naredbi unutar blokova je preporueno ali nije obvezno, kao ni stavljanje toke-zareza na kraj naredbe blokove definiramo vitiastim zagradama, slino jezicima Java ili C tipove varijabli ne definiramo unaprijed, oni se prilagoavaju pridruenoj vrijednosti komentari zapoinju znakom # Umjesto navoenja niza pravila sintaksu emo najbolje nauiti kroz primjere - uz upoznavanje sa jednostavnim funkcijama i operatorima, to emo i uiniti u ovoj lekciji. Nakon pregleda osnovnih tipova i operatora zavretak lekcije emo posvetiti rapsravi o tzv. nedostajuim ili nepostojeim vrijednostima, koje imaju posebno vanu ulogu kod uobiajenog koritenja programskog jezika R. 2.1 Osnovni tipovi podataka R poznaje est osnovnih tipova podataka: tip izvorni naziv tipa primjeri logiki logical TRUE, FALSE ili T, F cjelobrojni integer 2L, 5L, 123456789L realni double 4, 6, 3.14, 2e5 kompleksni complex 5 + 2i, 7 + 1i znakovni character \"A\", \"B\", \"Pero\", \"ABCDEFGHijklmnoPQRSTUVwyz\" bajtovi raw as.raw(2), charToRaw(\"1\") Dobro je znati: cjelobrojni i realni tipovi se esto zajedno tretiraju kao tip numeric (iako ovo nije u potpunosti konzistentno!) kompleksni tip mora imati deklariranu imaginarnu konstantu ak i ako je ona 1 (2 + i nije dobar zapis!) tip sirovih bajtova se relativno rijetko koristi Provjeru da li je neka varijabla odreenog tipa moemo raditi uz pomo funkcije is.&lt;naziv_tipa&gt;, to emo demonstrirati u sljedeem zadatku. Prije samog zadatka potrebno je napomenuti sljedee: kako bi ispis programskih odsjeaka bio to pregledniji potruditi emo se vizualno odvojiti razliite segmente ispisa. U tu svrhu emo koristiti naredbu cat(\"-----------\\n\") koja e na zaslon ispisati niz crtica i potom prijei u novi red. Ovdje moemo koristiti i funkciju print(), no naredba cat je ovdje bolji izbor samo zbog injenice da print uvijek ispis zapoinje indeksom prikazanog elementa, to nam kod ovakvog tipa ispisa nije potrebno. Zadatak 2.1 - provjera tipova podataka #isprobajte sljedee naredbe: #is.logical(FALSE) #is.integer(2L) #is.double(1.11) # izvedite sljedee provjere: # da li je 5L numeriki tip? # da li je 3.14 numeriki tip? # da li je &quot;ABC&quot; znakovni tip? # da li je 4 + 2i kompleksni tip? # da li je 5 cjelobrojni tip? is.logical(FALSE) is.integer(2L) is.double(1.11) cat(&quot;-----------\\n&quot;) is.numeric(5L) is.numeric(3.14) is.character(&quot;ABC&quot;) is.complex(4 + 2i) is.integer(5) ## [1] TRUE ## [1] TRUE ## [1] TRUE ## ----------- ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] FALSE Da li ste uoili neto neobino u ovim provjerama? Pokuajte objasniti dobiveni rezultat. Tip neke varijable ili konstante moemo dohvatiti uz pomo funkcija typeof ili class. Razlika izmeu njih je sljedea: typeof - dohvaa primitivni ili osnovni tip podatka (integer, double ) class - objektni tip, zapravo vrijednost atributa class Zadatak 2.2 - dohvat naziva tipa podatka # ispiite tipove sljedeih konstanti: TRUE, 2L, F, 3.14, &quot;ABC&quot; # ispiite klase istih konstanti. Ima li razlike? typeof(TRUE) typeof(2L) typeof(F) typeof(3.14) typeof(&quot;ABC&quot;) cat(&quot;-----------\\n&quot;) class(TRUE) class(2L) class(F) class(3.14) class(&quot;ABC&quot;) ## [1] &quot;logical&quot; ## [1] &quot;integer&quot; ## [1] &quot;logical&quot; ## [1] &quot;double&quot; ## [1] &quot;character&quot; ## ----------- ## [1] &quot;logical&quot; ## [1] &quot;integer&quot; ## [1] &quot;logical&quot; ## [1] &quot;numeric&quot; ## [1] &quot;character&quot; Podatke moemo eksplicitno pretvarati iz jednog tipa u drugi uz pomo funkcije as.&lt;naziv_tipa&gt;: Zadatak 2.3 - pretvorba tipova podataka # Izvedite sljedee pretvorbe i ispiite rezultat # 2.35 u integer # TRUE u numeric # 100L u character # 2.35 u character # 2e2 u character # 0 u logical # 2.75 u logical as.integer(2.35) as.numeric(TRUE) as.character(100L) as.character(2.35) as.character(2e2) as.logical(0) as.logical(2.75) ## [1] 2 ## [1] 1 ## [1] &quot;100&quot; ## [1] &quot;2.35&quot; ## [1] &quot;200&quot; ## [1] FALSE ## [1] TRUE R e sam provoditi implicitnu pretvorbu ukoliko je mogua: Zadatak 2.4 - implicitna pretvorba # napiite izraze koji odgovaraju sljedeem i ispiite rezultat: # aritmetiki operator izmeu logike i numerike varijable # aritmetiki operator izmeu cjijelog i realnog broja # logiki operator negacije primjenjen na numeriku varijablu # aritmetiki operator izmeu logike i numerike varijable TRUE + 5 # aritmetiki operator izmeu cjelobrojne i numerike varijable 5L + 3.14 # logiki operator negacije primjenjen na numeriku varijablu !25 ## [1] 6 ## [1] 8.14 ## [1] FALSE Implicitna pretvorba e se izvesti samo ako je smislen - npr. aritmetiki operator izmeu znakovne i numerike varijable rezultirati e grekom. 2.2 Operatori Kao i u drugim programskim jezicima, R dozvoljava koritenje operatora u izrazima. Neki od ee koritenih operatora su: aritmetiki +, -, *, /, ** ili ^ (potencija), %% (modulo), %/% (cjelobrojno dijeljenje) usporedni &lt;, &lt;=, &gt;, &gt;=, ==, != logiki ! (negacija), &amp;&amp; (skalarni i), || (skalarni ili), &amp; (vektorski i), | (vektorski ili) pridruivanje &lt;- ili = Zadatak 2.5 - operatori # isprobajte izraze `5 / 2` i `5 %/% 2` # provjerite koliko iznosi &quot;17 na kvadrat&quot; i &quot;ostatak dijeljenja 101 sa 12&quot; # provjerite to je rezultat sljedeih izraza: `17 &gt; 13`, `!TRUE`, `5 &amp;&amp; 0`, `0. || 2` # isprobajte izraze `5 / 2` i `5 %/% 2` 5 / 2 5 %/% 2 cat(&quot;-----------\\n&quot;) # provjerite koliko iznosi &quot;17 na kvadrat&quot; i &quot;ostatak dijeljenja 101 sa 12&quot; 17 ^ 2 101 %% 12 cat(&quot;-----------\\n&quot;) # provjerite to je rezultat sljedeih izraza: `17 &gt; 13`, `!TRUE`, `5 &amp;&amp; 0`, `0. || 2`, 17 &gt; 13 !TRUE 5 &amp;&amp; 0 0. || 2 ## [1] 2.5 ## [1] 2 ## ----------- ## [1] 289 ## [1] 5 ## ----------- ## [1] TRUE ## [1] FALSE ## [1] FALSE ## [1] TRUE Logike vrijednosti i usporedne operatore najee emo koristiti kod tzv. uvjetnog izvoenja naredbi, poznatog iz drugih programskih jezika kao IF ELSE naredba. U R-u njezina sintaksa izgleda ovako: if (izraz) {blok} else {blok} Isprobajmo ovu naredbu na sljedeem zadatku: Zadatak 2.6 - uvjetno izvoenje naredbi # napiite naredbu koja izvodi sljedee: # &quot;ako je 100 paran broj ispii &#39;Uspjeh!&#39;&quot; if (100 %% 2 == 0) print(&quot;Uspjeh!&quot;) ## [1] &quot;Uspjeh!&quot; Uoili smo gore da imamo dvije vrste logikih operatora za i i ili. Razliku emo objasniti kasnije, za sada je dovoljno rei da se kod uvjetnog izvoenja naredbi ili programskih petlji gotovo iskljuivo koristimo operatorima &amp;&amp; i || (C++ - ovski operatori!). Isto tako, ve smo spomenuli da R nudi dva operatora pridruivanja, &lt;- i =. Izmeu njih postoje neke sitne razlike, no one nemaju gotovo nikakav utjecaj na uobiajeno koritenje ovog operatora u praksi. U literaturi se za pridruivanje vrijednosti novim varijablama moe vidjeti i jedna i druga inaica, no mi emo u nastavku primarno i konzistentno koristiti &lt;-, ponajvie zato kako bi programski kod bio vizualno distinktivniji od drugih programskih jezika. NAPOMENA: za jednostavniji upis operatora &lt;- moemo se koristiti kombinacijom tipaka ALT i - Kod pridruivanja pazimo da je s lijeve strane tzv. lijeva vrijednost (engl. lvalue). Ovo u programerskom smislu interpretiramo kao neto u to se moe pohraniti izraunata vrijednost. x + 1 &lt;- 2 # greka!!!] U pravilu se u R-u kao lvalue koristi varijabla, iako se tu ponekad moe pojaviti i poziv funkcije. Ovu moda inicijalno zbunjujuu pojavu razjasniti emo kasnije. Imenovanje varijabli uglavnom slijedi pravila iz drugih programskih jezika - dozvoljena su slova, brojke, podcrta ali i toka . Prvi simbol mora biti slovo ili toka. .mojaVarijabla &lt;- 5 #OK moja.Varijabla &lt;- 5 #OK _mojaVarijabla &lt;- 5 # nije OK 123Varijabla &lt;- 5 # nije OK U praksi za varijable sloenih imena trebamo odabrati jednu od sljedeih konvencija: mojaVarijabla &lt;- 1 # tzv. camelcase moja_varijabla &lt;- 2 # podcrta ili moja.varijabla &lt;- 3 # toka Bitno je da u programskom kodu ne mijeamo konvencije tj. da nakon odabira budemo konzistentni. Ukoliko ba inzistiramo na udnim imenima koja koriste specijalne znakove, onda ih moramo staviti pod tzv. lijeve jednostruke apostrofe (engl. backticks): Zadatak 2.7 - ime varijable sa specijalnim znakovima # upiite proizvoljno ime sa specijalnim znakovima unutar lijevih apostrofa # i ispiite vrijednost varijable #`` &lt;- 2 `!%^$*@__=` &lt;- 2 `!%^$*@__=` ## [1] 2 Ovakav nain imenovanja varijabli nije previe koristan u praksi, ali ima i svoju svrhu - budui da su operatori u R-u zapravo funkcije (ija su imena doslovno +, ^ i sl.) upotrebom lijevih apostrofa moemo ih direktno referencirati u njihovom originalnom obliku, to se moe pokazati vrlo praktinim kod tzv. funkcijskog programiranja (o emu emo govoriti u jednoj od buduih lekcija). Pridjeljivanje vrijednosti novim nazivima varijabli mi zapravo stvaramo nove varijable u radnoj okolini (koja se u R-u naziva globalna okolina). Sve varijable koje smo do sada stvorili moemo vidjeti uz pomo funkcije ls(). Ukoliko elimo obrisati neke varijable, samo navedemo njihova imena u pozivu funkcije rm() (npr. rm(x, y, z)). Za brisanje svih varijabli iz radne okoline koristimo poziv rm(list=ls()), s time to tu moramo biti oprezni (nema undo!). Zadatak 2.8 - ispis i brisanje varijabli globalne okoline # ispiite sve do sada stvorene varijable globalne okoline # obriite neke od gore ispisanih varijabli - npr. rm(x, y, z) # ponovo ispiite dostupne varijable # obriite SVE varijable globalne okoline # (oprezno s ovim pozivom u praksi!) # uvjerite se da je globalna okolina prazna # ispiite sve do sada stvorene varijable globalne okoline ls() # obriite neke od upravo ispisanih varijabli - npr. rm(x, y, z) # ponovo ispiite dostupne varijable rm(x, y) ls() # obriite SVE varijable globalne okoline # (oprezno s ovim pozivom u praksi!) # uvjerite se da je globalna okolina prazna rm(list=ls()) ls() Konano, kad god nam treba pomo oko neke funkcije, imamo sljedee opcije na raspolaganju: napiemo samo &lt;ime_funkcije&gt; (bez zagrada sa parametrima) i stisnemo - ukoliko je funkcija pisana u R-u (a nije samo proxy prema implementaciji u C-u) na zaslon emo dobiti ispis izvornog koda funkcije napiemo help(&lt;ime_funkcije&gt;) ili ?&lt;ime_funkcije&gt; ime dobijamo stranicu pomoi o funkciji sa popisom parametara, primjerima i sl. napiemo example(&lt;ime_funkcije&gt;) pri emu dobijemo popis primjera koritenja funkcije i dobivenih rezultata Sljedei isjeak koda prikazuje nain koritenja gornjih metoda (zbog tednje prostora ne prikazujemo njihov rezultat). #programski kod funkcije `ls` ls # pomo za funkciju `ls` ?ls # ili help(ls) # primjeri koritenja funkcije `ls` example(ls) 2.3 Nedostajue, nepoznate i nemogue vrijednosti U R-u postoji tri naina modeliranja nepostojeih vrijednosti: NA - (not available) nedostajua ili nepoznata vrijednost odreenog tipa NaN - (not a number) nemogui broj, npr. 0/0 NULL - nepostojea vrijednost, doslovno nita Zadatak 2.9 - rad sa NA, NaN i NULL # Koliko je &quot;5 + nepoznati broj&quot;? # Koliko je &quot;5 + nepostojei broj&quot;? # provjerite klase sljedeih konstanti i izraza: # NA # aritmetika operacija izmeu numeric i NA # NaN # NULL # Koliko je &quot;5 + nepoznati broj&quot;? 5 + NA # Koliko je &quot;5 + nepostojei broj&quot;? 5 + NaN cat(&quot;-----------\\n&quot;) # provjerite klase sljedeih konstanti i izraza i objasnite rezultat: # NA # aritmetika operacija izmeu numeric i NA # NaN # NULL class(NA) # logiki tip je &quot;najslabiji&quot;! class(5 + NA) class(NaN) class(NULL) ## [1] NA ## [1] NaN ## ----------- ## [1] &quot;logical&quot; ## [1] &quot;numeric&quot; ## [1] &quot;numeric&quot; ## [1] &quot;NULL&quot; Provjeru nedostajuih vrijednosti radimo slino provjeri tipova podataka - koristimo funkcije is.na, is.nan i is.null. Moramo voditi rauna da je NaN zapravo podvrsta od NA te da je NULL zapravo potpuno zasebna klasa sa specifinim ponaanjem - pokuaj aritmetikih ili logikih operacija nad NULL vrijednosti nee rezultirati novom nepostojeom vrijednosti ve upozorenjima i praznim rezultatima. Ovo je posebno bitno napomenuti poznavateljima jezika SQL - ono to je NULL u SQL-u je NA u R-u i to je ono to u pravilu koristimo u praksi, dok NULL ima vrlo specifine primjene te ga puno rjee koristimo u programskom kodu. Zadatak 2.10 - provjera vrijednosti NA, NaN i NULL # to je od idueg NA? NA, NaN, NULL, &quot;&quot;, 0 # to je od idueg NaN? NA, NaN, NULL # to je od idueg NULL? NA, NaN, NULL # to je od idueg NA? NA, NaN, NULL, &quot;&quot;, 0 is.na(NA) is.na(NaN) is.na(NULL) is.na(&quot;&quot;) is.na(0) cat(&quot;-----------\\n&quot;) # to je od idueg NaN? NA, NaN, NULL is.nan(NA) is.nan(NaN) is.nan(NULL) cat(&quot;-----------\\n&quot;) # to je od idueg NULL? NA, NaN, NULL is.null(NA) is.null(NaN) is.null(NULL) ## [1] TRUE ## [1] TRUE ## logical(0) ## [1] FALSE ## [1] FALSE ## ----------- ## [1] FALSE ## [1] TRUE ## logical(0) ## ----------- ## [1] FALSE ## [1] FALSE ## [1] TRUE Za kraj posvetimo se malo NA vrijednosti, budui da emo ju vrlo esto susretati u praksi. Pojednostavljeno reeno, ukoliko se pojavljuju NA vrijednosti, moemo oekivati sljedee nuspojave: rezultati aritmetikih izraza rezultiraju sa NA vrijednosti rezultati poziva nekih funkcija rezultiraju sa NA (osim ako ne navedemo kompenzacijske akcije, kao npr. parametar na.rm = T koji zapravo znai ignoriraj NA) rezultati logikih izraza mogu ali ne moraju rezultirati sa NA vrijednosti ovisno o tom da li izraz ovisi o NA ili ne (npr. TRUE || NA ima rezultat TRUE, ali FALSE || NA ima rezultat NA) S ovim zadnjim moramo biti posebno oprezni, budui da NA u uvjetnom izrazu rezultira grekom: if (NA &lt; 2) print(&quot;Uspjeh!&quot;) # greka!! U ovoj lekciji upoznali smo se sa osnovnim elementima jezika R. U radu s R-om u pravilu radimo sa sloenim tipovima podataka koje emo upoznati u nastavku - a to su vektori, matrice, podatkovni okviri i liste. Zadaci za vjebu to je rezultat sljedeih naredbi? Razmislite o moguem rezultatu prije izvravanja. as.complex(2) as.integer(-3.25) as.logical(&quot;0&quot;) as.numeric(TRUE) as.character(11.5+2i) as.numeric(&quot;ABC&quot;) Kako u R-u izgledaju sljedei opisni izrazi: tri puta deset na devetu logaritam od 5 cjelobrojno dijeljenje 10 sa 3 ostatak cjelobrojnog dijeljenja 10 sa 3 tangens od 75 stupnjeva | Uz pomo if izraza provjerite da li se rezultat dijeljenja nule s nulom smatra kao vrijednost NA, NaN ili NULL. Ubacite u varijablu x vrijednost 5. Ispiite sve varijable okoline. Potom u varijablu x ubacite NULL. Postoji li i dalje ova varijabla? Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
